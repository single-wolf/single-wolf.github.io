<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ByteToMessageDecoder问题的解决</title>
      <link href="/2019/09/25/To-Solve-Two-Problem-In-Using-ByteToMessageDecoder/"/>
      <url>/2019/09/25/To-Solve-Two-Problem-In-Using-ByteToMessageDecoder/</url>
      
        <content type="html"><![CDATA[<p>在使用某RPC框架过程中，遇到两个因使用 <code>ByteToMessageDecoder</code> 不当而导致的两个小问题，如下列示例代码所示：</p><pre>    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List\<object\> list) throws Exception {        byteBuf.markReaderIndex();        int dataLength = byteBuf.readInt();        if (byteBuf.readableBytes() < dataLength) {            // 未校验最大长度，存在安全隐患            byteBuf.resetReaderIndex();            return;        }        int rpcMagicVal = byteBuf.readShort();        if (rpcMagicVal != Rpc.MAGIC_VALUE) {            // 此处直接close或抛异常后close将导致decode()被重复调用            ctx.close();        }        // DO ACTUAL CODEC    }</object\></pre><a id="more"></a><h3 id="问题一-未对报文做长度校验，存在OOM隐患"><a href="#问题一-未对报文做长度校验，存在OOM隐患" class="headerlink" title="问题一 未对报文做长度校验，存在OOM隐患"></a>问题一 未对报文做长度校验，存在OOM隐患</h3><p>如上面代码片段中：</p><pre>        byteBuf.markReaderIndex();        int dataLength = byteBuf.readInt();        // byteBuf中可读信息不足，等待后续报文        if (byteBuf.readableBytes() < dataLength) {            // 未校验最大长度，存在安全隐患            byteBuf.resetReaderIndex();            return;        }</pre><p>当收到的报文长度标识位过长，则 <code>ByteToMessageDecoder</code> 继续将把后续报文存入 <code>ByteBuf</code> 中，当遇到恶意报文时将导致应用<strong>OOM</strong>。顺便提一下 <code>ByteToMessageDecoder</code> 中提供两种 <code>ByteBuf</code> 的叠加机制。</p><ol><li><strong>MERGE_CUMULATOR</strong> 通过拷贝来实现叠加，不足则申请新 <code>ByteBuf</code> 再拷贝进去</li><li><strong>COMPOSITE_CUMULATOR</strong> 通过组合来实现叠加，直接使用 <code>CompositeByteBuf</code>不需要拷贝</li></ol><p>默认的是使用<strong>MERGE_CUMULATOR</strong>，在累计报文大小到达 <code>DIRECT_MEMORY_LIMIT</code>的一半或是堆内存的一半时，应用就将<strong>OOM</strong>报错</p><h3 id="问题二-关闭Channel前未释放ByteBuf，导致decode-被多次调用"><a href="#问题二-关闭Channel前未释放ByteBuf，导致decode-被多次调用" class="headerlink" title="问题二 关闭Channel前未释放ByteBuf，导致decode()被多次调用"></a>问题二 关闭Channel前未释放ByteBuf，导致decode()被多次调用</h3><p>如上面代码片段中：</p><pre>        int rpcMagicVal = byteBuf.readShort();        if (rpcMagicVal != Rpc.MAGIC\_VALUE) {            // 此处直接close将导致decode()被重复调用            ctx.close();        }</pre><p>或是如</p><pre>        int rpcMagicVal = byteBuf.readShort();        if (rpcMagicVal != Rpc.MAGIC\_VALUE) {            // 此处直接抛异常并在别的Handler做channel.close()将导致decode()被重复调用            throw new RuntimeException("INVALID MSG");        }</pre><p>当解析报文遇到不合法的报文时，上面代码选择关闭此 <code>channel</code>，并为对 <code>byteBuf</code> 进行释放，这将导致此 <code>ByteToMessageDecoder</code> 的实现类的 decode() 方法被多次调用。造成此问题的原因有两</p><h4 id="多次调用原因一（直接在decode调用close）"><a href="#多次调用原因一（直接在decode调用close）" class="headerlink" title="多次调用原因一（直接在decode调用close）"></a>多次调用原因一（直接在decode调用close）</h4><p><code>Netty4</code> 默认每个 <code>Channel</code> 上所有操作都归一个线程排队操作，所以在调用了 <code>ctx.close()</code> 并不会立即触发 <code>channelInactive</code> 等。线程将继续走完本次 <code>decode()</code> ，而我们看父类调用此  <code>decode()</code> 的地方 <code>ByteToMessageDecoder.callDecode()</code> </p><pre>    protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List\<object\> out) {        try {            // 只要是可读就循环            while (in.isReadable()) {                int outSize = out.size();                if (outSize > 0) {                    fireChannelRead(ctx, out, outSize);                    out.clear();                    if (ctx.isRemoved()) {                        //被Remove才跳出                        break;                    }                    outSize = 0;                }                int oldInputLength = in.readableBytes();                // 实际调用子类decode()方法处                decodeRemovalReentryProtection(ctx, in, out);                if (ctx.isRemoved()) {                    //被Remove才跳出                    break;                }                if (outSize == out.size()) {                    if (oldInputLength == in.readableBytes()) {                        // 未解码出东西且未移动读索引则跳出                        break;                    } else {                        //否则继续                        continue;                    }                }                // ignore some code            }        } catch (DecoderException e) {            throw e;        } catch (Exception cause) {            throw new DecoderException(cause);        }    }</object\></pre><p>如上所示在我们未解码出东西放入 <code>out</code> 且移动了读索引 <code>byteBuf.readShort()</code> 情况下是满足循环条件的，因此不可避免地就<strong>对一条错误的报文多次调用<code>decode()</code></strong></p><h4 id="多次调用原因二（在decode中throw-Exception）"><a href="#多次调用原因二（在decode中throw-Exception）" class="headerlink" title="多次调用原因二（在decode中throw Exception）"></a>多次调用原因二（在decode中throw Exception）</h4><p>如上面代码所示，直接在其中抛出异常貌似能跳出 <code>while (in.isReadable())</code> 的循环，为什么还是会调用 <code>decode()</code> 呢？</p><p>这是因为设计者为了防止 <code>channel.close()</code> 后而丢失暂存在 <code>ByteToMessageDecoder</code> 的信息，在  <code>ByteToMessageDecoder.channelInactive()</code> 中还进行了如下操作：</p><pre>    void channelInputClosed(ChannelHandlerContext ctx, List\<object\> out) throws Exception {        // 若累计暂存的ByteBuf不为空，则继续调用上段代码循环解码        if (cumulation != null) {            callDecode(ctx, cumulation, out);            decodeLast(ctx, cumulation, out);        } else {            // 方法内容如下，其实不进行任何操作            decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);        }    }        protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List\<object\> out) throws Exception {        if (in.isReadable()) {            decodeRemovalReentryProtection(ctx, in, out);        }    }</object\></object\></pre><h4 id="两种原因通用的解决方案"><a href="#两种原因通用的解决方案" class="headerlink" title="两种原因通用的解决方案"></a>两种原因通用的解决方案</h4><p>在调用  <code>ctx.close()</code> 或 抛出异常前将所给参数 <code>byteBuf</code> 变成不可读，如下：</p><pre>        int rpcMagicVal = byteBuf.readShort();        if (rpcMagicVal != Rpc.MAGIC_VALUE) {            // 或byteBuf.readerIndex(byteBuf.writerIndex())均可            byteBuf.skipBytes(byteBuf.readableBytes());            ctx.close();        }</pre><p>此方案能解决第二种起因的道理是 父类的调用解码的入口方法 <code>ByteToMessageDecoder.channelRead()</code> finally    代码块中会对不为空但不可读的叠加 <code>ByteBuf</code> 做释放并置空。</p><pre>    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        if (msg instanceof ByteBuf) {            CodecOutputList out = CodecOutputList.newInstance();            try {                // ignore some code                callDecode(ctx, cumulation, out);            } catch (DecoderException e) {                throw e;            } catch (Exception e) {                throw new DecoderException(e);            } finally {                // 对不为空但不可读的叠加ByteBuf做释放并置空                if (cumulation != null && !cumulation.isReadable()) {                    numReads = 0;                    cumulation.release();                    cumulation = null;                }                // ignore some code            }        } else {            ctx.fireChannelRead(msg);        }    }</pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由RestartClassLoader探索Springboot热部署</title>
      <link href="/2019/08/07/Spring-Hot-Reload-Problem/"/>
      <url>/2019/08/07/Spring-Hot-Reload-Problem/</url>
      
        <content type="html"><![CDATA[<p>在SpringBoot项目引入的依赖的代码中发现下面这样问题，最终确定是由RestartClassLoader导致的，由此展开一步一步探索<br><code><br>// 类名一致，但加载出的类却不相等<br>Class.forName(paramClassNames) == paramClass // false<br></code></p><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Debug 发现 <code>paramClass .getClassLoader()</code> 居然是个<code>RestartClassLoader </code>，然而 <code>Class.forName()</code> 方法则用的是当前调用者的ClassLoader，发现是普通的应用类加载器<code>AppClassLoader</code></p><pre>// JDK Class.forName()方法@CallerSensitivepublic static Class<?> forName(String className) throws ClassNotFoundException {    Class<?> caller = Reflection.getCallerClass();     return forName0(className, true, ClassLoader.getClassLoader(caller), caller);}</pre><h4 id="那么疑问来了"><a href="#那么疑问来了" class="headerlink" title="那么疑问来了"></a>那么疑问来了</h4><ol><li>为什么引用依赖的代码的类加载器是<code>AppClassLoader</code>而项目代码<code>paramClass</code>的类加载器是<code>RestartClassLoader </code>？</li><li>自定义<code>RestartClassLoader </code>的目的、或者说功能是什么？</li></ol><h4 id="为什么ClassLoader不一致"><a href="#为什么ClassLoader不一致" class="headerlink" title="为什么ClassLoader不一致"></a>为什么ClassLoader不一致</h4><p>全局搜索<code>RestartClassLoader </code> 发现其属于依赖 Spring-boot-devtools 引入的包，继承自<code>URLClassLoader</code>，是Spring热部署功能代码，继续反查源码寻找到此类加载器唯一生效的地方。</p><pre>// RestartClassLoader 类构造函数public RestartClassLoader(ClassLoader parent, URL[] urls,        ClassLoaderFileRepository updatedFiles, Log logger) {    super(urls, parent); 。// 父类 URLClassLoader 构造函数}</pre><pre>// Restarter 类中，忽略部分行private Throwable doStart() throws Exception {    ClassLoader parent = this.applicationClassLoader;    URL[] urls = this.urls.toArray(new URL[this.urls.size()]);    ClassLoaderFiles updatedFiles = new ClassLoaderFiles(this.classLoaderFiles);    ClassLoader classLoader = new RestartClassLoader(parent, urls, updatedFiles,            this.logger);    return relaunch(classLoader);}</pre><p>可以看到唯一实例化此类加载器的参数中传入的<code>urls</code>将作为父类<code>URLClassLoader</code>的参数即此类加载器负责加载URL，继续反查确认此<code>urls</code>是<code>Restarter</code>构造函数从传入参数<code>DefaultRestartInitializer.getInitialUrls(Thread)</code>中获取的，获取方式是复制类加载器<code>thread.getContextClassLoader()</code> 中以<code>file:</code>开头以 / 结尾的URLs并通过<code>DevToolsSettings</code>读取<code>META-INF/spring-devtools.properties</code>配置文件进行纳入、排查</p><pre>// Restarter 类构造函数protected Restarter(Thread thread, String[] args, boolean forceReferenceCleanup,        RestartInitializer initializer) {    this.initialUrls = initializer.getInitialUrls(thread); //     this.mainClassName = getMainClassName(thread);    this.applicationClassLoader = thread.getContextClassLoader();}</pre><pre>// DefaultRestartInitializer.getInitialUrls() -> ChangeableUrls()private ChangeableUrls(URL... urls) {    DevToolsSettings settings = DevToolsSettings.get();    List<url> reloadableUrls = new ArrayList<url>(urls.length);    for (URL url : urls) { // 过滤URL        if ((settings.isRestartInclude(url) || isFolderUrl(url.toString()))                && !settings.isRestartExclude(url)) {            reloadableUrls.add(url);        }    }    this.urls = Collections.unmodifiableList(reloadableUrls);}</url></url></pre><p>既然问题请求清晰了，那么我们在<code>Restarter</code>构造函数打个断点看看传入的Thread是哪个线程，又是怎么调用的，过滤后还有哪些URL.</p><blockquote><p>main() -&gt; SpringApplication.run() -&gt; SpringApplicationRunListeners.starting() -&gt;<br>SimpleApplicationEventMulticaster.multicastEvent() RestartApplicationListener.onApplicationEvent() -&gt;<br>RestartApplicationListener.onApplicationStartingEvent() -&gt; Restarter.initialize()</p></blockquote><p>由此我们看到是由实现<code>ApplicationListener</code>的<code>RestartApplicationListener</code>完成对<code>Restarter</code>的初始化的，而此是传入的Thread正是main线程，此线程的ContextClassLoader便是<code>AppClassLoader</code>，所以经过过滤后就将只有类似于 <code>file:/projectPath/projectName/module/target/classes</code>这样的属于此项目代码的URL，所以此类加载器不负责加载第三方jar包的类文件。</p><h4 id="那这个类加载器在哪开始加载类的呢？"><a href="#那这个类加载器在哪开始加载类的呢？" class="headerlink" title="那这个类加载器在哪开始加载类的呢？"></a>那这个类加载器在哪开始加载类的呢？</h4><p>在上文的<code>Restarter.initialize()</code>中初始完<code>Restarter</code>后，将调用此<code>Restarter</code>实例的initialize() 方法，如果是刚实例化的继续调用immediateRestart()并启动另一<code>LeakSafeThread</code>线程执行doStart() 并join()等待，此线程将执行doStart()中<code>RestartClassLoader</code>的实例化，并再启动一<code>RestartLauncher</code>线程，并将实例化的<code>RestartClassLoader</code>设为此线程的ContextClassLoader，在此线程中反射调用Main 方法，从而实现热部署重启，并将应用环境的所有项目中的类交给此自定义的类加载器进行加载。</p><pre>RestartLauncher(ClassLoader classLoader, String mainClassName, String[] args,        UncaughtExceptionHandler exceptionHandler) {    this.mainClassName = mainClassName;    //省略    setContextClassLoader(classLoader); // 设置此线程上下文类加载器}@Overridepublic void run() {    try {// 此线程反射调用main方法        Class<?> mainClass = getContextClassLoader().loadClass(this.mainClassName);        Method mainMethod = mainClass.getDeclaredMethod("main", String[].class);        mainMethod.invoke(null, new Object[] { this.args });    }    catch (Throwable ex) {        //省略    }}</pre><h4 id="ClassLoader不一致的解决方法"><a href="#ClassLoader不一致的解决方法" class="headerlink" title="ClassLoader不一致的解决方法"></a>ClassLoader不一致的解决方法</h4><ol><li>最粗暴的方式就是直接去除依赖 Spring-boot-devtools </li><li>如果确实想要热部署功能，Springboot也提供了配置，没错就是上文提到的过滤URLs时使用<code>DevToolsSettings</code>读取<code>META-INF/spring-devtools.properties</code>配置文件进行纳入、排查，你可以自己新建 spring-devtools.properties 文件，配置上需要此自定义类加载器负责来加载的正则表达式，形式如（exclude表示排查、include表示纳入）：<pre>restart.exclude.spring-boot=/spring-boot/target/classes/restart.exclude.spring-boot-devtools=/spring-boot-devtools/target/classes/restart.exclude.spring-boot-starters=/spring-boot-starter-[\\w-]+/</pre></li></ol><p>restart.include.commons-pool2=/org/apache/commons/commons-pool2/2.4.3/commons-pool2-2.4.3.jar<br></p><h4 id="Spring热部署过程触发机制"><a href="#Spring热部署过程触发机制" class="headerlink" title="Spring热部署过程触发机制"></a>Spring热部署过程触发机制</h4><p>既然我们已经探寻了<code>RestartClassLoader </code>，那么肯定也会好奇，这Spring是怎么实现类文件变更后自动触发重启的呢？<br>细看其实分成两部分，一部分是对文件变更的监视，一部分是将变更通知到容器实现应用重启。关键配置类为<code>LocalDevToolsAutoConfiguration</code>（实现本地热部署）和<code>RemoteClientConfiguration</code>（通过HTTP发送变更文件信息通知远程热部署），我们就以<code>LocalDevToolsAutoConfiguration</code>为例。</p><pre>// 本地热部署配置类public class LocalDevToolsAutoConfiguration {    // 实现静态资源文件变更自动刷新页面而非重启应用    static class LiveReloadConfiguration {        // 与WS或JS脚本实现页面刷新        public LiveReloadServer liveReloadServer() {            return new LiveReloadServer(this.properties.getLivereload().getPort(),                    Restarter.getInstance().getThreadFactory());        }        // 省略配置    }    // 实现文件变更自动重启应用    static class RestartConfiguration {        // 监听文件变更事件        @EventListener        public void onClassPathChanged(ClassPathChangedEvent event) {            if (event.isRestartRequired()) {                Restarter.getInstance().restart(                        new FileWatchingFailureHandler(fileSystemWatcherFactory()));            }        }        // 文件变更监视        @Bean        @ConditionalOnMissingBean        public ClassPathFileSystemWatcher classPathFileSystemWatcher() {            URL[] urls = Restarter.getInstance().getInitialUrls();            ClassPathFileSystemWatcher watcher = new ClassPathFileSystemWatcher(                    fileSystemWatcherFactory(), classPathRestartStrategy(), urls);            watcher.setStopWatcherOnRestart(true);            return watcher;        }        // 省略部分配置    }}</pre><p>可见，是由<code>ClassPathFileSystemWatcher</code>实现对文件变更的监视并通过<code>ClassPathChangedEvent</code>事件通知来触发 <code>Restarter.restart()</code>也就是上文描述的步骤 <strong>实例化<code>RestarterClassLoader</code></strong> –&gt; <strong>将其设为线程上下文类加载器</strong> –&gt; <strong>再反射调用Main方法</strong>。</p><p>细看<code>ClassPathFileSystemWatcher</code>传入的参数<code>urls</code>会发现正是等于上文提到的<code>RestarterClassLoader</code>的传入参数。再深入此类可知其是通过<code>DevToolsProperties</code>来配置诸如，等</p><ul><li>restart.exclude 实现指定文件变更不重启，如静态资源文件</li><li>restart.pollInterval 控制监视轮询间隔</li><li>restart.additionalExclude 指定额外的监视路径</li></ul><p>而真正实现文件变更监视的<code>FileSystemWatcher</code>，其实现只是扫描目录下所有文件，与初始的文件信息快照做对比。不过有一点倒挺细节的，就是不仅控制监视轮询间隔，还能通过<code>restart.pollInterval</code> 设置文件变更后多长时间不再继续变更，才触发重启，以防止项目批量编译类文件。</p><pre>private void scan() throws InterruptedException {    Thread.sleep(this.pollInterval - this.quietPeriod); //    Map<file, foldersnapshot> previous;    Map<file, foldersnapshot> current = this.folders;    do {        previous = current;        current = getCurrentSnapshots();        Thread.sleep(this.quietPeriod);  // 等待    }    while (isDifferent(previous, current)); //有变更就循环    if (isDifferent(this.folders, current)) {        updateSnapshots(current.values());    }}</file,></file,></pre><p>本地热部署重启就到这了，有兴趣的童鞋也可以看看热部署页面自动刷新<code>LiveReload</code>、远程热部署重启 等，机制都是相同的，以上。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分&amp;概率论基础总结</title>
      <link href="/2017/11/13/Basis-Of-ProbabilityStatistics-And-Calculus/"/>
      <url>/2017/11/13/Basis-Of-ProbabilityStatistics-And-Calculus/</url>
      
        <content type="html"><![CDATA[<p>最近自己也跟着了解学习机器学习方面知识，打算先从统计数理基础知识开始着手。已下为对微积分和概率论基础知识总结，后续将补充更深入更全面的知识总结。</p><a id="more"></a><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><h3 id="函数与极限"><a href="#函数与极限" class="headerlink" title="函数与极限"></a>函数与极限</h3><h4 id="两遍夹定理"><a href="#两遍夹定理" class="headerlink" title="两遍夹定理"></a>两遍夹定理</h4><p>$$\forall x \in \cup (x0,r) ,g(x)\leqslant f(x)\leqslant h(x)$$<br>$$\mbox{且 }\lim _{x\to x _0}g(x)=A,\lim _{x\to x _0}h(x)=A,\mbox{则 } \lim _{x\to x _0}f(x)=A$$</p><h4 id="极限存在定理"><a href="#极限存在定理" class="headerlink" title="极限存在定理"></a>极限存在定理</h4><p>数列单调递增（减）且有上（下）界，则该数列必有极限<br>$$\lim_{x\to \infty}(1+\frac{1} {x})^x=e$$<br>上面极限使用两遍夹定理求得</p><h3 id="导数与积分部分"><a href="#导数与积分部分" class="headerlink" title="导数与积分部分"></a>导数与积分部分</h3><h4 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h4><p>一阶导数就是曲线的斜率，是曲线变化快慢的反应。而二阶导数是斜率变化的快慢的反应，表示曲线的凹凸性</p><p>求导常用的关系式<br>$${(u+v)}’={u}’+{v}’$$<br>$${uv}’={u}’{v}+{v}’{u}$$</p><h4 id="幂指函数的一般处理策略"><a href="#幂指函数的一般处理策略" class="headerlink" title="幂指函数的一般处理策略"></a>幂指函数的一般处理策略</h4><p>$$\mbox{已知幂指 }f(x) = x^x,x\gt 0,\mbox{求 }f(x) \mbox{最大值}$$<br>$$\mbox{设 }t = x^x,\mbox{则 } \ln t = x\ln x$$<br>$$\frac{1} {t} t’ = \ln x+1 \mbox{两边求导},\mbox{令 }t’ = 0,\ln x+1=0，\mbox{得 }x=e^-1,t=e^{- \frac{1} {e}}$$</p><h4 id="泰勒Taylor公式"><a href="#泰勒Taylor公式" class="headerlink" title="泰勒Taylor公式"></a>泰勒Taylor公式</h4><p>$$f(x)=f(x_0)+f’(x_0)(x-x_0)+\frac{f’’(x_0)} {2!} (x-x_0)^2+…+\frac{f^{n}(x_0)} {n!}(x-x_0)^n+R_n(x)$$<br>$R_n(x)$为函数$X$在$x_0$处的n阶段无穷小</p><h4 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h4><p>方法导数讨论的是二元函数 $z=f(x,y)$在一定$P$上沿着某个方向的变化率问题。<br>$$\frac{\partial f}{\partial x}=\lim_{\rho\to0} \frac{f(x+\Delta x,y+\Delta y)-f(x,y)} {\rho}$$<br>若此极限存在，称该极限为函数$z=f(x,y)$在点$p$沿方向$l$上的方向导数<br>关于方向导数的定理如下：</p><blockquote><p>如果函数$z=f(x,y)$在点$P$上可微分，那么函数在该点的任意方向$l$的方向导数都存在，而且有：<br>$$\frac{\partial f} {\partial l}=\frac{\partial f} {\partial x} cos\varphi+\frac{\partial f} {\partial y}sin\varphi$$<br>其中$\varphi$为$x$轴正方向到射线$l$的转角</p></blockquote><h4 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h4><p>凸函数的<strong>定义</strong>：</p><blockquote><p>函数$f(x)$在区间$I$，如果对区间$I$上的任意两点$x,y$，恒有以下不等式成立：<br>$$f(\theta x+(1-\theta)y)\leqslant\theta f(x)+(1-\theta)f(y),\mbox{其中 }\theta\in[0,1]$$<br>则称$f(x)$在区间$I$上是凸的</p></blockquote><p>凸函数的判定：如果$f(x)$在区间[a,b]上连续，在(a,b)内二阶可导，那么：</p><ul><li>如果$f’’(x)&gt;0$，则$f(x)$是凸的；</li><li>如果$f’’(x)&lt;0$，则$f(x)$是凹的；</li></ul><p>假如$f(x)$为凸函数，还可对上面的不等式进行拓展：$$f(\theta_1x_1+…+\theta_nx_n)\leqslant\theta_1f(x_1)+…+\theta_nf(x_n)$$<br>其中$\theta_i\in[0,1],\theta_1+…+\theta_n=1$</p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><h4 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h4><p><strong>定义</strong>：设$A,B$是两个事件，且P(A)&gt;0，称$$P(B|A)=\frac{P(AB)} {P(A)}$$<br>为在事件$A$发生的条件下事件$B$发生的条件概率</p><h4 id="乘法定理"><a href="#乘法定理" class="headerlink" title="乘法定理"></a>乘法定理</h4><p>设$P(A)&gt;0$，则有$$P(AB)=P(B|A)P(A)$$<br>推广到多个事件的积事件的情况，例如，假设$A,B,C$为事件，且$P(AB)&gt;0$，这有$$P(ABC)=P(C|AB)P(B|A)P(A)$$</p><h4 id="全概率公式和贝叶斯公式"><a href="#全概率公式和贝叶斯公式" class="headerlink" title="全概率公式和贝叶斯公式"></a>全概率公式和贝叶斯公式</h4><p><strong>定义</strong>：设$S$为试验$E$的样本空间，$B_1,B_2,\cdots,B_n$为$E$的一组事件。若</p><ol><li>$B_i B_j=\varnothing  ,i\neq  j,i,j=1,2,\cdots,n$</li><li>$B_1\cup B_2\cup\cdots\cup B_n=S$</li></ol><p>则称$B_1,B_2,\cdots,B_n$为样本空间$S$的一个<strong>划分</strong></p><p>若$B_1,B_2,\cdots,B_n$是样本空间$S$的一个<strong>划分</strong>，则对每次试验，事件$B_1,B_2,\cdots,B_n$中必有且仅有一个发生<br><strong>定理</strong> 设试验$E$的样本空间为$S$，$A$为$E$的事件，$B_1,B_2,\cdots,B_n$为$S$的一个划分，且$P(B_i)&gt;0(i=1,2,\cdots,n)$，则$$P(A)=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+\cdots+P(A|B_n)P(B_n)$$<br>称为<strong>全概率公式</strong></p><p><strong>定理</strong> 设试验$E$的样本空间为$S$，$A$为$S$的事件，$B_1,B_2,\cdots,B_n$为$S$的一个划分，且$P(A)&gt;0,P(B_i)&gt;0 (i=1,2,\cdots,n)$,则$$P(B_i|A)=\frac{P(B_i A)} {P(A)}=\frac{P(A|B_i)P(B _i)} {\sum _{i=1}^{n} P(A|B _i)P(B _i)}$$<br>称为<strong>贝叶斯公式</strong></p><h3 id="常见分布"><a href="#常见分布" class="headerlink" title="常见分布"></a>常见分布</h3><p>常见分布包括：<br>离散型概率分布：两点分布、二项分布、泊松分布；<br>连续型概率分布：均匀分布、指数分布、高斯分布；</p><h4 id="两点分布（伯努利实验）"><a href="#两点分布（伯努利实验）" class="headerlink" title="两点分布（伯努利实验）"></a>两点分布（伯努利实验）</h4><p>离散分布的期望：$E(X)=1\cdot p+0\cdot (1-p)=p$<br>方差：$D(X)=E(X^2)-[E(X)]^2=pq$</p><h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p>将伯努利试验单独重复地进行$n$次，称这一串重复的独立实验为$n$重伯努利实验。<em>重复</em>是指每次试验$p$保持不变；<em>独立</em>指的是每次试验结果互不影响。在抛$n$次硬币的试验中，令随机变量$X$表示字面朝上的次数，那么令$f(x)=P(X=x)$为概率质量函数，则：$$f(x)=\begin{cases}<br> &amp; \binom{n}{x}p^x(1-p)^{n-x}  ,x=0,\cdots n \<br> &amp;  0,els<br>\end{cases}$$<br>如果某一随机变量的概率质量函数如上式所述，那么我们称这类随机变量为二项分布随机变量，可以表示为$X\sim Binomial(n,p)$，即随机变量$X$服从参数为(n,p)二项分布。</p><blockquote><p>二项分布的期望：<br>$$E(X)=\sum _{k=0}^{n}k\cdot p(X=x)=\sum _{k=0}^{n}k\cdot \binom{n}{x}p^x(1-p)^{n-x} \\ =\sum _{k=0}^{n}k\cdot \frac{n!} {k!(n-k)!}p^k (1-p)^{n-k}=np\sum _{k=1}^{n}\cdot \frac{(n-1)!} {(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k}$$<br>设$a=k-1,b=n-1$，那么$$=np\sum _{a=0}^{b}\frac{b!} {a!(b-a)!}p^a(1-p)^{b-a}=np\sum _{a=0}^{b}\binom{b}{a}p^a(1-p)^{b-a}=np$$</p></blockquote><h4 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h4><p>如果试验次数n很大，二项分布的概率p很小，且乘积λ= np比较适中，则事件出现的次数的概率可以用泊松分布来逼近。事实上，二项分布可以看作泊松分布在离散时间上的对应物。<br>回顾$e$的定义：$$\lim_{n\to\infty}(1-\frac{\lambda} {n})^n=e^{-\lambda}$$<br>此定义由上文推导得来。</p><p>二项分布定义：$$P(X=k)= \binom{n}{x}p^x(1-p)^{n-x}$$<br>如果令$p=\frac{\lambda} {n}$，$n$趋于无穷时$P$的极限：<br>$$\lim _{n\to\infty}P(X=k)=\lim _{n\to\infty}\binom{n}{k}p^x(1-p)^{n-x}=\lim _{n\to\infty}\frac{n!}{(n-k)!k!}\left(\frac{\lambda}{n}\right)^k\left(1-\frac{\lambda}{n}\right)^{n-k}\\ =\lim _{n\to\infty}\left[\frac{n!}{n^k(n-k)!}\right]\left(\frac{\lambda^k}{k!}\right)\left(1-\frac{\lambda}{n}\right)^n\left(1-\frac{\lambda}{n}\right)^{-k}\\ =\lim _{n\to\infty}\left[\left(1-\frac{1}{n}\right)\left(1-\frac{2}{n}\right)\cdots\left(1-\frac{k-1}{n}\right)\right]\left(\frac{\lambda^k}{k!}\right)\cdot e^{-\lambda}\cdot 1\ =\left(\frac{\lambda ^k}{k!}\right)\cdot e^{-\lambda}$$</p><p>泊松分布期望推导：</p><blockquote><p>回顾泰勒公式，将函数$e^x$在$x$处的泰勒公式展开：$$e^x=1+x+\frac{x^2}{2!}+\cdots+\frac{x^k}{k!}+R _k$$<br>式子两侧同事乘以$e^{-x}$，可以得到：$$1=1\cdot e^{-x}+x\cdot e^{-x}+\frac{x^2}{2!}\cdot e^{-x}+\cdots+\frac{x^k}{k!}\cdot e^{-x}+R _k\cdot e^{-x}$$<br>如此可以看出，上面展开式右侧每一项的$\frac{x^k}{k!}\cdot e^{-x}$就是上文泊松分布的概率质量函数，只不过此处$x=\lambda$，接下来使用上述结论推导期望：<br>设$X \sim \pi (x)$，则概率质量函数为：$$P(X=k)=\frac{\lambda ^k}{k!}\cdot e^{-\lambda}$$<br>则有期望：$$E(X)=\sum _{k=0}^{\infty}k\cdot \frac{\lambda ^k}{k!}\cdot e^{-\lambda}=\lambda\sum _{k=1}^{\infty}(\frac{\lambda ^{k-1}}{(k-1)!}e^{-\lambda})=\lambda\cdot 1=\lambda$$<br>推导方差：$$E(X^2)=E[X(X-1)+X]=\sum _{k=0}^{+\infty}k(k-1)\cdot \frac{\lambda ^k}{k!}e^{-\lambda}+\lambda\\ =\lambda^2e^{-\lambda}\sum _{k=2}^{+\infty}\cdot\frac{\lambda^{k-2}}{(k-2)!}+\lambda=\lambda^2e^{-\lambda}e^\lambda+\lambda=\lambda^2+\lambda$$$$D(X)=E(X^2)-[E(X)]^2=\lambda$$</p></blockquote><h4 id="泊松定理"><a href="#泊松定理" class="headerlink" title="泊松定理"></a>泊松定理</h4><p>设$\lambda &gt;0$是一个常数，$n$是任意一个正整数，设$np _n=\lambda$（在二项分布(n,p)中p即为$p _n$），则对于任一固定的非负整数$k$，有：$$\lim _{n\to\infty}\binom{n}{k}p _n^k(1-p _n)^{n-k}=\frac{\lambda^k}{k!}\cdot e^{-\lambda}$$<br>定理的条件 $np _n=\lambda$（常数）意味当n很大时 $p _n$ 必然很小，因此，上述定理表明当n很大且p很小时有以下近似值：<br>$$ \binom{n}{k}p^k(1-p)^{n-k}\approx \frac{\lambda^k}{k!}\cdot e^{-\lambda} $$<br>也就是说已n,p为参数的二项分布的概率值可以由参数为 $ \lambda=np $ 的泊松分布的概率值来近似。当然这必须满足一定的条件：n很大且p很小。</p><h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>设$X\sim U(a,b)$，其概率密度为：$$f(x)=\begin{cases}<br> &amp; \frac{1}{b-a}  ,a&lt;x&lt;b, \\<br> &amp;  0, els<br>\end{cases}$$那么可以得到$$E(X)=\int _{-\infty}^{+\infty}xf(x)dx=\int _{a}^{b}x\cdot \frac{1}{b-a}dx=\frac{1}{2}(a+b)$$<br>方差$$D(X)=E(X^2)-[E(X)]^2=\int _{a}^{b}x^2\cdot \frac{1}{b-a}dx-[\frac{1}{2}(a+b)]^2=\frac{(b-a)^2}{12}$$</p><h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><p>假设随机变量$X$服从指数分布，它的概率密度函数可以写成两种形式：<br>$$f(x)=\begin{cases}&amp; \frac{1}{\theta}e^{-\frac{x}{\theta}}  ,x&gt;0, \\ &amp;  0, x\leqslant 0 .\end{cases} \mbox{其中 }\theta&gt;0 and f(x)=\begin{cases}&amp;\lambda e^{-\lambda x}  ,x&gt;0, \\ &amp;  0, x\leqslant 0 .\end{cases} \mbox{其中 }\lambda&gt;0 $$<br>其中$\lambda &gt;0 $被称为率参数，即每个单位时间内发生某事件的次数。简单记为：$X\sim Exponential(\lambda) \mbox{或 }X\sim E(\lambda)$</p><p>无后效性是指数分布的特征。</p><h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><p>正态分布又称为高斯分布，在机器学习领域正态分布使用得非常广泛。<br>设$\mu$是常数，$\sigma$是正常数，如果$X$的密度是<br>$$f(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e\left(-\frac{(x-\mu)^2}{2\sigma^2}\right),x\in R$$<br>就称$X$服从参数为$(\mu,\sigma)$的正态分布，记作$X\sim N(\mu,\sigma)$。这里N为Normal的缩写</p><p>特别的，当$X\sim N(0,1)$时，称$X$服从<strong>标准正态分布</strong>，标准正态分布的密度函数有特殊的地位，所以用一个特定的符号$\varphi$表示：<br>$$\varphi(x)=\frac{1}{\sqrt{2\pi}}e\left(-\frac{x^2}{2}\right),x\in R$$<br>正态分布的密度特点：</p><ul><li>参数$\mu$是密度的中心和最大值点，密度在$\mu$两侧对称；</li><li>参数$\sigma$代表密度的宽度，$\varphi$越大密度越宽。</li></ul><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ol><li>《高等数学》同济大学</li><li>《概率统计讲义》 何书元</li><li><a href="https://www.zybuluo.com/frank-shaw/note/139175" target="_blank" rel="noopener">三月机器学习在线班第一课</a> @frank-shaw</li></ol><p>以上公式在Markdown中采用<strong>LaTeX</strong>排版，可以在以下获取帮助</p><ol><li><a href="https://www.latex-project.org/" target="_blank" rel="noopener">The LATEX Project </a> 官网</li><li><a href="https://cn.sharelatex.com/" target="_blank" rel="noopener">ShareLaTeX</a> 在线编辑器</li><li><a href="https://www.codecogs.com/latex/eqneditor.php?lang=zh-cn" target="_blank" rel="noopener">简易编辑器</a></li></ol><p>Hexo对LaTeX的支持参考</p><ol><li><a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/" target="_blank" rel="noopener">Hexo 书写 LaTeX 公式时的一些问题及解决方法</a></li></ol><p>温馨提示 ：<strong>多行公式中 \\ 换成 \\\\ 才有效</strong></p>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Statistics </tag>
            
            <tag> Calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux架设GitServer、GitWeb</title>
      <link href="/2017/11/02/Setup-GitServer-GitWeb-With-Linux/"/>
      <url>/2017/11/02/Setup-GitServer-GitWeb-With-Linux/</url>
      
        <content type="html"><![CDATA[<p>起因是公司 SVN 服务器老歇机，有些代码放GitHub 又不怎么合适，且近来 GitHub被墙的贼厉害。只需要简单几步即可搭建自己私有的 Git Server，并通过 Git Web 进行浏览查看。</p><p>环境： Debian 9 ，Nginx/1.10.3</p><a id="more"></a><h3 id="搭建-Git-Server"><a href="#搭建-Git-Server" class="headerlink" title="搭建 Git Server"></a>搭建 Git Server</h3><p>Git 可以通过 git://、http[s]://、ssh://、file:// 等方式实现跨仓库传输数据。相比较使用 http 需要设置 cgi ，而使用自带 git-daemon 没有安全验证，所有此处我们选择使用 ssh 传输的Git Server。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>因使用 ssh，那么在开始前你需要有产生好的 ssh key ，并在 Server/Client 放置好，不熟悉的话可参考：（当然你也可选择每次使用时输入密码。）</p><ul><li><a href="http://plog.longwin.com.tw/my_note/2005/12/28/ssh_keygen_no_passwd" target="_blank" rel="noopener">产生 ssh keygen 免输入密码</a></li><li><a href="http://josephjiang.com/article/understand-ssh-key/" target="_blank" rel="noopener">SSH 免密码登录</a></li></ul><p>先声明一下内容：</p><ul><li>Server : 服务器需公网IP或域名（IP 、example.com）</li><li>Linux：可登录用户及用户群组（VPS:VPS）</li><li>Project name :  项目名（Project_name）</li><li>Git-Repo-Dir：仓库目录（/home/VPS/git-repo）<h4 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h4></li></ul><p><strong>Server 端</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. mkdir /home/VPS/git-repo/project_name.git</span><br><span class="line">2. cd /home/VPS/git-repo/project_name.git</span><br><span class="line">3. git init --bare</span><br><span class="line">4. chown VPS:VPS -R /home/VPS/git-repo/project_name.git</span><br></pre></td></tr></table></figure><p>轻松几步即完成 Server 端搭建</p><p><strong>Client 端</strong>使用</p><ol><li>正常使用如 <code>git clone VPS@（IP或example.com）:/home/VPS/git-repo/project_name.git</code></li><li>若<strong>Client 端</strong>已存在 project_name 的仓库，可通过 <code>git remote add  private VPS@（IP或example.com）:/home/VPS/git-repo/project_name.git</code> ，然后调用<code>git push private</code> 将本地仓库推送到远端空的同名库中。（需是同名且<strong>Server</strong>端库需为空库）</li></ol><h3 id="搭建GitWeb"><a href="#搭建GitWeb" class="headerlink" title="搭建GitWeb"></a>搭建GitWeb</h3><p>其实单纯 Git Server就能满足对远端仓库的需求，搭建 GitWeb 只是提供 HTTP 界面服务方便浏览查看。步骤也很简单</p><p>本文是通过 Nginx 搭建，若想换成 Apache 可参考 <a href="https://blog.longwin.com.tw/2009/05/build-git-env-over-ssh-2009/" target="_blank" rel="noopener">Debian Linux 架設 Gitweb</a></p><h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装需要的软件：</p><pre><code>apt-get install -t wheezy-backports nginx nginx-common git gitweb fcgiwrap</code></pre><p>你需清楚的配置文件</p><ol><li><code>/etc/gitweb.conf</code>  GitWeb配置文件。其中Git仓库目录 默认是<code>/var/lib/git/</code>可修改。</li><li><code>/usr/share/gitweb</code> GitWeb运行目录，包含 <code>index.cgi</code> 脚本</li><li><code>/etc/nginx/sites-available/default</code> Nginx Web服务器默认站配置</li><li><code>/var/run/fcgiwrap.socket</code> Nginx与FastCGI通信Socket</li></ol><p>在运行时如果遇到错误都可以参看 Nginx log 文件：<code>/var/log/nginx/error.log</code> and <code>/var/log/nginx/access.log</code>。</p><h4 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h4><p>创建新文件 <code>/etc/nginx/sites-available/gitweb</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  <span class="comment"># Git 仓库将展示在 http://example.com:4321/</span></span><br><span class="line">  listen 4321 default;   <span class="comment"># 如果80已占用，去除 default。也可为其他端口</span></span><br><span class="line">  server_name example.com; <span class="comment"># Server 域名</span></span><br><span class="line"></span><br><span class="line">  location /index.cgi &#123;</span><br><span class="line">    root /usr/share/gitweb/;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    gzip off;</span><br><span class="line">    fastcgi_param SCRIPT_NAME <span class="variable">$uri</span>;</span><br><span class="line">    fastcgi_param GITWEB_CONFIG /etc/gitweb.conf;</span><br><span class="line">    fastcgi_pass  unix:/var/run/fcgiwrap.socket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    root /usr/share/gitweb/;</span><br><span class="line">    index index.cgi;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将在 site-enable 中创建配置文件软链接</p><pre><code>ln -s /etc/nginx/sites-available/gitweb /etc/nginx/sites-enabled/gitweb</code></pre><p>然后你可以先测试 Nginx 配置</p><pre><code>sudo nginx -t #若显示成功，重启以加载设置，失败则回去检测;分号是否正确sudo nginx -s reload#或sudo systemctl restart nginx</code></pre><p>搭建好啦！在 <a href="http://example.com:4321/" target="_blank" rel="noopener">http://example.com:4321/</a>  你将看到你的仓库，没有则为”No projects found”</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>如果不希望谁都能在公网上看到自己的仓库，也可以通过简单几步加上一个验证。</p><p>安装apache2-utils</p><pre><code>sudo apt-get install apache2-utils</code></pre><p>在 <code>/usr/share/gitweb/</code>下创建用户密码文件</p><pre><code>sudo htpasswd -c htpasswd Username#Username 为用户名，之后按提示输入密码</code></pre><p>完成后修改上面 Nginx 配置文件中第二个 location 部分为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> location / &#123;</span><br><span class="line">auth_basic <span class="string">"Git Login"</span>; <span class="comment"># 加上这两行</span></span><br><span class="line">auth_basic_user_file <span class="string">"/usr/share/gitweb/htpasswd"</span>;<span class="comment"># 文件</span></span><br><span class="line">   root /usr/share/gitweb/;</span><br><span class="line">   index index.cgi;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再如上文重启或 reload Nginx。可以看到你私有带验证的GitWeb就搭建好了 XD</p><p>参考 [<a href="https://blog.longwin.com.tw/2009/05/build-git-env-over-ssh-2009/" target="_blank" rel="noopener">Debian Linux 架設使用 SSH 存取 的 Git Server</a>][<a href="https://gist.github.com/mcxiaoke/055af99e86f8e8d3176e" target="_blank" rel="noopener">Set up Gitweb + Nginx </a>]</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debian </tag>
            
            <tag> Git </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JShell - Java交互工具（REPL） - 笔记</title>
      <link href="/2017/10/20/Java-REPL-Tool-JShell-Notes/"/>
      <url>/2017/10/20/Java-REPL-Tool-JShell-Notes/</url>
      
        <content type="html"><![CDATA[<p>在今年九月正式发布的 Java9 版本中，其 /bin 目录中多个一个交互工具 JShell（据说 Java8 已有测试版）。众所周知，许多编程语言都提供称作 Read-Evaluate-Print Loop （REPL）的命令行工具，它们能够在输入声明、语句及表达式时计算，并立即给出结果。</p><p>以 Python 为例，运行整个工程、项目可能需要很长时间，但是你可以使用此工具执行一些需要确定的表达式，就能立即得到他们返回的值。这对于哪些开始学习语言或者接触语言新功能的程序员来说是个便捷好用的工具。</p><p>然而没 JShell 之前的 Java 来说，你需要编写一个测试类新建 main 方法来打印结果，并且每次修改后需要重写编译、运行。</p><a id="more"></a><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>下载并安装 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Java9</a> ，配置环境变量，或者不配置的话直接在 /bin 目录下就能找到 jshell 可执行文件。建议一开始运行加入 -v 参数，JShell 给出详细反馈。</p><pre><code>root@Mydebian:~$ jdk-9/bin/jshell -v|  欢迎使用 JShell -- 版本 9|  要大致了解该版本, 请键入: /help introjshell&gt; </code></pre><p>此时不需要详情模式，可输入 <em>/set feedback normal</em></p><h2 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h2><p>JShell 默认有一组常用的导入</p><pre><code>jshell&gt; /imports|    import java.util.*、|    import java.io.*|    import java.math.*|    import java.net.*|    import java.util.concurrent.*|    import java.util.prefs.*|    import java.util.regex.*</code></pre><p>你也可以任何时候导入自己想要的通过  <em>import XXX</em> （单击 tab 补全、给出可选）</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>你可以输入任何有效的 Java 表达式，它将得出返回值、类型，并分配给一个变量，如：</p><pre><code>jshell&gt; 3+3$1 ==&gt; 6|  已创建暂存变量 $1 : intjshell&gt; $1$1 ==&gt; 6|  $1 的值: in</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>可以声明变量（默认值），并赋值。一旦声明后，变量即为当前对话中全局变量，再次声明、赋值将覆盖</p><pre><code>jshell&gt; int x=5x ==&gt; 5|  已创建 变量 x : intjshell&gt; xx ==&gt; 5|  x 的值: int</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>也可以定义方法，再次定义将覆盖</p><pre><code>jshell&gt; void hello() { System.out.println(&quot;Hello JShell&quot;); }|  已创建 方法 hello()jshell&gt; hello()Hello JShelljshell&gt; void hello() { System.out.println(&quot;Replace Method&quot;); }|  已修改 方法 hello()|    更新已覆盖 方法 hello()jshell&gt; hello()Replace Method</code></pre><p>不过尝试了下，发现 JShell 定义方法只支持参数重载，不支持返回值重载，后定义将覆盖前面定义的</p><pre><code>jshell&gt; void hello() { System.out.println(&quot;Void No Param&quot;); }|  已创建 方法 hello()jshell&gt; void hello(int x) { System.out.println(&quot;Void INT Param&quot;); }|  已创建 方法 hello(int)jshell&gt; /methods |    void hello()|    void hello(int)jshell&gt; int hello(int x) { System.out.println(&quot;Int INT Param&quot;);return x; }|  已替换 方法 hello(int)|    更新已覆盖 方法 hello(int)jshell&gt; /methods |    void hello()|    int hello(int)jshell&gt; int hello() { System.out.println(&quot;Int No Param&quot;);return 1; }|  已替换 方法 hello()|    更新已覆盖 方法 hello()jshell&gt; /methods |    int hello(int)|    int hello()</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>除了 Java 代码外，你还可以执行一些 JShell 命令。一些常用的如下（键入 <em>help</em> 将列举所有）</p><h3 id="列出变量"><a href="#列出变量" class="headerlink" title="列出变量"></a>列出变量</h3><pre><code>jshell&gt; /vars|    int x = 0|    double j = 0.5</code></pre><h3 id="列出方法"><a href="#列出方法" class="headerlink" title="列出方法"></a>列出方法</h3><pre><code>jshell&gt; /methods|    printf (String,Object...)void|    hello ()void</code></pre><h3 id="列出执行过的代码"><a href="#列出执行过的代码" class="headerlink" title="列出执行过的代码"></a>列出执行过的代码</h3><pre><code>jshell&gt; /list1 : 3+32 : $14 : x5 : int y;6 : y7 : x8 : int x;10 : hello()11 : void hello() { System.out.println(&quot;Replace Method&quot;); }12 : hello()</code></pre><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><pre><code>jshell&gt; /edit hello</code></pre><p>可以后跟方法名（将编辑所有重载方法）、变量名、id。id 就是上面通过 <em>/list</em>  列出的序号。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="验证返回值"><a href="#验证返回值" class="headerlink" title="验证返回值"></a>验证返回值</h3><pre><code>jshell&gt; 1.0/2$6 ==&gt; 0.5|  已创建暂存变量 $6 : doublejshell&gt; 1/2.0$7 ==&gt; 0.5|  已创建暂存变量 $7 : doublejshell&gt; 1/2.0f$8 ==&gt; 0.5|  已创建暂存变量 $8 : floatjshell&gt; 1.0f/2$9 ==&gt; 0.5|  已创建暂存变量 $9 : floatjshell&gt; 1.0f/2.0f$10 ==&gt; 0.5|  已创建暂存变量 $10 : floatjshell&gt; 1.0f/2.0$11 ==&gt; 0.5|  已创建暂存变量 $11 : double</code></pre><h3 id="装箱细节"><a href="#装箱细节" class="headerlink" title="装箱细节"></a>装箱细节</h3><pre><code>jshell&gt; Integer i1=127 i1 ==&gt; 127|  已创建 变量 i1 : Integerjshell&gt; Integer i2=127i2 ==&gt; 127|  已创建 变量 i2 : Integerjshell&gt; i1==i2$14 ==&gt; true|  已创建暂存变量 $14 : booleanjshell&gt; Integer i1=128i1 ==&gt; 128|  已修改 变量 i1 : Integer|    更新已覆盖 变量 i1 : Integerjshell&gt; Integer i2=128i2 ==&gt; 128|  已修改 变量 i2 : Integer|    更新已覆盖 变量 i2 : Integerjshell&gt; i1==i2$17 ==&gt; false|  已创建暂存变量 $17 : boolean</code></pre><p>值在-128-127的自动装箱 Integer 对象在JVM中已经缓存好</p><pre><code>jshell&gt; Integer i1= new Integer(127)i1 ==&gt; 127|  已修改 变量 i1 : Integer|    更新已覆盖 变量 i1 : Integerjshell&gt; Integer i2= 127i2 ==&gt; 127|  已修改 变量 i2 : Integer|    更新已覆盖 变量 i2 : Integerjshell&gt; i1==i2$29 ==&gt; false|  已创建暂存变量 $29 : boolean</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JShell 这一REPL交互工具，将给测试 Java 代码片段带来很大的方便。Java 程序员将像 Python、NodeJS、Scala程序员那样享受这种命令行带来的便捷，看到这里还不行动起来？下载个试试，将让你回想起自己写 main 测试就想流泪 XD</p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener"><strong>Java Download</strong></a></li><li><a href="http://docs.oracle.com/javase/9/tools/jshell.htm" target="_blank" rel="noopener"><strong>JShell Doc</strong></a></li><li>[<strong>JAKUB DZIWORSKI`s BLOG</strong>](<a href="http://jakubdziworski.github.io/java/2016/07/31/jshell-getting-started-examples.html" target="_blank" rel="noopener">http://jakubdziworski.github.io/java/2016/07/31/jshell-getting-started-examples.html</a>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一键配置脚本（用户添加配置、源修改、ss&amp;BBR安装）</title>
      <link href="/2017/10/12/QuickInit-Shell-Script/"/>
      <url>/2017/10/12/QuickInit-Shell-Script/</url>
      
        <content type="html"><![CDATA[<p>最近在各个服务器提供商中尝试适合的服务器，然而给多个服务器初始配置确实很是繁琐无聊。<br>索性自己写个脚本，这样一接手新的服务器就能自动配置，省下时间来好好折腾别的。</p><hr><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>目前适用环境：CentOS 5+、Ubuntu、Debian</p><ol><li>显示系统信息 </li><li>修改源为国内阿里云源镜像（也可修改参数配置其他源）</li><li>创建指定用户、创建Home目录、指定Shell、添加到 sudoers （可修改参数）</li><li>下载.bashrc、.vimrc 配置工作环境（来自博主自己）</li><li>安装Shadowsocks 、BBR（可选、来源 <a href="https://teddysun.com/" target="_blank" rel="noopener">https://teddysun.com/</a> 秋水逸冰）</li><li>配置Java、Python等（待续完善）<a id="more"></a></li></ol><h2 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment"># File Name: quickInit.sh</span></span><br><span class="line"><span class="comment"># Author: single-wolf</span></span><br><span class="line"><span class="comment"># mail: root@mail.zhongm.in</span></span><br><span class="line"><span class="comment"># Created Time: 2017年10月12日 10:43:49</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#Auto init ECS or VPS include useradd ,install pakeage ,add sys-config</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#新建用户名</span></span><br><span class="line">defaultUser=<span class="string">'MyVPS'</span></span><br><span class="line"><span class="comment">#新用户默认Shell</span></span><br><span class="line">defaultShell=<span class="string">'bash'</span></span><br><span class="line"><span class="comment">#常用工具安装</span></span><br><span class="line">initPakeage=<span class="string">"sudo wget vim git dstat <span class="variable">$defaultShell</span>"</span></span><br><span class="line"><span class="comment">#自定义源URL，适用于Ubuntu、Debian</span></span><br><span class="line">srcUrl=<span class="string">'http://mirrors.aliyun.com/'</span></span><br><span class="line"></span><br><span class="line">red=<span class="string">'\033[0;31m'</span></span><br><span class="line">green=<span class="string">'\033[0;32m'</span></span><br><span class="line">yellow=<span class="string">'\033[0;33m'</span></span><br><span class="line">plain=<span class="string">'\033[0m'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#待续</span></span><br><span class="line">version_jdk=9 </span><br><span class="line"></span><br><span class="line">[[ <span class="variable">$EUID</span> -ne 0 ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> This script must be run as root!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/redhat-release ]; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"centos"</span></span><br><span class="line"><span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">"debian"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"debian"</span></span><br><span class="line"><span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">"ubuntu"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"ubuntu"</span></span><br><span class="line"><span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">"centos|red hat|redhat"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"centos"</span></span><br><span class="line"><span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">"debian"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"debian"</span></span><br><span class="line"><span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">"ubuntu"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"ubuntu"</span></span><br><span class="line"><span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">"centos|red hat|redhat"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"centos"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_opsy</span></span>() &#123;<span class="comment">##获取系统信息</span></span><br><span class="line">    [ -f /etc/redhat-release ] &amp;&amp; awk <span class="string">'&#123;print ($1,$3~/^[0-9]/?$3:$4)&#125;'</span> /etc/redhat-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    [ -f /etc/os-release ] &amp;&amp; awk -F<span class="string">'[= "]'</span> <span class="string">'/PRETTY_NAME/&#123;print $3,$4,$5&#125;'</span> /etc/os-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    [ -f /etc/lsb-release ] &amp;&amp; awk -F<span class="string">'[="]+'</span> <span class="string">'/DESCRIPTION/&#123;print $2&#125;'</span> /etc/lsb-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_version</span></span>()&#123;<span class="comment">##获取版本</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"centos"</span> ]];<span class="keyword">then</span></span><br><span class="line">        [ -f /etc/os-release ] &amp;&amp; awk -F<span class="string">'[="]+'</span> <span class="string">'/VERSION_ID/&#123;print $2&#125;'</span> /etc/os-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"debian"</span> ]];<span class="keyword">then</span></span><br><span class="line">        [ -f /etc/os-release ] &amp;&amp; awk -F<span class="string">'[()]'</span> <span class="string">'/VERSION=/&#123;print $2&#125;'</span> /etc/os-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"ubuntu"</span> ]];<span class="keyword">then</span></span><br><span class="line">        [ -f /etc/lsb-release ] &amp;&amp; awk -F<span class="string">'[="]+'</span> <span class="string">'/DISTRIB_CODENAME/&#123;print $2&#125;'</span> /etc/lsb-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> OS is not be supported, please change to CentOS/Debian/Ubuntu and try again."</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opsy=$( get_opsy )</span><br><span class="line">arch=$( uname -m )</span><br><span class="line">lbit=$( getconf LONG_BIT )</span><br><span class="line">kern=$( uname -r )</span><br><span class="line">version=$( get_version )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_char</span></span>() &#123;</span><br><span class="line">    SAVEDSTTY=`stty -g`</span><br><span class="line">    stty -<span class="built_in">echo</span></span><br><span class="line">    stty cbreak</span><br><span class="line">    dd <span class="keyword">if</span>=/dev/tty bs=1 count=1 2&gt; /dev/null</span><br><span class="line">    stty -raw</span><br><span class="line">    stty <span class="built_in">echo</span></span><br><span class="line">    stty <span class="variable">$SAVEDSTTY</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init_install</span></span>()&#123;<span class="comment">##修改源、安装常用软件</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"debian"</span> ]];<span class="keyword">then</span></span><br><span class="line">        file=<span class="string">"/etc/apt/sources.list"</span></span><br><span class="line">        [[ ! -e <span class="variable">$file</span> ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>src file <span class="variable">$file</span> not exist,please check it!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">        cp <span class="variable">$file</span> <span class="string">"<span class="variable">$file</span>.`date +%F`"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"#Created By quickInit.sh `date +%F`"</span>&gt;<span class="variable">$file</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> <span class="string">"deb"</span> <span class="string">"deb-src"</span>;<span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> sort <span class="keyword">in</span> <span class="string">""</span> <span class="string">"-updates"</span> ;<span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$kind</span> <span class="variable">$srcUrl</span><span class="variable">$release</span> <span class="variable">$version</span><span class="variable">$sort</span> main contrib non-free"</span> &gt;&gt; <span class="variable">$file</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"<span class="variable">$kind</span> <span class="variable">$srcUrl</span><span class="variable">$release</span>-security <span class="variable">$version</span>/updates main contrib non-free"</span> &gt;&gt; <span class="variable">$file</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        apt-get update</span><br><span class="line">        apt-get -y install <span class="variable">$initPakeage</span></span><br><span class="line">        <span class="keyword">if</span> [[ $? -ne 0 ]];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Install InitPakeages failed, please check it."</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"ubuntu"</span> ]];<span class="keyword">then</span></span><br><span class="line">        file=<span class="string">"/etc/apt/sources.list"</span></span><br><span class="line">        [[ ! -e <span class="variable">$file</span> ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>src file <span class="variable">$file</span> not exist,please check it!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">        cp <span class="variable">$file</span> <span class="string">"<span class="variable">$file</span>.`date +%F`"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"#Created By quickInit.sh `date +%F`"</span>&gt;<span class="variable">$file</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> <span class="string">"deb"</span> <span class="string">"deb-src"</span>;<span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> sort <span class="keyword">in</span> <span class="string">""</span> <span class="string">"-updates"</span> <span class="string">"-security"</span>;<span class="keyword">do</span></span><br><span class="line">                <span class="keyword">for</span> free <span class="keyword">in</span> <span class="string">"main"</span> <span class="string">"universe"</span>;<span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">"<span class="variable">$kind</span> <span class="variable">$srcUrl</span><span class="variable">$release</span> <span class="variable">$version</span><span class="variable">$sort</span> <span class="variable">$free</span>"</span> &gt;&gt; <span class="variable">$file</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        apt-get update</span><br><span class="line">        apt-get -y install <span class="variable">$initPakeage</span></span><br><span class="line">        <span class="keyword">if</span> [[ $? -ne 0 ]];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Install InitPakeages failed, please check it."</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"centos"</span> ]];<span class="keyword">then</span></span><br><span class="line">        file=<span class="string">"/etc/yum.repos.d/CentOS-Base.repo"</span></span><br><span class="line">        [[ ! -e <span class="variable">$file</span> ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>src file <span class="variable">$file</span> not exist,please check it!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">        cp <span class="variable">$file</span> <span class="string">"<span class="variable">$file</span>.`date +%F`"</span></span><br><span class="line">        <span class="keyword">if</span> [[ ! -e <span class="string">"/usr/bin/wget"</span> ]];<span class="keyword">then</span></span><br><span class="line">            wget -O <span class="variable">$file</span> <span class="string">"http://mirrors.aliyun.com/repo/Centos-<span class="variable">$version</span>.repo"</span></span><br><span class="line">        <span class="keyword">elif</span> [[ -e <span class="string">"/usr/bin/curl"</span> ]];<span class="keyword">then</span></span><br><span class="line">            curl -o <span class="variable">$file</span> <span class="string">"http://mirrors.aliyun.com/repo/Centos-<span class="variable">$version</span>.repo"</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            yum -y install wget &amp;&amp; wget -O <span class="variable">$file</span> <span class="string">"http://mirrors.aliyun.com/repo/Centos-<span class="variable">$version</span>.repo"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        yum clean all &amp;&amp; yum makecache</span><br><span class="line">        yum -y install <span class="variable">$initPakeage</span></span><br><span class="line">        <span class="keyword">if</span> [[ $? -ne 0 ]];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Install InitPakeages failed, please check it."</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> OS is not be supported, please change to CentOS/Debian/Ubuntu and try again."</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:Init and install <span class="variable">$initPakeage</span> successfully."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">adduser</span></span>()&#123;<span class="comment">##添加用户、修改sudoers</span></span><br><span class="line">    shell=<span class="string">"/bin/<span class="variable">$defaultShell</span>"</span></span><br><span class="line">    useradd <span class="variable">$defaultUser</span> -m -s <span class="variable">$shell</span></span><br><span class="line">    [ $? -ne 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Add user <span class="variable">$defaultUser</span> failed,please check it"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Input password for your newUser"</span></span><br><span class="line">    passwd <span class="variable">$defaultUser</span></span><br><span class="line">    <span class="keyword">while</span> [ $? -ne 0 ]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        passwd <span class="variable">$defaultUser</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Add user <span class="variable">$defaultUser</span> successfully"</span></span><br><span class="line">    chmod +w /etc/sudoers</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$defaultUser</span>  ALL=(ALL)   ALL"</span> &gt;&gt; /etc/sudoers</span><br><span class="line">    [ $? -ne 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Give user <span class="variable">$defaultUser</span> failed"</span> &amp;&amp; chmod -w /etc/sudoers &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">    chmod -w /etc/sudoers</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Give user <span class="variable">$defaultUser</span> Rootright successfully"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">userconfig</span></span>()&#123;<span class="comment">##配置.bash .vimrc环境</span></span><br><span class="line">    home=<span class="string">"/home/<span class="variable">$defaultUser</span>/"</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$home</span></span><br><span class="line">    wget -O .profile <span class="string">"http://cloud.zhongm.in/f/c92022b083/?raw=1"</span> &amp;&amp; wget -O .bashrc <span class="string">"http://cloud.zhongm.in/f/e933c3dcf0/?raw=1"</span> &amp;&amp; wget -O .vimrc <span class="string">"http://cloud.zhongm.in/f/1cecaee058/?raw=1"</span> &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Download userconfig successfully,relogin in to use it."</span></span><br><span class="line">    chown <span class="variable">$defaultUser</span>:<span class="variable">$defaultUser</span> .*</span><br><span class="line">    [ $? -ne 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>User config failed!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">disableRootLogin</span></span>()&#123;<span class="comment">##禁用Root登录</span></span><br><span class="line">    config=<span class="string">"/etc/ssh/sshd_config"</span></span><br><span class="line">    <span class="keyword">if</span> [[ -e  <span class="variable">$config</span> ]];<span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [[ -w <span class="variable">$config</span> ]];<span class="keyword">then</span></span><br><span class="line">            chmod +w <span class="variable">$config</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        sed -i <span class="string">'/^PermitRootLogin/'</span>d <span class="variable">$config</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"PermitRootLogin no"</span>&gt;&gt;<span class="variable">$config</span></span><br><span class="line">        [ $? -ne 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Disable RootLogin failed"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>config file <span class="variable">$config</span> not exist,please check it!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Disable RootLogin successfully"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#install_java()&#123;##安装Java，待续</span></span><br><span class="line"><span class="comment">#  if [ -n `which java` ];then</span></span><br><span class="line"><span class="comment">#      version_local=`java -version&gt;version.tmp 2&gt;&amp;1 &amp;&amp; awk -F'["]' '/java version/&#123;print $2&#125;' version.tmp &amp;&amp; rm version.tmp`</span></span><br><span class="line"><span class="comment">#      if [ $version_local -eq $version_jdk ];then</span></span><br><span class="line"><span class="comment">#          echo -e "$&#123;green&#125;INFO:$&#123;plain&#125;JDK$version_jdk alreadly exists!"</span></span><br><span class="line"><span class="comment">#          return</span></span><br><span class="line"><span class="comment">#      else </span></span><br><span class="line"><span class="comment">#          echo -e "$&#123;yellow&#125;INFO:$&#123;plain&#125;Prepare to remove local JDK$version_local,and install JDK$version_jdk"</span></span><br><span class="line"><span class="comment">#      fi</span></span><br><span class="line"><span class="comment">#  else</span></span><br><span class="line"><span class="comment">#  fi</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_ss</span></span>()&#123;<span class="comment">##安装Shadowsocks</span></span><br><span class="line">    wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">    chmod +x shadowsocks-all.sh</span><br><span class="line">    ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_bbr</span></span>()&#123;<span class="comment">##安装BBR</span></span><br><span class="line">    wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line">    chmod +x bbr.sh</span><br><span class="line">    ./bbr.sh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"---------- System Information ----------"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" OS      : <span class="variable">$opsy</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" Arch    : <span class="variable">$arch</span> (<span class="variable">$lbit</span> Bit)"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" Kernel  : <span class="variable">$kern</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" Version : <span class="variable">$version</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"----------------------------------------"</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Press any key to start...or Press Ctrl+C to cancel"</span></span><br><span class="line">char=`get_char`</span><br><span class="line">init_install</span><br><span class="line">adduser</span><br><span class="line">userconfig</span><br><span class="line">disableRootLogin</span><br><span class="line">install_ss</span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>GitHub位置 <a href="https://github.com/single-wolf/ShellScript/blob/master/quickInit.sh" target="_blank" rel="noopener">一键快速配置</a></p><p>功能有待完善。欢迎拍砖</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度解析Java线程池的异常处理</title>
      <link href="/2017/09/20/Analyze-Java-Theadpool-Exception/"/>
      <url>/2017/09/20/Analyze-Java-Theadpool-Exception/</url>
      
        <content type="html"><![CDATA[<p>在逛同性交友网站GitHub的时候看到一个解析线程池异常处理的Issue，正好是曾经自己遇到过的问题。在此记录下来，并将其拓展到其他类型的线程池。</p><p>本文因篇幅省略了诸多AQS相关知识，可以查看博客中另一篇博文 <a href="/2017/08/25/Analyze-JDK-AQS/">一行一行源码分析清楚AQS</a> 以保证清楚理解本文。</p><a id="more"></a><h3 id="1、ThreadPoolExecutor"><a href="#1、ThreadPoolExecutor" class="headerlink" title="1、ThreadPoolExecutor"></a>1、ThreadPoolExecutor</h3><blockquote><p>此部分来源于 <a href="https://github.com/aCoder2013/blog/issues/3" target="_blank" rel="noopener">GitHub aCoder2013</a></p></blockquote><p>这一线程池由来已久，是抽象类 AbstractExecutorService 继承类，通过调用不同构造函数实现诸如 newFixedThreadPool 、newCachedThreadPool 线程池功能。</p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>考虑下面这段代码，有什么区别呢？你可以猜猜会不会有异常打出呢？如果打出来的话是在哪里？：</p><pre class="lang:java decode:true" title="Question">        ExecutorService threadPool = Executors.newFixedThreadPool(1);        threadPool.submit(() -&gt; {            Object obj = null;            System.out.println(obj.toString());        });        threadPool.execute(() -&gt; {            Object obj = null;            System.out.println(obj.toString());        });</pre><p>你会发现单就执行这两句的话，结果只会打印一处异常信息，来源于 execute() 中的 obj.toString() 。</p><h4 id="源码解析："><a href="#源码解析：" class="headerlink" title="源码解析："></a>源码解析：</h4><p>分析下面源码，发现其实重载的 submit() 方法将 Runnable、Callable 都封装成继承 Future 的 RunnableFuture 的实现类 FutureTask 对象（有点忽悠  XD）</p><pre class="lang:java decode:true" title="SrcAnalyse">    public Future&lt;?&gt; submit(Runnable task) {        if (task == null) throw new NullPointerException();        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);        execute(ftask);        return ftask;    }    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {        if (task == null) throw new NullPointerException();        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);        execute(ftask);        return ftask;    }    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {        return new FutureTask&lt;T&gt;(runnable, value);    }    public FutureTask(Runnable runnable, V result) {        this.callable = Executors.callable(runnable, result);        this.state = NEW;       // volatile修饰，保证多线程下的可见性,可以看看Java内存模型    }    public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {        if (task == null)            throw new NullPointerException();        return new RunnableAdapter&lt;T&gt;(task, result);    }    static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {        final Runnable task;        final T result;        RunnableAdapter(Runnable task, T result) {            this.task = task;            this.result = result;        }        public T call() {            task.run();            return result;        }    }</pre><p>接下来就会实际提交到队列中交给线程池调度处理：</p><pre class="lang:java decode:true " title="SrcAnalyse2"> /**    * 这里经过多次检查验证    * 意图都是将通过addWorker()或是workQueue.offer()    * 将Runnable传给继承AQS的Worker内部类进行封装    * 了解AQS的同学一看便能融会贯通    */    public void execute(Runnable command) {        if (command == null)            throw new NullPointerException();        int c = ctl.get();        if (workerCountOf(c) &lt; corePoolSize) {            if (addWorker(command, true))                return;            c = ctl.get();        }        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {            int recheck = ctl.get();            if (! isRunning(recheck) &amp;&amp; remove(command))                reject(command);            else if (workerCountOf(recheck) == 0)                addWorker(null, false);        }        else if (!addWorker(command, false))            reject(command);    }</pre><p>那么接下来看看线程池核心的流程：</p><pre class="lang:java decode:true" title="SrcAnalyse3">private final class Worker        extends AbstractQueuedSynchronizer        implements Runnable{          /** Delegates main run loop to outer runWorker  */        public void run() {            runWorker(this);        }}final void runWorker(Worker w) {        Thread wt = Thread.currentThread();        Runnable task = w.firstTask;        w.firstTask = null;        w.unlock(); // allow interrupts        boolean completedAbruptly = true;        try {            //getTask()方法会尝试从队列中抓取数据            while (task != null || (task = getTask()) != null) {                w.lock();                if ((runStateAtLeast(ctl.get(), STOP) ||                     (Thread.interrupted() &amp;&amp;                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                    !wt.isInterrupted())                    wt.interrupt();                try {                    //可覆写此方法打日志埋点之类的                    beforeExecute(wt, task);                    Throwable thrown = null;                    try {                        //简单明了，直接调用run方法                        task.run();                    } catch (RuntimeException x) {                        thrown = x; throw x;                    } catch (Error x) {                        thrown = x; throw x;                    } catch (Throwable x) {                        thrown = x; throw new Error(x);                    } finally {                        afterExecute(task, thrown);//下文将介绍可以重写此方法捕获异常                    }                } finally {                    task = null;                    w.completedTasks++;                    w.unlock();                }            }            completedAbruptly = false;        } finally {            processWorkerExit(w, completedAbruptly);        }    }</pre><h4 id="submit-的方式"><a href="#submit-的方式" class="headerlink" title="submit() 的方式"></a>submit() 的方式</h4><p>之前我们知道最终传递过去的是FutureTask，也就是说会调用这里的 Future 的 run方法，我们看看实现：</p><pre class="lang:java decode:true" title="SrcAnalyse4">    public void run() {        if (state != NEW ||            !UNSAFE.compareAndSwapObject(this, runnerOffset,                                         null, Thread.currentThread()))            return;        try {            Callable&lt;V&gt; c = callable;            if (c != null &amp;&amp; state == NEW) {                V result;                boolean ran;                try {                    result = c.call();                    ran = true;                } catch (Throwable ex) {//捕获异常不抛出                    result = null;                    ran = false;                    //。。。                    setException(ex);//调用此方法设置异常状态                }                if (ran)                    set(result);            }        } finally {          //省略    }      protected void setException(Throwable t) {        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {            outcome = t; //异常赋给了这个变量            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // 将状态CAS为EXCEPTIONAL            finishCompletion();        }    }    public V get() throws InterruptedException, ExecutionException {//Future.get()获取返回值        int s = state;        if (s &lt;= COMPLETING)            s = awaitDone(false, 0L);        return report(s);//最终调用report返回outcome变量    }    private V report(int s) throws ExecutionException {        Object x = outcome;        if (s == NORMAL)            return (V)x;        if (s &gt;= CANCELLED)            throw new CancellationException();        throw new ExecutionException((Throwable)x);//若状态异常则抛出outcome异常    }</pre><p>如上面分析到的，这样的话调用 FutureTask.run() 并不会直接抛出异常，所以在 ThreadPool.execute() 中捕获不到异常。但我们可以通过调用 get() 方法来捕捉异常。</p><h4 id="submit-解决方式"><a href="#submit-解决方式" class="headerlink" title="submit() 解决方式"></a>submit() 解决方式</h4><p>1、基本方式 try/catch，直接调用get()</p><p>2、重写  protected afterExecute(Runnable r,Throwable t ) { } 方法</p><p>想想如果我明明一开始调用的是 submit(Runnable r) ，为了捕捉异常还需刻意调用 get() 未免有点麻烦。Doug Lea 大佬已经在 JDK 文档中教我们可以重写 ThreadPoolExecutor 中的 afterExecute() 方法来实现异常捕获：</p><pre class="lang:java decode:true" title="SrcAnalyse5">    protected void afterExecute(Runnable r, Throwable t) {          super.afterExecute(r, t);          if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) {            try {              //如上文所说，主动调用get() 将异常抛出              Object result = ((Future&lt;?&gt;) r).get();            } catch (CancellationException ce) {                t = ce;            } catch (ExecutionException ee) {//异常捕获                t = ee.getCause();            } catch (InterruptedException ie) {                Thread.currentThread().interrupt(); // ignore/reset            }          }          if (t != null){            //异常处理            t.printStackTrace();          }        }</pre><h4 id="execute-方式："><a href="#execute-方式：" class="headerlink" title="execute() 方式："></a>execute() 方式：</h4><p>如代码SrcAnalyse2，此方法不同于submit() 会进行封装成Future ，其传递过去的就直接是Runnable,因此就会直接抛出：</p><pre class="lang:java decode:true" title="SrcAnalyse2-sample">    try {        task.run();//在此情况直接为Runnable.run()    } catch (RuntimeException x) {//异常被直接捕获        thrown = x; throw x;    } catch (Error x) {        thrown = x; throw x;    } catch (Throwable x) {        thrown = x; throw new Error(x);    } finally {        afterExecute(task, thrown);    }</pre><p>那么这里的异常到底会抛出到哪里呢, 我们看看JVM具体是怎么处理的：</p><pre class="lang:java decode:true " title="JVM-Analyse">if (!destroy_vm || JDK_Version::is_jdk12x_version()) {    // JSR-166: change call from from ThreadGroup.uncaughtException to    // java.lang.Thread.dispatchUncaughtException    if (uncaught_exception.not_null()) {      //如果有未捕获的异常      Handle group(this, java_lang_Thread::threadGroup(threadObj()));      {        KlassHandle recvrKlass(THREAD, threadObj-&gt;klass());        CallInfo callinfo;        KlassHandle thread_klass(THREAD, SystemDictionary::Thread_klass());        /*              这里类似一个方法表，实际就会去调用Thread#dispatchUncaughtException方法            template(dispatchUncaughtException_name,            "dispatchUncaughtException")                        */        LinkResolver::resolve_virtual_call(callinfo, threadObj, recvrKlass, thread_klass,                                           vmSymbols::dispatchUncaughtException_name(),                                           vmSymbols::throwable_void_signature(),                                           KlassHandle(), false, false, THREAD);        CLEAR_PENDING_EXCEPTION;        methodHandle method = callinfo.selected_method();        if (method.not_null()) {          JavaValue result(T_VOID);          JavaCalls::call_virtual(&amp;result,                                  threadObj, thread_klass,                                  vmSymbols::dispatchUncaughtException_name(),                                  vmSymbols::throwable_void_signature(),                                  uncaught_exception,                                  THREAD);        } else {          KlassHandle thread_group(THREAD, SystemDictionary::ThreadGroup_klass());          JavaValue result(T_VOID);          JavaCalls::call_virtual(&amp;result,                                  group, thread_group,                                  vmSymbols::uncaughtException_name(),                                  vmSymbols::thread_throwable_void_signature(),                                  threadObj,           // Arg 1                                  uncaught_exception,  // Arg 2                                  THREAD);        }        if (HAS_PENDING_EXCEPTION) {          ResourceMark rm(this);          jio_fprintf(defaultStream::error_stream(),                "\nException: %s thrown from the UncaughtExceptionHandler"                " in thread \"%s\"\n",                pending_exception()-&gt;klass()-&gt;external_name(),                get_thread_name());          CLEAR_PENDING_EXCEPTION;        }      }    }</pre><p>可以看到这里最终会去调用Thread#dispatchUncaughtException方法：</p><pre class="lang:java decode:true" title="SrcAnalyse6">    private void dispatchUncaughtException(Throwable e) {        //默认会调用ThreadGroup的实现        getUncaughtExceptionHandler().uncaughtException(this, e);    }​    public void uncaughtException(Thread t, Throwable e) {        if (parent != null) {            parent.uncaughtException(t, e);        } else {            Thread.UncaughtExceptionHandler ueh =                Thread.getDefaultUncaughtExceptionHandler();            if (ueh != null) {                ueh.uncaughtException(t, e);            } else if (!(e instanceof ThreadDeath)) {                //可以看到会打到System.err里面                System.err.print("Exception in thread \""                                 + t.getName() + "\" ");                e.printStackTrace(System.err);            }        }    }</pre><h4 id="execute-解决方式"><a href="#execute-解决方式" class="headerlink" title="execute() 解决方式"></a>execute() 解决方式</h4><p>1、基本方式，直接try/catch</p><p>2、线程重写 setUncaughtExceptionHandler() 方法</p><pre class="lang:java decode:true" title="Solution">       Thread t = new Thread();       t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {           public void uncaughtException(Thread t, Throwable e) {              LOGGER.error(t + " throws exception: " + e);           }        });        //如果是线程池的模式:        ExecutorService threadPool = Executors.newFixedThreadPool(1, r -&gt; {            Thread t = new Thread(r);            t.setUncaughtExceptionHandler(                (t1, e) -&gt; LOGGER.error(t1 + " throws exception: " + e));            return t;        });</pre><h3 id="2、ForkJoinPool"><a href="#2、ForkJoinPool" class="headerlink" title="2、ForkJoinPool"></a>2、ForkJoinPool</h3><p><code>ForkJoinPool</code>也是继承<code>AbstractExecutorService</code>的线程池，实现了 Fork/Join 及 work-stealing 以提升多核计算效率（详细的 ForkJoin 设计原理可参考<a href="http://www.molotang.com/articles/694.html" target="_blank" rel="noopener">三石 道</a> 、<a href="http://ifeve.com/a-java-fork-join-framework/" target="_blank" rel="noopener">并发编程网</a> ）。<br>因各版本 JDK 源码略有差异，此处仅为 JDK8 源码分析，且不具体分析线程池运行机制。</p><p>JDK源码中给了我们这样一个<strong>任务提交总结表</strong></p><table><thead><tr><th align="center">任务执行需求</th><th align="center">在非Fork/Join调用</th><th align="center">在Fork/Join计算中调用</th></tr></thead><tbody><tr><td align="center">异步执行无返回值</td><td align="center">execute(ForkJoinTask)</td><td align="center">ForkJoinTask.fork()</td></tr><tr><td align="center">等待获取返回值</td><td align="center">invoke(ForkJoinTask)</td><td align="center">ForkJoinTask.invoke()</td></tr><tr><td align="center">异步执行并获取Future</td><td align="center">submit(ForkJoinTask)</td><td align="center">ForkJoinTask.fork()</td></tr></tbody></table><blockquote><ol><li>非Fork/Join 和在 Fork/Join 中是指调用提交时所在的位置，前者为外部（main）通过 ForkJoinPool 本身提交 ForkJoinTask ，后者为 ForkJoinTask 执行中再将子任务提交到 ForkJoinPool 中。</li><li>ForkJoinTask fork 方法返回<code>this</code>，而 ForkJoinTask 本身实现 Future ，则第三种中可使用 <code>submit(ForkJoinTask).get()</code> 和 <code>ForkJoinTask.fork().get()</code>获取返回值，将 get 方法换成 join 也同样可行，区别只在于异常处理方式。</li><li>调用 <code>execute(Runnable)</code>、<code>submit(Runnable)</code>、<code>submit(Callable)</code>将通过 ForkJoinTask 的子类进行适配。</li><li>此外还有 <code>invokeAll(Collection  &lt;Callable&gt;)</code> 等方法，类似此处就不讨论。</li></ol></blockquote><pre><code>//ForkJoinPoolpublic &lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task) {} //提交并等待返回值public void execute(ForkJoinTask&lt;?&gt; task) {} //提交，异步执行public void execute(Runnable task) {}//提交并异步执行，返回ForkJoinTaskpublic &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) {}public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Callable&lt;T&gt; task) {}public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Runnable task, T result) {}public ForkJoinTask&lt;?&gt; submit(Runnable task) {}//ForkJoinTaskpublic final ForkJoinTask&lt;V&gt; fork() {} // 提交并异步执行public final V invoke() {} //提交并等待返回值</code></pre><h4 id="跟踪捕获"><a href="#跟踪捕获" class="headerlink" title="跟踪捕获"></a>跟踪捕获</h4><p>ForkJoinPool 中三种类型的提交方法都将调用 <code>externalPush(ForkJoinTask)</code> 或<code>externalSubmit(ForkJoinTask)</code>将参数封装成 ForkJoinTask 并 Push 到 已存在或初始化的 WorkQueue 中</p><p>我们绕过具体的任务调度、状态转换直接从执行 ForkJoinTask 的 ForkJoinWokerThread 来跟踪执行异常的处理 （每个这样的线程对象都在 ForkJoinPool 中有一对应的 WorkQueue）</p><p>线程run方法： ForkJoinWorkerThread.run()</p><pre><code>    public void run() {    if (workQueue.array == null) { // only run once        Throwable exception = null;        try {            onStart(); // 空方法            // 调用 ForkJoinPool 中方法开始执行            pool.runWorker(workQueue);              } catch (Throwable ex) {  // 此处捕获抛出的异常，最后将介绍             exception = ex;        } finally {             try {                    onTermination(exception); // 自定义收尾函数                } catch (Throwable ex) {                    if (exception == null)                        exception = ex;                } finally {                    pool.deregisterWorker(this, exception); // 自定义异常处理，最后介绍                }        }    }}</code></pre><p>线程执行循环： ForkJoinPool.runWorker(WorkQueue)</p><pre><code>final void runWorker(WorkQueue w) {    w.growArray();                   // 给 WorkQueue 分配任务数组    int seed = w.hint;               // 初始化随机数    int r = (seed == 0) ? 1 : seed;      for (ForkJoinTask&lt;?&gt; t;;) {        if ((t = scan(w, r)) != null) // 实现 work-stealing             w.runTask(t); // 调用 WorkQueue 方法执行任务 t            // 等待任务进入下一循环，若返回false，则退出循环线程进入结束        else if (!awaitWork(w, r))             break;        r ^= r &lt;&lt; 13; r ^= r &gt;&gt;&gt; 17; r ^= r &lt;&lt; 5; // 可先忽略    }}</code></pre><p>调用 WorkQueue 执行： WorkQueue.runTask(ForkJoinTask)</p><pre><code>final void runTask(ForkJoinTask&lt;?&gt; task) {        if (task != null) {            scanState &amp;= ~SCANNING;            // 调用 ForkJoinTask.doExec() 直接执行任务，此处未捕获或抛出            (currentSteal = task).doExec();              U.putOrderedObject(this, QCURRENTSTEAL, null); //             execLocalTasks(); // 继续执行 WorkQueue 中任务数组中任务            ForkJoinWorkerThread thread = owner;            if (++nsteals &lt; 0)                   transferStealCount(pool);            scanState |= SCANNING;            if (thread != null)                thread.afterTopLevelExec();        }    }</code></pre><p>最终调用任务执行方法： ForkJoinTask.doExec()</p><pre><code>final int doExec() {    int s; boolean completed;    if ((s = status) &gt;= 0) { // 任务状态判断，volatile保证可见性        try {            completed = exec(); // exec() 为抽象方法以自定义任务执行体        } catch (Throwable rex) { // 在此捕获所有任务内容抛出的异常            // 修改状态，并记录异常            return setExceptionalCompletion(rex);         }        if (completed)            s = setCompletion(NORMAL);    }    return s;}</code></pre><p>修改任务状态并记录异常： setExceptionalCompletion(Throwable)</p><pre><code>private int setExceptionalCompletion(Throwable ex) {    // 使用 Static+弱引用类型+类HashTable结构 变量记录全局异常    // 并设置状态为 EXCEPTIONAL ，下文详解    int s = recordExceptionalCompletion(ex);    if ((s &amp; DONE_MASK) == EXCEPTIONAL)    // 自定义异常传播（权限只在此并发包内）        internalPropagateException(ex);    return s;}</code></pre><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>ExceptionNode[ ] 实现类似 HashTable 以记录异常及异常的 ForkJoinTask。为什么使用弱引用呢？可以想象当分出的诸多子任务中一个子任务异常，势必造成之上的父任务异常，以此循环向上将造成大量异常对象，全部存储将有损效率。所以采用弱应用，当子任务的异常在父任务执行体中因执行 get、join、invoke 而抛出并被我们上面分析到的过程捕获，异常将被记录为父任务的异常并存储，此时子任务异常已没有意义子任务也无引用，使用弱引用可借用GC帮助清除</p><pre><code>static final class ExceptionNode extends WeakReference&lt;ForkJoinTask&lt;?&gt;&gt; {    final Throwable ex;    ExceptionNode next;  // 虽然设计成数组链表结构，可源码中并没以此存储    final long thrower;  // 用id代替引用，避免引用    final int hashCode;  // 在弱引用消失前记录ForkJoinTask 的 HashCode    ExceptionNode(ForkJoinTask&lt;?&gt; task, Throwable ex, ExceptionNode next) {        super(task, exceptionTableRefQueue);        this.ex = ex;        this.next = next;        this.thrower = Thread.currentThread().getId();        this.hashCode = System.identityHashCode(task);    }}</code></pre><p>既然已经记录下异常，那么怎样会抛出这些异常呢？在 ForkJoinTask 中提供方法获取</p><pre><code>private Throwable getThrowableException() {    if ((status &amp; DONE_MASK) != EXCEPTIONAL)        return null;    int h = System.identityHashCode(this);//获取HashCode    ExceptionNode e;    final ReentrantLock lock = exceptionTableLock;    lock.lock();    try {        // 通过ReferenceQueue清除已无意义ExceptionNode        expungeStaleExceptions();        //exptionTable是static ExceptionNode[]存储全局异常        ExceptionNode[] t = exceptionTable;        e = t[h &amp; (t.length - 1)];//以HashCode求数组下标        while (e != null &amp;&amp; e.get() != this)            e = e.next;//得到对于ExceptionNode    } finally {        lock.unlock();    }    Throwable ex;    if (e == null || (ex = e.ex) == null)//从ExceptionNode中取异常        return null;    // 如果出错线程不是当前线程，则在构造此异常以便在提供准确的异常堆栈轨迹    if (e.thrower != Thread.currentThread().getId()) {        Class&lt;? extends Throwable&gt; ec = ex.getClass();        try {        // ...........        } catch (Exception ignore) {        }    }    return ex;}</code></pre><p>上面已提到 ForkJoinTask 中调用到此方法获取异常的有 get、join、invoke、invokeAll<br>其中的 join、invoke、invokeAll 采用如下抛出 Unchecked 异常，而JDK源码示例中也<strong>推荐在任务体中使用这几种</strong>。</p><pre><code>static void rethrow(Throwable ex) {    if (ex != null)        ForkJoinTask.&lt;RuntimeException&gt;uncheckedThrow(ex);}@SuppressWarnings(&quot;unchecked&quot;) static &lt;T extends Throwable&gt;    void uncheckedThrow(Throwable t) throws T {    throw (T)t; }</code></pre><p>而 get 因实现自 Future 而将异常封装成统一的 ExecutionException </p><pre><code>public final V get() throws InterruptedException, ExecutionException {    int s = (Thread.currentThread() instanceof ForkJoinWorkerThread) ?        doJoin() : externalInterruptibleAwaitDone();    Throwable ex;    if ((s &amp;= DONE_MASK) == CANCELLED)        throw new CancellationException();    if (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != null)        throw new ExecutionException(ex);//封装成统一的Checked异常    return getRawResult();}</code></pre><blockquote><p> <strong>因此只要在执行体中进行合适 Fork/Join 任务分解，并在非 Fork/Join 中给 ForkJoinPool 提交后调用提交或返回的 ForkJoinTask 中 get、join、invoke 方法（即使无返回值也可以调用来抛出），再加以 try/catch 就能捕获到任务体执行过程中的异常。</strong></p></blockquote><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p> 要是我通过<code> ForkJoinPool.execute(Runnable) </code> 提交的任务，本身就没有 <code>ForkJoinTask </code>且此方法也没有返回 <code>ForkJoinTask</code> ，这种情况将如何捕获异常呢？</p><p>其实此方法将 Runnable 封装为 ForkJoinTask 的子类，此子类拓展了上面提到的 <code>internalPropagateException(Throwable) </code>异常传播方法，并在其中抛出异常被在上文介绍的 <code>ForkJoinWorkerThread.run()</code>这个方法捕获，并调用 ForkJoinWorkerThread 中<code> onTermination(Throwable exception) </code> 收尾函数，最终都将调用 <code>ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) </code>并在其中抛出。</p><pre><code>try {     onTermination(exception); // 可添加自定义处理，但不做捕获     } catch (Throwable ex) {         if (exception == null)             exception = ex;     } finally {         pool.deregisterWorker(this, exception);// 最终都将抛出异常     }</code></pre><p>没人管了？肯定不会的。</p><p>第一部分讲到的<code> Thread.UncaughtExceptionHandler </code>在这里也同样起作用，给 ForkJoinPool 构造函数传入UncaughtExceptionHandler，则所有 <code> ForkJoinWorkerThread </code>都将被设置成此以处理异常（设计得就是这么周到 XD）。当然你要不嫌麻烦选择自定义<code> ForkJoinWorkerThreadFactory </code>也是没问题的</p><pre><code>public ForkJoinPool(int parallelism,                    ForkJoinWorkerThreadFactory factory,                    UncaughtExceptionHandler handler,                    boolean asyncMode) {    this(checkParallelism(parallelism),         checkFactory(factory),         handler,         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,         &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);    checkPermission();}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LockSupport.park 与wait用法示例</title>
      <link href="/2017/08/26/Use-Example-locksupport-And-Wait/"/>
      <url>/2017/08/26/Use-Example-locksupport-And-Wait/</url>
      
        <content type="html"><![CDATA[<p>自Java1.6引入的LockSupport为开发者提供新的阻塞、唤醒线程的原语方法，只是平时都是使用已经封装好的各种Lock、Latch、Synchronizer并不常见到。在学习过程中看到这篇对比LockSupport.park() 方法和wait() 方法的示例<a href="http://www.cnblogs.com/skywang12345/p/3505784.html" target="_blank" rel="noopener">Java多线程系列–“JUC锁”07之 LockSupport</a><a href="http://www.cnblogs.com/skywang12345/p/3505784.html" target="_blank" rel="noopener"> </a>来自<a href="http://www.cnblogs.com/skywang12345/" target="_blank" rel="noopener">skywang12345</a>是的引起自己诸多疑惑，便打算按照编码实践一番。<a id="more"></a></p><p>在这就直接绕过基本介绍 ，详细实现可参考 <a href="https://my.oschina.net/readjava/blog/282882" target="_blank" rel="noopener">https://my.oschina.net/readjava/blog/282882</a></p><h3 id="LockSupport-函数列表"><a href="#LockSupport-函数列表" class="headerlink" title="LockSupport 函数列表"></a>LockSupport 函数列表</h3><pre class="lang:java decode:true" title="LockSupport-method">// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。static Object getBlocker(Thread t)// 为了线程调度，禁用当前线程，除非许可可用。static void park()// 为了线程调度，在许可可用之前禁用当前线程。static void park(Object blocker)// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。static void parkNanos(long nanos)// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。static void parkNanos(Object blocker, long nanos)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(long deadline)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(Object blocker, long deadline)// 如果给定线程的许可尚不可用，则使其可用。static void unpark(Thread thread)</pre><h3 id="Object-wait-阻塞示例"><a href="#Object-wait-阻塞示例" class="headerlink" title="Object.wait() 阻塞示例"></a>Object.wait() 阻塞示例</h3><pre class="lang:java decode:true" title="Object.wait()">public class WaitTest {    public static void main(String[] args) {        ThreadA ta = new ThreadA("ta");        synchronized(ta) { // 通过synchronized(ta)获取“对象ta的同步锁”            try {                System.out.println(Thread.currentThread().getName()+" start ta");                ta.start();//断点一                System.out.println("Do something before "+Thread.currentThread().getName()+"block");                for (int i=0;i&lt;Integer.MAX_VALUE;i++) ;                System.out.println(Thread.currentThread().getName()+" block");                // 主线程等待                ta.wait();//断点二                System.out.println(Thread.currentThread().getName()+" continue");            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    static class ThreadA extends Thread{        public ThreadA(String name) {            super(name);        }        public void run() {            synchronized (this) { // 通过synchronized(this)获取“当前对象的同步锁”                System.out.println(Thread.currentThread().getName()+" wakup others");//断点三                notify();    // 唤醒“当前对象上的等待线程”                System.out.println("After wakup");//断点四            }        }    }}</pre><p>输出：</p><pre class="lang:java decode:true" title="result1">main start taDo something before mainblockmain blockta wakup othersAfter wakupmain continue</pre><p>断点经历过程顺序：</p><table style="height: 33px;" width="705"><tbody><tr><th>线程名</th><td>断点一</td><td>断点二</td><td>断点三</td><td>断点四</td></tr><tr><th>main</th><td>RUNNING</td><td>RUNNING</td><td>WAIT</td><td>MONITOR</td></tr><tr><th>ta</th><td>未创建</td><td>MONITOR</td><td>RUNNING</td><td>RUNNING</td></tr></tbody></table><p>断点二开始：</p><blockquote><p>ta 线程 MONITOR 状态表示线程处于 synchronized (this)，正在等待main 线程释放 ta 对象的锁（monitor）</p><p>main 线程中调用 ta.wait() 释放对象 ta 的锁，并进入WAIT 状态，ta 线程获取到锁后进入 RUNNING状态</p><p>ta 线程中调用 notify() 唤醒一个调用自身对象 ta.wait() 方法的线程，于是 main 线程状态从WAIT到MONITOR</p></blockquote><p>&nbsp;</p><h3 id="LockSupport-park-阻塞示例"><a href="#LockSupport-park-阻塞示例" class="headerlink" title="LockSupport.park() 阻塞示例"></a>LockSupport.park() 阻塞示例</h3><pre class="lang:java decode:true" title="LockSupport.park()">import java.util.concurrent.locks.LockSupport;public class LockSupportTest1 {    private static Thread mainThread;    public static void main(String[] args) {        ThreadA ta = new ThreadA("ta");        // 获取主线程        mainThread = Thread.currentThread();        System.out.println(Thread.currentThread().getName()+" start ta");        ta.start();//断点一        System.out.println(Thread.currentThread().getName()+" block");        // 主线程阻塞        LockSupport.park(Thread.currentThread());//断点二        System.out.println(Thread.currentThread().getName()+" continue");    }    static class ThreadA extends Thread{        public ThreadA(String name) {            super(name);        }        public void run() {            System.out.println(Thread.currentThread().getName()+" wakup others");//断点三            // 唤醒“主线程”            LockSupport.unpark(mainThread);            System.out.println("After wakup others");//断点四        }    }}</pre><p>断点顺序很可能是 一 -&gt; 三 -&gt; 四 -&gt; 二 或者 一 -&gt; 三 -&gt;二 等等，单是线程都不会出现 MONITOR 状态</p><p>所有输出的情况也有多种情况，甚至会出现先执行unpark 后执行 park 当时依然可以输出 main continue</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、wait 是通过线程对对象的锁的占用、释放来间接实现阻塞、和唤醒的，并且调用对象的wait 方法 必须要拥有此对象的锁。而 park 则实现线程阻塞机制却不同，不需要对对象的锁进行操作。</p><p>2、若通过wait 方法调用来实现线程间阻塞、唤醒的配合的话，需要考虑好wait 和 notify、notifyAll 的配合顺序，不然可能出现先执行notify 后执行notify 导致线程一直处于WAIT 状态。而通过park 和 unpark 实现线程间的配合则不需要考虑这些，即使 unpark 先执行不会阻塞线程 ，后执行 park 也不会阻塞线程。这是因为实现上 park 和 unpark 是通过对被称为许可证的数值进行增减操作，通过对此许可证值的判断来进行阻塞、唤醒操作的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>详细介绍实现 <a href="https://my.oschina.net/readjava/blog/282882" target="_blank" rel="noopener">https://my.oschina.net/readjava/blog/282882</a></p><p>Oracle官方文档 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html</a></p><p>简书 <a href="http://www.jianshu.com/u/42116042245c" target="_blank" rel="noopener">miaoLoveCode</a> <a href="http://www.jianshu.com/p/ceb8870ef2c5" target="_blank" rel="noopener">http://www.jianshu.com/p/ceb8870ef2c5</a></p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一行一行源码分析清楚AQS[转]</title>
      <link href="/2017/08/25/Analyze-JDK-AQS/"/>
      <url>/2017/08/25/Analyze-JDK-AQS/</url>
      
        <content type="html"><![CDATA[<p>在分析java并发包java.util.concurrent源码的时候，少不了需要了解AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是java并发包的基础工具类，是实现ReentrantLock、CountDownLatch、Semaphore、FutureTask等类的基础。</p><p>Google一下AbstractQueuedSynchronizer，我们可以找到很多关于AQS的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从ReentrantLock的公平锁源码出发，分析下AbstractQueuedSynchronizer这个类是怎么工作的，希望能给大家提供一些简单的帮助。<a id="more"></a></p><p>原文链接 <a href="https://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">https://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/</a></p><p>申明以下几点：</p><ol><li>本文有点长，但是很简单很简单很简单，主要面向读者对象为并发编程的初学者，或者想要阅读java并发包源码的开发者。</li><li>建议在电脑上阅读，如果你想好好地理解所有的细节，而且你从来没看过相关的分析，你可能至少需要20分钟仔细看所有的描述，本文后面的1/3以上很简单，前面的1/4更简单，中间的部分要好好看。</li><li>如果你不知道为什么要看这个，我想告诉你，即使你看懂了所有的细节，你可能也不能把你的业务代码写得更好</li><li>源码环境JDK1.7，看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea大神的代码写得真心不错。</li><li>有很多英文注释我没有删除，这样读者可以参考着英文说的来，万一被我忽悠了呢</li><li>本文不分析共享模式，这样可以给读者减少很多负担，只要把独占模式看懂，共享模式读者应该就可以顺着代码看懂了。而且也不分析condition部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的ReentrantLock的概念，本质上来说是不正确的，读者应该清楚，AQS不仅仅用来实现锁，只是希望读者可以用锁来联想AQS的使用场景，降低读者的阅读压力</li><li>ReentrantLock的公平锁和非公平锁只有一点点区别，没有任何阅读压力</li><li>你需要提前知道什么是CAS(CompareAndSet)<br>废话结束，开始。</li></ol><h2 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h2><p>先来看看AQS有哪些属性，搞清楚这些基本就知道AQS是什么套路了，毕竟可以猜嘛！</p><pre class="lang:java decode:true" title="AQS-Structure">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的private transient volatile Node head;// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个隐视的链表private transient volatile Node tail;// 这个是最重要的，不过也是最简单的，代表当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁// 之所以说大于0，而不是等于1，是因为锁可以重入嘛，每次重入都加上1private volatile int state;// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁// if (currentThread == getExclusiveOwnerThread()) {state++}private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</pre><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer的等待队列示意如下所示，注意了，之后分析过程中所说的queue，也就是阻塞队列不包含head，不包含head，不包含head。</p><p><img src="/images/2017/08/aqs-0.png" alt></p><p>等待队列中每个线程被包装成一个node，数据结构是链表，一起看看源码吧：</p><pre class="lang:java decode:true " title="AQS-src1">static final class Node {    /** Marker to indicate a node is waiting in shared mode */    // 标识节点当前在共享模式下    static final Node SHARED = new Node();    /** Marker to indicate a node is waiting in exclusive mode */    // 标识节点当前在独占模式下    static final Node EXCLUSIVE = null;    // ======== 下面的几个int常量是给waitStatus用的 ===========    /** waitStatus value to indicate thread has cancelled */    // 代码此线程取消了争抢这个锁    static final int CANCELLED =  1;    /** waitStatus value to indicate successor's thread needs unparking */    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒    static final int SIGNAL    = -1;    /** waitStatus value to indicate thread is waiting on condition */    // 本文不分析condition，所以略过吧    static final int CONDITION = -2;    /**     * waitStatus value to indicate the next acquireShared should     * unconditionally propagate     */    // 同样的不分析，略过吧    static final int PROPAGATE = -3;    // =====================================================    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，    // 也许就是说半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。    volatile int waitStatus;    // 前驱节点的引用    volatile Node prev;    // 后继节点的引用    volatile Node next;    // 这个就是线程本尊    volatile Thread thread;}</pre><p>Node的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说ReentrantLock的公平锁。多嘴一下，我说的阻塞队列不包含head节点。</p><p><img src="/images/2017/08/aqs-0.png" alt></p><p>首先，我们先看下ReentrantLock的使用方式。</p><pre class="lang:java decode:true " title="AQS-sample1">// 我用个web开发中的service概念吧public class OrderService {    // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个    private static ReentrantLock reentrantLock = new ReentrantLock(true);    public void createOrder() {        // 比如我们同一时间，只允许一个线程创建订单        reentrantLock.lock();        // 通常，lock 之后紧跟着 try 语句        try {            // 这块代码同一时间只能有一个线程进来(获取到锁的线程)，            // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来            // 执行代码...            // 执行代码...            // 执行代码...        } finally {            // 释放锁            reentrantLock.unlock();        }    }}</pre><p>ReentrantLock在内部用了内部类Sync来管理锁，所以真正的获取锁和释放锁是由Sync的实现类来控制的。</p><pre class="lang:java decode:true" title="AQS-src2">abstract static class Sync extends AbstractQueuedSynchronizer {}</pre><p>Sync有两个实现，分别为NonfairSync（非公平锁）和FairSync（公平锁），我们看FairSync部分。</p><pre class="lang:java decode:true " title="ReentrantLock1">public ReentrantLock(boolean fair) {    sync = fair ? new FairSync() : new NonfairSync();}</pre><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><pre class="lang:java decode:true " title="AQS-src2">static final class FairSync extends Sync {    private static final long serialVersionUID = -3000897897090466540L;      // 争锁    final void lock() {        acquire(1);    }      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。    // 否则，acquireQueued方法会将线程压到队列中    public final void acquire(int arg) { // 此时 arg == 1        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试        // 因为有可能直接就成功了呢，也就不需要进队列排队了，        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)        if (!tryAcquire(arg) &amp;&amp;            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {              selfInterrupt();        }    }    /**     * Fair version of tryAcquire.  Don't grant access unless     * recursive call or no waiters or is first.     */    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取    protected final boolean tryAcquire(int acquires) {        final Thread current = Thread.currentThread();        int c = getState();        // state == 0 此时此刻没有线程持有锁        if (c == 0) {            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，            // 看看有没有别人在队列中等了半天了            if (!hasQueuedPredecessors() &amp;&amp;                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=                // 因为刚刚还没人的，我判断过了😂😂😂                compareAndSetState(0, acquires)) {                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁                setExclusiveOwnerThread(current);                return true;            }        }          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1        else if (current == getExclusiveOwnerThread()) {            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error("Maximum lock count exceeded");            setState(nextc);            return true;        }        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁        // 回到上面一个外层调用方法继续看:        // if (!tryAcquire(arg)         //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))         //     selfInterrupt();        return false;    }    // 假设tryAcquire(arg) 返回false，那么代码将执行：      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)    /**     * Creates and enqueues node for current thread and given mode.     *     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared     * @return the new node     */    // 此方法的作用是把线程包装成node，同时进入到队列中    // 参数mode此时是Node.EXCLUSIVE，代表独占模式    private Node addWaiter(Node mode) {        Node node = new Node(Thread.currentThread(), mode);        // Try the fast path of enq; backup to full enq on failure        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后        Node pred = tail;        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)        if (pred != null) {             // 设置自己的前驱 为当前的队尾节点            node.prev = pred;             // 用CAS把自己设置为队尾, 如果成功后，tail == node了            if (compareAndSetTail(pred, node)) {                 // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，                // 上面已经有 node.prev = pred                // 加上下面这句，也就实现了和之前的尾节点双向连接了                pred.next = node;                // 线程入队了，可以返回了                return node;            }        }        // 仔细看看上面的代码，如果会到这里，        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的        enq(node);        return node;    }    /**     * Inserts node into queue, initializing if necessary. See picture above.     * @param node the node to insert     * @return node's predecessor     */    // 采用自旋的方式入队    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的    private Node enq(final Node node) {        for (;;) {            Node t = tail;            // 之前说过，队列为空也会进来这里            if (t == null) { // Must initialize                // 初始化head节点                // 细心的读者会知道原来head和tail初始化的时候都是null，反正我不细心                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢                if (compareAndSetHead(new Node()))                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了                    // 这个时候有了head，但是tail还是null，设置一下，                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了                    tail = head;            } else {                // 下面几行，和上一个方法 addWaiter 是一样的，                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排                node.prev = t;                if (compareAndSetTail(t, node)) {                    t.next = node;                    return t;                }            }        }    }    // 现在，又回到这段代码了    // if (!tryAcquire(arg)     //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))     //     selfInterrupt();    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了    final boolean acquireQueued(final Node node, int arg) {        boolean failed = true;        try {            boolean interrupted = false;            for (;;) {                final Node p = node.predecessor();                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列                // 所以当前节点可以去试抢一下锁                // 这里我们说一下，为什么可以去试试：                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state                if (p == head &amp;&amp; tryAcquire(arg)) {                    setHead(node);                    p.next = null; // help GC                    failed = false;                    return interrupted;                }                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    interrupted = true;            }        } finally {            if (failed)                cancelAcquire(node);        }    }    /**     * Checks and updates status for a node that failed to acquire.     * Returns true if thread should block. This is the main signal     * control in all acquire loops.  Requires that pred == node.prev     *     * @param pred node's predecessor holding status     * @param node the node     * @return {@code true} if thread should block     */    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {        int ws = pred.waitStatus;        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true        if (ws == Node.SIGNAL)            /*             * This node has already set status asking a release             * to signal it, so it can safely park.             */            return true;        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。这里需要知道这点：        // 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，        // 找前驱节点的前驱节点做爹，往前循环总能找到一个好爹的        if (ws &gt; 0) {            /*             * Predecessor was cancelled. Skip over predecessors and             * indicate retry.             */            do {                node.prev = pred = pred.prev;            } while (pred.waitStatus &gt; 0);            pred.next = node;        } else {            /*             * waitStatus must be 0 or PROPAGATE.  Indicate that we             * need a signal, but don't park yet.  Caller will need to             * retry to make sure it cannot acquire before parking.             */            // 仔细想想，如果进入到这个分支意味着什么            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        }        return false;    }    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)    // 这个方法结束根据返回值我们简单分析下：    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看    // 跳回到前面是这个方法    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;    //                parkAndCheckInterrupt())    //                interrupted = true;    // 1\. 如果shouldParkAfterFailedAcquire(p, node)返回true，    // 那么需要执行parkAndCheckInterrupt():    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======    private final boolean parkAndCheckInterrupt() {        LockSupport.park(this);        return Thread.interrupted();    }    // 2\. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。}</pre><p>说到这里，也就明白了，多看几遍final boolean acquireQueued(final Node node, int arg)这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被LockSupport.park(this);挂起停止，等待被唤醒。</p><pre class="lang:java decode:true " title="AQS-src3">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了public void unlock() {    sync.release(1);}public final boolean release(int arg) {    // 往后看吧    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}// 回到ReentrantLock看tryRelease方法protected final boolean tryRelease(int releases) {    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    // 是否完全释放锁    boolean free = false;    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉    if (c == 0) {        free = true;        setExclusiveOwnerThread(null);    }    setState(c);    return free;}/** * Wakes up node's successor, if one exists. * * @param node the node */// 唤醒后继节点// 从上面调用处知道，参数node是head头结点private void unparkSuccessor(Node node) {    /*     * If status is negative (i.e., possibly needing signal) try     * to clear in anticipation of signalling.  It is OK if this     * fails or if status is changed by waiting thread.     */    int ws = node.waitStatus;    // 如果head节点当前waitStatus&lt;0, 将其修改为0    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    /*     * Thread to unpark is held in successor, which is normally     * just the next node.  But if cancelled or apparently null,     * traverse backwards from tail to find the actual     * non-cancelled successor.     */    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的    Node s = node.next;    if (s == null || s.waitStatus &gt; 0) {        s = null;        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    }    if (s != null)        // 唤醒线程        LockSupport.unpark(s.thread);}</pre><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><pre class="lang:java decode:true " title="AQS-src4">private final boolean parkAndCheckInterrupt() {    LockSupport.park(this); // 刚刚线程被挂起在这里了    return Thread.interrupted();}// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</pre><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是state的作用，它为0的时候代表没有线程占有锁，可以去争抢这个锁，用CAS将state设为1，如果CAS成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行+1就可以，解锁就是减1，直到state又变为0，代表释放锁，所以lock()和unlock()必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS中采用了LockSupport.park(thread) 来挂起线程，用unpark来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个queue来管理这些线程，AQS用的是一个FIFO的队列，就是一个链表，每个node都持有后继节点的引用。AQS采用了CLH锁的变体来实现，感兴趣的读者可以参考这篇文章关于CLH的介绍，写得简单明了: <a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">http://coderbee.net/index.php/concurrent/20131115/577</a></li></ol><h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回true了，结束。只是设置了state=1，连head都没有初始化，更谈不上什么阻塞队列了。要是线程1调用unlock()了，才有线程2来，那世界就太太太平了，完全没有交集嘛，那我还要AQS干嘛。</p><p>如果线程1没有调用unlock()之前，线程2调用了lock(), 想想会发生什么？</p><p>线程2会初始化head【new Node()】，同时线程2也会插入到阻塞队列并挂起 (注意看这里是一个for循环，而且设置head和tail的部分是不return的，只有入队成功才会跳出循环)</p><pre class="lang:java decode:true" title="AQS-src5">private Node enq(final Node node) {    for (;;) {        Node t = tail;        if (t == null) { // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        } else {            node.prev = t;            if (compareAndSetTail(t, node)) {                t.next = node;                return t;            }        }    }}</pre><p>首先，是线程2初始化head节点，此时head==tail, waitStatus==0</p><p><img src="/images/2017/08/aqs-1.png" alt></p><p>然后线程2入队：</p><p><img src="/images/2017/08/aqs-2.png" alt></p><p>同时我们也要看此时节点的waitStatus，我们知道head节点是线程2初始化的，此时的waitStatus没有设置，java默认会设置为0，但是到shouldParkAfterFailedAcquire这个方法的时候，线程2会把前驱节点，也就是head的waitStatus设置为-1。</p><p>那线程2节点此时的waitStatus是多少呢，由于没有设置，所以是0；</p><p>如果线程3此时再进来，直接插到线程2的后面就可以了，此时线程3的waitStatus是0，到shouldParkAfterFailedAcquire方法的时候把前驱节点线程2的waitStatus设置为-1。</p><p><img src="/images/2017/08/aqs-3.png" alt></p><p>这里可以简单说下waitStatus中SIGNAL(-1)状态的意思，Doug Lea注释的是：代表后继节点需要被唤醒。也就是说这个waitStatus其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个node在入队的时候，都会把前驱节点的状态改为SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着“waitStatus代表后继节点的状态”这种思路去看一遍源码。</p><p>（全文完）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 转载 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 插件推荐</title>
      <link href="/2017/08/18/Chrome-Plugins/"/>
      <url>/2017/08/18/Chrome-Plugins/</url>
      
        <content type="html"><![CDATA[<p>在经历本人金融危机后，终于重新搭建起自己的”帆樯”服务器。不得不说呼吸外面新鲜空气的感觉真是太爽了，赶紧把公司电脑里饥渴的Chrome折腾起来。在这里推荐几个在个人工作中感觉很实用的插件。</p><p><img src="/images/2017/08/google_chrome.png" alt></p><a id="more"></a><h3 id="1、Infinity新标签页"><a href="#1、Infinity新标签页" class="headerlink" title="1、Infinity新标签页"></a>1、Infinity新标签页</h3><p>是我折腾过的标签页中最满意的。界面美观简洁、功能丰富。并提供天气预报、笔记、待办事项及诸多自定义功能。</p><p><img src="/images/2017/08/infinity.png" alt></p><h3 id="2、马克飞象"><a href="#2、马克飞象" class="headerlink" title="2、马克飞象"></a>2、马克飞象</h3><p>来自印象笔记的Chrome插件。如果你不满足于简单的笔记，那么这个支持Markdown语法的笔记插件可以尝试下。即开即用、功能齐全，如需云笔记功能可以绑定自己印象笔记账号。</p><p><img src="/images/2017/08/Markfeixiang.png" alt></p><h3 id="3、Vimium"><a href="#3、Vimium" class="headerlink" title="3、Vimium"></a>3、Vimium</h3><p>号称黑客的浏览器插件。通过提供键盘快捷键来操作Chrome，实现类似Vim 一般的0鼠标操作。下图帮助界面包含基本的操作快捷键，你可以使用高级或自定义（其中的很多操作快捷键与真正的Vim快捷键不一致，有Vim强迫症的慎入）。</p><p><img src="/images/2017/08/Vimium.jpg" alt>)更清晰的中文说明可以看看简书的<a href="http://www.jianshu.com/p/5b627a24f7aa" target="_blank" rel="noopener">这篇</a></p><h3 id="4、Postman-amp-amp-Firebug"><a href="#4、Postman-amp-amp-Firebug" class="headerlink" title="4、Postman &amp;&amp; Firebug"></a>4、Postman &amp;&amp; Firebug</h3><p>这两个算是经典的IT插件。前者提供简单、齐全的API测试功能，后者更是前端开发者必备，懂的应该都懂就不多介绍了。</p><h3 id="5、Awesome-Screenshot"><a href="#5、Awesome-Screenshot" class="headerlink" title="5、Awesome Screenshot"></a>5、Awesome Screenshot</h3><p>正如名字及下图的说明一样，这个功能强大的截屏插件算是最好用的了。</p><p><img src="/images/2017/08/screenshot.png" alt></p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux parted、siege 工具小记</title>
      <link href="/2017/08/16/Linux-Tool-pared-And-siege-Notes/"/>
      <url>/2017/08/16/Linux-Tool-pared-And-siege-Notes/</url>
      
        <content type="html"><![CDATA[<p>这一会在折腾debian9系统，尝试磁盘操作时发现就只有个df 命令并没有fdisk、cfdisk等工具。于是找到了parted这一工具（其实在我之前一直用的Ubuntu中有，只是fdisk、cfdisk用的多一点）。而siege 则是一个FTP/HTTP压力测试工具，能够很方便测试自己的web系统。</p><p><img src="/images/2017/08/DebianDesktop.png" alt="漂亮简洁的Debian桌面"></p><a id="more"></a><h2 id="1、parted"><a href="#1、parted" class="headerlink" title="1、parted"></a>1、parted</h2><p>强大的磁盘管理工具。安装的话只需要简单的apt-get，并且运行时需要以root身份。</p><p>parted -l 将列出所有系统能识别的磁盘设备，如下图中有一块8590MB的磁盘设备/dev/sdc，这是刚用vmware给debian添加的一块硬盘。</p><p><img src="/images/2017/08/parted1.png" alt></p><p>下图是完整的分区过程：</p><p><img src="/images/2017/08/parted6.png" alt="完整步骤"></p><p>步骤说明：</p><ol><li>执行 sudo parted 进入交互模式，默认选中/dev/sda 设备</li><li>输入 help 打印提示信息</li><li>输入 select /dev/sdc 选中需要操作的磁盘设备</li><li>输入 make gpt 设置分区模式为 gpt</li><li>输入 mkpart extended 64s 4MiB 新建extended 小分区 （此举为了对齐磁盘分区）</li><li>输入 mkpart primary 4MiB 8590MiB 新建 primary 主分区（提示越界）</li><li>输入 mkpart primary 4MiB -1s  新建primary 主分区（-1s 为最后一个Sector ，工具将自动提示我们，输入Yes即可）</li><li>输入 print 打印 /dev/sdc 磁盘设备分区情况（两个分区）</li><li>输入 help align-check 打印对齐检测帮助信息（可略）</li><li>输入 align-check optimal 2 检查 primary 分区对齐情况（align-type 可选minimal、optimal 或缩写），符合对齐则显示 2 aligned</li><li>quit 退出操作<br>之后需要格式化 primary 分区（文件系统ext4）：<pre class="lang:sh decode:true" title="mkfs.ext4">sudo mkfs.ext4 /dev/sdc2</pre><img src="/images/2017/08/parted4.png" alt></li></ol><p>&nbsp;</p><p>最后挂载 /dev/sdc2 到你需要的目录即可使用</p><pre class="lang:sh decode:true " title="mount">mount /dev/sdc2 /mnt</pre><p>修改 /etc/fstab 文件可以开机自动挂载设备，格式如下（各个&lt;&gt;值、作用可以通过 man fstab 查看到详细信息）：</p><p><img src="/images/2017/08/parted7.png" alt></p><blockquote><p>注：其中 &lt;file system&gt; 可以是 /dev/sdc2 ，也可是此分区的UUID。UUID可以在 /dev/disk/by-uuid 中查看到所有的。</p><p><img src="/images/2017/08/parted8.png" alt><br>关于磁盘、分区、文件系统资料：</p></blockquote><p><a href="http://www.cnblogs.com/sammyliu/p/4521315.html" target="_blank" rel="noopener">http://www.cnblogs.com/sammyliu/p/4521315.html</a></p><p>关于磁盘分区对齐：</p><p><a href="https://linux.cn/article-3167-1.html" target="_blank" rel="noopener">https://linux.cn/article-3167-1.html</a></p><p>GNU parted命令手册：</p><p><a href="http://www.gnu.org/software/parted/manual/parted.html" target="_blank" rel="noopener">http://www.gnu.org/software/parted/manual/parted.html</a></p><h2 id="2、siege"><a href="#2、siege" class="headerlink" title="2、siege"></a>2、siege</h2><p>支持HTTP/HTTPS/FTP的压力测试工具。安装同样很简单apt-get（Debian、Ubuntu一致的让人感动），而且使用很简单。</p><h3 id="常见参数："><a href="#常见参数：" class="headerlink" title="常见参数："></a>常见参数：</h3><blockquote><p>-c 200 指定并发数200</p><p>-r 5 指定测试的次数5</p><p>-f urls.txt 制定url的文件</p><p>-i internet系统，随机发送url</p><p>-b 请求无需等待 delay=0</p><p>-t 5 持续测试5分钟</p><p>-d 设置测试的delay</p><p> -r和-t一般不同时使用</p></blockquote><h3 id="常见使用："><a href="#常见使用：" class="headerlink" title="常见使用："></a>常见使用：</h3><p>50个用户（每次并发量）重复100次 共产生 50*100 个请求</p><div><pre class="lang:sh decode:true " title="example1">/usr/local/siege/bin/siege -c 50 -r 100 www.baidu.com</pre>50个用户 重复100次 发送POST参数(从文件中读取)<pre class="lang:sh decode:true" title="example2">/usr/local/siege/bin/siege -c 50 -r 100 \    "https://www.abc.com/a.php POST &lt; /root/ab_test/post.xml"</pre></div><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><div>    Transactions:                     10 hits    ：服务器接收的请求数</div><div>    Availability:                 100.00 %       ：有效情况的比例</div><div>    Elapsed time:                   1.06 secs    :  测试所用的时间</div><div>    Data transferred:               0.04 MB    ：每个模拟用户的数据传输量</div><div>    Response time:                  0.03 secs    ：响应每个模拟用户请求的平均时间</div><div>    Transaction rate:               9.43 trans/sec    ：服务器每秒处理事务的平均数</div><div>    Throughput:                     0.04 MB/sec    ：服务器每秒跟所有模拟用户的数据传量</div><div>    Concurrency:                    0.25    ：每秒的模拟连接</div><div>    Successful transactions:          10    ：处理成功的事务数（code&lt;400）</div><div>    Failed transactions:               0    ： 处理失败的事务数（code&gt;400）</div><div>    Longest transaction:            0.04    ：最长的事务处理时间</div><div>    Shortest transaction:           0.02    ：最短的事务处理时间</div><div></div><div>提醒：并发太高的测试容易让待测试服务器的云平台管理员认为是DDOS攻击，并且也容易把服务器负荷太重影响正常服务。</div><h2 id="3、额外一提"><a href="#3、额外一提" class="headerlink" title="3、额外一提"></a>3、额外一提</h2><div>在使用Debian 时，发现没有预安装Vim，手动apt-get 安装后发现安装的Vim没有系统寄存器，Vim 无法使用系统剪贴板确实很不方便。</div><div></div><div>额外手动安装 vim-gnome 即可解决。</div><div></div><div>附带一张Vim键盘图</div><div>![](/images/2017/08/vim.png)</div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你可能不知道的Shell</title>
      <link href="/2017/07/27/The-Shell-You-Dont-Know/"/>
      <url>/2017/07/27/The-Shell-You-Dont-Know/</url>
      
        <content type="html"><![CDATA[<p>Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。</p><p>这篇文章向大家介绍Shell一些非广为人知、但却实用有趣的知识，权当品尝shell主食后的甜点吧。</p><p><img src="/images/2017/04/bash.jpg" alt></p><a id="more"></a><p>原文转载自：酷壳-CoolShell <a href="http://coolshell.cn/articles/8619.html" target="_blank" rel="noopener">http://coolshell.cn/articles/8619.html</a> （一个值得订阅的IT博客）</p><p>跳过科普</p><blockquote><p><strong>一些强大的命令</strong><br>再分享一些可能你不知道的shell用法和脚本，简单&amp;强大！</p></blockquote><p><em>在阅读以下部分前，强烈建议读者打开一个shell实验，这些都不是shell教科书里的大路货哦：）</em></p><ul><li><p><code>**!$**!$是一个特殊的环境变量，它代表了上一个命令的最后一个字符串。如：你可能会这样：$mkdir mydir$mv mydir yourdir$cd yourdir可以改成：$mkdir mydir$mv !$ yourdir$cd !$</code></p></li><li><p><strong><code>sudo !!</code></strong><br>以root的身份执行上一条命令 。<br>场景举例：比如Ubuntu里用<code>apt-get</code>安装软件包的时候是需要root身份的，我们经常会忘记在<code>apt-get</code>前加<code>sudo</code>。每次不得不加上<code>sudo</code>再重新键入这行命令，这时可以很方便的用<code>sudo !!</code>完事。<br>（陈皓注：在shell下，有时候你会输入很长的命令，你可以使用!xxx来重复最近的一次命令，比如，你以前输入过，vi /where/the/file/is, 下次你可以使用 !vi 重得上次最近一次的vi命令。）</p></li><li><p><strong><code>cd –</code></strong><br>回到上一次的目录 。<br>场景举例：当前目录为<code>/home/a</code>，用<code>cd ../b</code>切换到<code>/home/b</code>。这时可以通过反复执行<code>cd –</code>命令在<code>/home/a</code>和<code>/home/b</code>之间来回方便的切换。<br>（陈皓注：cd ~ 是回到自己的Home目录，cd ~user，是进入某个用户的Home目录）</p></li><li><p><strong>‘ALT+.’ or ‘&lt;ESC&gt; .’</strong><br>热建alt+. 或 esc+. 可以把上次命令行的参数给重复出来。</p></li><li><p><strong><code>^old^new</code></strong><br>替换前一条命令里的部分字符串。<br>场景：<code>echo &quot;wanderful&quot;</code>，其实是想输出<code>echo &quot;wonderful&quot;</code>。只需要<code>^a^o</code>就行了，对很长的命令的错误拼写有很大的帮助。（陈皓注：也可以使用 <strong>!!:gs/old/new</strong>）</p></li><li><p><strong>du -s * | sort -n | tail</strong><br>列出当前目录里最大的10个文件。</p></li><li><p><strong>:w !sudo tee %</strong><br>在vi中保存一个只有root可以写的文件</p></li><li><p><strong>date -d@1234567890</strong><br>时间截转时间</p></li><li><div title="Click to select this command"><div>**&gt; file.txt**创建一个空文件，比touch短。</div></div></li><li><p><strong>mtr coolshell.cn</strong><br>mtr命令比traceroute要好。</p></li><li><p>在命令行前加空格，该命令不会进入history里。</p></li><li><p><strong>echo “ls -l” | at midnight</strong><br>在某个时间运行某个命令。</p></li><li><p><strong>curl -u user:pass -d status=”Tweeting from the shell” <a href="http://twitter.com/statuses/update.xml" target="_blank" rel="noopener">http://twitter.com/statuses/update.xml</a></strong><br>命令行的方式更新twitter。</p></li><li><p><strong>curl -u username –silent “<a href="https://mail.google.com/mail/feed/atom”" target="_blank" rel="noopener">https://mail.google.com/mail/feed/atom”</a> | perl -ne ‘print “\t” if /&lt;name&gt;/; print “$2\n” if /&lt;(title|name)&gt;(.*)&lt;/\1&gt;/;’</strong><br>检查你的gmail未读邮件</p></li><li><p><strong>ps aux | sort -nk +4 | tail</strong><br>列出头十个最耗内存的进程</p></li><li><p><strong><code>man ascii</code></strong><br>显示ascii码表。<br>场景：忘记ascii码表的时候还需要google么?尤其在天朝网络如此“顺畅”的情况下，就更麻烦在GWF多应用一次规则了，直接用本地的<code>man ascii</code>吧。</p></li><li><p><strong><code>ctrl-x e</code></strong><br>快速启动你的默认编辑器（由变量$EDITOR设置）。</p></li><li><p><strong><code>netstat –tlnp</code></strong><br>列出本机进程监听的端口号。（陈皓注：netstat -anop 可以显示侦听在这个端口号的进程）</p></li><li><p><strong><code>tail -f /path/to/file.log | sed &#39;/^Finished: SUCCESS$/ q&#39;</code></strong><br>当file.log里出现Finished: SUCCESS时候就退出tail，这个命令用于实时监控并过滤log是否出现了某条记录。</p></li><li><p><strong><code>ssh user@server bash &amp;lt; /path/to/local/script.sh</code></strong><br>在远程机器上运行一段脚本。这条命令最大的好处就是不用把脚本拷到远程机器上。</p></li><li><p><strong>ssh user@host cat /path/to/remotefile | diff /path/to/localfile –</strong><br>比较一个远程文件和一个本地文件</p></li><li><div title="Click to select this command"><div>**net rpc shutdown -I ipAddressOfWindowsPC -U username%password**远程关闭一台Windows的机器</div></div></li><li><p><strong><code>screen -d -m -S some_name ping my_router</code></strong><br>后台运行一段不终止的程序，并可以随时查看它的状态。<code>-d -m</code>参数启动“分离”模式，<code>-S</code>指定了一个session的标识。可以通过<code>-R</code>命令来重新“挂载”一个标识的session。更多细节请参考screen用法 <code>man screen</code>。</p></li><li><p><strong><code>wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com</code></strong><br>下载整个<a href="http://www.example.com网站。（注：别太过分，大部分网站都有防爬功能了：））" target="_blank" rel="noopener">www.example.com网站。（注：别太过分，大部分网站都有防爬功能了：））</a></p></li><li><p><strong><code>curl ifconfig.me</code></strong><br>当你的机器在内网的时候，可以通过这个命令查看外网的IP。</p></li><li><p><strong>convert input.png -gravity NorthWest -background transparent -extent 720×200  output.png</strong><br>改一下图片的大小尺寸</p></li><li><p><strong><code>lsof –i</code></strong><br>实时查看本机网络服务的活动状态。</p></li><li><p><strong>vim scp://username@host//path/to/somefile</strong><br>vim一个远程文件</p></li><li><p><strong><code>python -m SimpleHTTPServer</code></strong><br>一句话实现一个HTTP服务，把当前目录设为HTTP服务目录，可以通过<code>http://localhost:8000</code>访问 这也许是这个星球上最简单的HTTP服务器的实现了。</p></li><li><p><strong><code>history | awk &#39;{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a] &quot; &quot; CMD[a]/count*100 &quot;% &quot; a }&#39; | grep -v &quot;./&quot; | column -c3 -s &quot; &quot; -t | sort -nr | nl | head -n10</code></strong><br>(陈皓注：有点复杂了，history|awk ‘{print $2}’|awk ‘BEGIN {FS=”|”} {print $1}’|sort|uniq -c|sort -rn|head -10)<br>这行脚本能输出你最常用的十条命令，由此甚至可以洞察你是一个什么类型的程序员。</p></li><li><div title="Click to select this command"><div>**tr -c “[:digit:]” ” ” &lt; /dev/urandom | dd cbs=$COLUMNS conv=unblock | GREP_COLOR=”1;32″ grep –color “[^ ]”**想看看Matrix（装逼神器）的屏幕效果吗？（不是很像，但也很Cool!）</div></div>&nbsp;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量删除文件脚本</title>
      <link href="/2017/07/25/Batch-Delete-Shell-Script/"/>
      <url>/2017/07/25/Batch-Delete-Shell-Script/</url>
      
        <content type="html"><![CDATA[<p>自己的ECS上挂了一些备份数据库、日志、配置文件、/var/www目录等备份脚本，时间一长备份目录下的东西就多了。今天闲下来写个脚本自己批量删除下（别跟我说怎么不在备份脚本里加删除操作的，就是任性）</p><p><img src="/images/2017/04/bash.jpg" alt></p><a id="more"></a><p>一言不合上代码</p><pre class="lang:sh decode:true" title="bulkdeletescript">#!/bin/bashDIR="BACKDIR/"#删除文件所在目录，后接/PATTERN="^MySQL-[0-9]{4}(-[0-9]{2}){2}.sql$"#文件正则匹配模式DAYS=10#过期时间PREFIX="-"#日期的前缀SUFFIX=".sql"#后缀for FILE in $DIR*;do    NAME=${FILE#*$DIR}#去除路径得到文件名    if [[ $NAME =~ $PATTERN ]] &amp;&amp; test -f $FILE;then        TMP=${NAME#*$PREFIX}        DATE=${TMP%$SUFFIX*}#根据前后缀截取日期        #计算过期文件        if test $(( `date +%s`-`date +%s -d $DATE` )) -ge $[DAYS*24*60*60];then            echo "Delete expired file:$FILE"            rm $FILE#删除        fi    fidone</pre><p>例如：需要删除目录DIR为/home/root/backup/下，格式为MySQL-2017-07-21.sql的数据库备份文件。则需要正则为^MySQL-[0-9]{4}(-[0-9]{2}){2}.sql$（其实要写严谨的话老长了）。截取日期的前缀–即在日期前的一个或多个字符（），同理后缀也一样，如上代码中的。</p><p>只是练练手，查缺补漏。（菜鸟一枚，shell平时不怎么练手，一到写脚本各种查资料）下面是知识点总结：</p><p>1、${NAME#<em>PREFIX}的作用是截取从左开始PREFIX第一次出现后位置的字符串，如URL=”<a href="http://www.baidu.com&quot;;${URL#" target="_blank" rel="noopener">http://www.baidu.com&quot;;${URL#</a></em>//} 则是”<a href="http://www.baidu.com&quot;。所以若Docker-ghost-2017-07-24.log这样的截取日期的话，采用PREFIX为" target="_blank" rel="noopener">www.baidu.com&quot;。所以若Docker-ghost-2017-07-24.log这样的截取日期的话，采用PREFIX为</a> - 的话则会截取到错误的ghost-，此时可加长PREFIX为ghost-或t-</p><p>2、同上很相似，${NAME%SUFFIX<em>}的作用是截取从右开始SUFFIX第一次出现前位置的字符串，如URL=”<a href="http://www.baidu.com&quot;;${URL%//" target="_blank" rel="noopener">http://www.baidu.com&quot;;${URL%//</a></em>} 则是”http”。然后需要注意的也同上理推。</p><p>3、简单又实用一点 。for FILE in /home/root/* 或 <code>ls /home/root</code> ，这样可以遍历目录下的文件和目录，再通过 if test -f $FILE 判断是否为文件。</p><p>4、if [[   ]]其实也是一种判断方法 ，和if [  ]容易混淆。但是if [[  ]]中[[ 是shell的关键字，在bash、ksh等支持，且能够防止脚本中的许多逻辑错误。在其中可以使用 =~进行正则匹配，也可以使用在if [ ]中不能使用&amp;&amp;、||、&gt;=等。这里搬来一张图做对比：</p><p><img src="/images/2017/07/shell-test.gif" alt></p><p>5、时间差计算：date +%s获取当前时间戳，date +%s -d $DATE 获取给点日期时间戳。相减就是相差的时间，单位为秒。此外date 命令功能很强大，出了给出时间戳和给出格式化时间 date %Y-%m-%d 外，也可以获得上一或多天、上礼拜X、多天前、多个星期前、上个月等等。</p><p>6、另外不得不说的就是在shell中${ }、$[ ] 、$(( ))、 $( ) 的使用区别，[[    ]]、 [ ]、  ( )、((  ))、{ }的使用区别。有时候也是蛮让人容易混淆的。需要额外提的两个是 ${ }：用来应直接变量也包括环境变量等（当然我们上面的截取其实也是引用过程的处理）；$[ ]：可用来做基本的数值运算。</p><p>详尽的资料可以查阅这两篇博文：</p><p><a href="http://blog.chinaunix.net/uid-14351756-id-2820651.html" target="_blank" rel="noopener">shell中$(( )) 与 $( ) 还有${ }的区别</a></p><p>[shell中if条件字符串、数字比对，[[ ]]和[ ]区别](<a href="http://www.cnblogs.com/include/archive/2011/12/09/2307905.html" target="_blank" rel="noopener">http://www.cnblogs.com/include/archive/2011/12/09/2307905.html</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Java内存模型笔记</title>
      <link href="/2017/07/24/Understand-Memory-Model-Of-Java/"/>
      <url>/2017/07/24/Understand-Memory-Model-Of-Java/</url>
      
        <content type="html"><![CDATA[<p>在并发编程网上看到这个<a href="http://ifeve.com/java-memory-model-0/" target="_blank" rel="noopener">深入理解java内存模型系列文章</a>，文章一个系列图文并茂讲得都很不错，让我了解到了很多关于内存可见性、内存屏蔽指令一些知识。在此结合自己对《深入理解Java虚拟机》的一些理解对文章重点基础知识做个笔记。注：文章基于JSR-133内存模型</p><p><img src="/images/2017/07/JavaPic5.png" alt="Java内存模型"></p><a id="more"></a><p>如上图，Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。下面将循序渐进的介绍。</p><h3 id="1、Java内存模型抽象"><a href="#1、Java内存模型抽象" class="headerlink" title="1、Java内存模型抽象"></a>1、Java内存模型抽象</h3><p>内存模型抽象是Java虚拟机规范为实现让Java 程序在各个平台下都能达到一致性的内存访问效果而试图定义的。（<strong>此处的内存模型与Java 内存区域中相关的堆、栈不是一个层次的内存划分</strong>）</p><p>如上图，在Java中，所有实例域、静态域和数组元素存储在主内存（原文堆内存，勉强对应的话也没问题）中，主内存在线程之间共享（本文使用“共享变量”这个术语代指）。局部变量，方法定义参数（Java语言规范称之为formal method parameters）和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><h3 id="2、内存间交互操作、规则"><a href="#2、内存间交互操作、规则" class="headerlink" title="2、内存间交互操作、规则"></a>2、内存间交互操作、规则</h3><p>原文并没有介绍这一十分繁琐的一系列操作、规则，而是针对voliatile 、final 的一些特殊规定做了很详细的介绍，不过我觉得这有助于更好理解那些特殊规则。</p><p>Java内存模型定义了8种操作来完成主内存和工作内存（本地内存）之间 的具体的交互，虽然之后被弃用但内存模型没有改变。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double 、long类型某些操作在某些平台允许例外）</p><p>8种操作包括：lock（锁定M）、unlock（解锁M）、read（读取M-&gt;）、load（载入-&gt;W）、use（使用W）、assign（赋值W）、store（存储-&gt;M）、write（写入M）</p><p>//其中M代表作用于主内存，W代表作用于工作内存</p><p>此外还定义了一些基本规则（不包括volatile的特殊规定），如read必须load一起出现以完成从主内存读取数据到工作内存的操作。（规则不详细介绍，理解便可）</p><h3 id="3、三大特征中可见性"><a href="#3、三大特征中可见性" class="headerlink" title="3、三大特征中可见性"></a>3、三大特征中可见性</h3><p>Java 三个特征：原子性、可见性、有序性。通过上面提的基本操作、基本规则可大致的认为基本数据类型的访问读写具备原子性（更大规模的原子性保证有monitorenter、monitorexit–synchronized），所以直接跳过原子性来讲解可见性。</p><p><strong>可见性</strong>指的是当一个线程修改了共享变量的值，其他线程也能够立即得知修改。</p><p>Java内存模型是通过在变量修改后将新值通过回主内存，在变量读取前从主内存刷新变量值这种依赖主内存的作为传递媒介的方式来实现可见性的。（volatile的特殊规则保证新值能够立即通过到主内存，使每次使用前立即从主内存刷新。普通变量则不能保证）</p><p>原文中还提到了final的可见性问题，并详细地说明了<strong>this引用逃逸</strong>，在此就不多加篇幅论述。</p><p>此外还有一个关键字也能实现可见性，即synchronized 。同步块的可见性是由“对一个变量执行unlock操作前，必须先把此变量同步到主内存中（执行store、write操作）”这条规则获得的。</p><h3 id="4、重排序"><a href="#4、重排序" class="headerlink" title="4、重排序"></a>4、重排序</h3><p>重排序是理解下一种特征前必须要说明的。</p><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p><p><strong>数据依赖性</strong>：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分三种类型：写后读、写后写、读后写。（注：仅针对单线程和单处理器指令序列）</p><p><strong>重排序</strong>分三种类型：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，为了充分利用处理器内部的运算单元，处理器可能会对代码进行乱序执行（Out-Of-Order Execution）优化，再将乱序执行结果重组，保证该结果与顺序执行结果一致，但不保证各语句计算先后顺序与输入顺序一致。<br><img src="/images/2017/07/JavaPic6.png" alt></li></ol><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（注：仅针对单线程和单处理器指令序列）</p><h3 id="5、三大特征中有序性"><a href="#5、三大特征中有序性" class="headerlink" title="5、三大特征中有序性"></a>5、三大特征中有序性</h3><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的。</p><p>这句话的前半段可以根据上面重排序理解：单线程中，若操作间存在数据依赖性则不改变执行顺序，若不存在，则有可能进行重排序，但保证操作结果和顺序执行结果一致。故而看似都是有序的。</p><p>后半句话则指“指令重排序”现象和“工作内存和主内存同步延迟”现象。</p><p>Java语言提供volatile 和synchronized 两个关键字保证线程间操作的有序性。volatile关键字除立刻刷新主内存共享变量以外，本身包含了禁止重排序的语义。（原文中有详细的volatile语义描述）</p><h3 id="6、先行发生原则"><a href="#6、先行发生原则" class="headerlink" title="6、先行发生原则"></a>6、先行发生原则</h3><p>为什么将这一原则放在最后呢！因为此原则容易望文生义，如果在没有之前那些知识的基础上首先介绍的话，容易让人的意识里一直埋下“在前面的就是会先发生的、先执行的”误解。这会让你在接触之后的知识里很痛苦，难以理解的矛盾。（智商如我就是这样过来的 XD）</p><p>先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据。</p><p><strong>先行发生关系</strong>：如果说操作A先行发生于操作B。其实就是说在发生B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了主内存共享变量的值、发送信息、调用方法等。–《深入理解Java虚拟机》（没错，听起来好像很容易理解的样子）</p><p>原文中是通过“执行的结果”来代替上述的“产生的影响”。</p><p>那么可能会问一些问题</p><p><strong>（1）</strong>怎么判断两个操作存在先行发生关系？<strong>（2）</strong>先行发生关系能给这两个操作带来什么？</p><p>（1）Java内存模型通过限制编译器和处理器（内存屏蔽指令）的重排序，实现了无需任何同步器协助就已经存在的一些先行发生关系（只介绍大意）：</p><ul><li>程序次序规则：在一线程内，按控制流（<strong>不是代码</strong>）顺序，前面操作–&gt;后面操作</li><li>管程锁定规则：unlock操作–&gt;时间顺序后<strong>同一个锁</strong>的lock操作。</li><li>volatile规则：同上，略</li><li>线程启动规则：Thread对象start()–&gt;此线程的每一个动作</li><li>线程终止规则：线程中所有操作–&gt;此线程终止检测（Thead.join()、isAlive()）</li><li>线程中断规则：对线程interrupt()方法调用–&gt;中断检测代码</li><li>对象终结规则：一个对象的初始化完成–&gt;对象finalize()方法开始</li><li>传递性：若操作A–&gt;操作B，操作B–&gt;操作C，则操作A–&gt;操作C<br>注： –&gt; 表示先行发生于</li></ul><p>（2）正如我们定义<strong>先行发生关系</strong>，回头再看一遍定义，然后看下面的小例子</p><blockquote><p>i=1;   //这个操作在线程A中执行，代号a</p><p>j=1;   //这个操作在线程B中执行，代号b</p><p>i=2;   //这个操作在线程C中执行，代号c<br>若线程A中操作a先行发生于线程B的操作b，则可以确定在线程B执行后，变量j的值一定等于1。需要的依据：一是根据先行发生原则，a操作结果可以被b操作观察。二是线程A操作后C未执行（假设）</p></blockquote><p>在上面A、B先行发生关系基础上再假设线程C出现在A、B之间且操作c和操作b没有先行发生关系，那么j 的值是多少？答案是不确定。1,2都有可能，因为线程C对变量的影响可能被B观察到也可能不会。</p><p>此时线程B就存在读取过期数据的风险，不具备多线程安全性。</p><p><strong>先行发生关系可以保障操作之间的顺序性，和线程安全性。</strong></p><p>注：时间的先后顺序和先行发生原则之间基本没有关系（存在所谓的工作内存和和主内存的同步延迟），我们衡量并发安全问题的时候不要受到时间顺序的干扰，<strong>一切以原则为准</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Mybatis：Mapper注入Could not autowire 问题解决</title>
      <link href="/2017/07/18/Solve-Could-not-autowried-In-SpringBoot/"/>
      <url>/2017/07/18/Solve-Could-not-autowried-In-SpringBoot/</url>
      
        <content type="html"><![CDATA[<p>在使用Springboot+Mybatis开发项目时遇到如下的错误（提示Could not autowire）。虽然能够编译运行无误，但看着让人很是郁闷：<img src="/images/2017/07/Error-Show.png" alt></p><a id="more"></a><h3 id="1、确保项目目录无问题"><a href="#1、确保项目目录无问题" class="headerlink" title="1、确保项目目录无问题"></a>1、确保项目目录无问题</h3><p>即 springboot 入口函数所在类应该在这些Mapper、Service、Controller子包上级目录，例如com.demo.Mapper、com.demo.Service ，则入口类需在com.demo包下。</p><p><img src="/images/2017/07/Error-Detail2.png" alt></p><h3 id="2、确保配置文档及入口类没问题"><a href="#2、确保配置文档及入口类没问题" class="headerlink" title="2、确保配置文档及入口类没问题"></a>2、确保配置文档及入口类没问题</h3><p>2.1 springboot 配置文档 application.properties</p><p>其中的mybatis.mapperLocations 指定 Mapper.xml 路径</p><p><img src="/images/2017/07/Error-Detail4.png" alt></p><p>2.2 入口类</p><p>@SpringBootApplication 注释等价于以默认属性使用 @Configuration，@EnableAutoConfiguration 和 @ComponentScan，通常作为主类的注解</p><p>@MapperScan 指定扫描的mapper接口所在的包 （然而我加了还是无卵用）</p><p><img src="/images/2017/07/Error-Detail3.png" alt></p><p>3、如果上述无效，只能放大招了</p><p>3.1 添加 @Repository或@Component(Value=xxxMapper”)注释</p><p>直接手动注册，使其能被发现，这样就不会报错</p><p>3.2 使用@Autowired(required=false)</p><p>此处声明使其可以允许不被注入，这样也不会报错</p><p>————————————End——————————————</p><p>具体为什么找不到 Mapper 这几天学习过程再研究研究</p><hr><p>2017.07.20 注 ：网上搜到资料说“通过在mapper 接口上添加@Mapper 注释使其可被@Autowire 使用”。</p><p>实验发现虽然也不会报错，但是依然会提示 Could not autowire 错误。之后尝试过@Resource @Qualifier 两种注释，也还是会报错。</p><p>另外通过@Mapper 注释后，就不需要在入口类中添加@MapperScan 。</p><hr><p>另外推荐个好东西 <a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok </a>，适合所有Java 开发，很大程度简化Java 代码</p><p>[embed]<a href="https://projectlombok.org/videos/lombok.ogv[/embed]" target="_blank" rel="noopener">https://projectlombok.org/videos/lombok.ogv[/embed]</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客维护笔记</title>
      <link href="/2017/06/26/Blog-Maintain-Notes/"/>
      <url>/2017/06/26/Blog-Maintain-Notes/</url>
      
        <content type="html"><![CDATA[<p>自端午放假后，因为发生的一些事情已有两周没管管博客了，今天上来一看发现各种问题。先是WordPress不知怎么抽风，导致登录循环跳转（以前改好过现在又犯了）；然后看Apache 日中发现一对报错，MySQL莫名的进入只读模式；登上博客又看到一堆的垃圾评论，删除都费了一会功夫。哎，杂草丛生喽！<a id="more"></a></p><h3 id="一、关于WordPress登录循环跳转"><a href="#一、关于WordPress登录循环跳转" class="headerlink" title="一、关于WordPress登录循环跳转"></a>一、关于WordPress登录循环跳转</h3><p>从资料来看，这是WordPress的老毛病了。查其原因，却没有一篇详细的说明文章，不过看到大多数文章均是归咎于WordPress中一些插件的更新，不过我觉得也有可能是下文中提到的数据库问题。（原谅我不懂PHP）</p><p>症状就是在登录界面输入正确的帐号密码后，依然是跳转至登录界面，如此循环使得用户进不了博客的后台界面。需要说明的是笔者WordPress版本是4.7，而之前还是4.6版本的时候这种症状也出现过。</p><p>解决方法：网上随便百度能发现一大堆，然而方法都是大同小异。要么就是修改wp-include目录下的pluggable.php中关于cookie设置的代码；要么是修改根目录下的wp-config.php；也有说是修改.htaccess文件的。但是笔者上一次出这个问题确实借助于第一个方法，通过修改pluggable.php文件解决了这一问题。然而这次不知怎么却没作用，试过各种方法没效果。无奈之下用上个月备份的整个博客的Web目录替换了现有的目录，结果自然是没问题了。</p><p>经过这么一出倒是庆幸自己有时常备份的好习惯。不过网上也有建议说用Windows Live Writer的，看起来不错之后尝试尝试。</p><h3 id="二、MySQL进入只读模式"><a href="#二、MySQL进入只读模式" class="headerlink" title="二、MySQL进入只读模式"></a>二、MySQL进入只读模式</h3><p>这个问题还是在Apache的错误日志中查到的。这个问题也可能是造成WordPress登录循环的原因。</p><p>由于未开启general_log所以没办法追踪开启read_only的原因。genenral log用来记录数据库运行期间所有成功和未成功的操作。可以修改配置文档，而在我使用MySQL 5.7版本就可以通过修改general_log 和general_log_file这两个变量值，在运行状态下开启日志。不过官方文档里提醒到，说这类日志是一个性能杀手。</p><p>2017.07.18 更新</p><p>目前已确定WordPress 登录页面循环跳转问题所在：</p><p>原因-&gt;mysql 处于 read_only 状态导致 登录时操作无法更新数据，造成循环跳转问题。（具体是自己在实验主从复制的时候，设置了从库自启动 read_only ）</p><hr><h3 id="三、Apache-为正确配置参数导致进程过多"><a href="#三、Apache-为正确配置参数导致进程过多" class="headerlink" title="三、Apache 为正确配置参数导致进程过多"></a>三、Apache 为正确配置参数导致进程过多</h3><p>Apache2.4版本下默认开启的多处理模块mpm 是prefork，而其中的一些配置参数的默认值可能不适合像我这样配置低的服务器。（顺便吐槽下Apache官方文档那让人无语的某些滞后）</p><p>prefork官方文档 <a href="http://httpd.apache.org/docs/2.4/mod/prefork.html" target="_blank" rel="noopener">http://httpd.apache.org/docs/2.4/mod/prefork.html</a></p><p>prefock 中文翻译文档 <a href="http://www.t086.com/code/apache2.2/mod/prefork.html" target="_blank" rel="noopener">http://www.t086.com/code/apache2.2/mod/prefork.html</a></p><p>其中的如下两个参数需要调整以适用于低配置服务器，当然你若有兴趣也可以按照文档修改成适合的配置。本人Apache 2.4 直接在apache.conf 修改（没什么httpd.conf）</p><blockquote><p>&lt;IfModule mpm_prefork_module&gt;</p><p>StartService   5          初始化子进程数</p><p>MaxClients      20       最大连接数</p><p>MaxSpareServers   6 空闲子进程最大数 默认值10</p><p>MinSpareServers    3 空闲子进程最小数 默认值5</p><p>MaxRequestsPerChild 500 子进程存在期间总共处理的最大请求数默认0为子进程不自动注销</p><p>&lt;/IfModule&gt;</p><p>&nbsp;<br>最后对于垃圾评论，正考虑尝试一些评论插件，也正在找好看的分享插件。欢迎分享 XD</p></blockquote><p>最近在 Leetcode上刷一些题目，接下来也会写一些关于编程算法的博文。推荐喜欢编程或者即将面对招聘的童鞋们也试试。</p><p>颓废了两周，得振作起来了 ^_^</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis接触过程的两个小坑</title>
      <link href="/2017/05/18/redis-notes/"/>
      <url>/2017/05/18/redis-notes/</url>
      
        <content type="html"><![CDATA[<p>最为高效的键值对存储数据库，redis应用广泛，各大主流的编程语言对其的支持都很好。今天来说说，接触过程的小坑。</p><p><img src="/images/2017/05/redis.jpg" alt></p><p>&nbsp;</p><a id="more"></a><h2 id="1、响应格式均为byte"><a href="#1、响应格式均为byte" class="headerlink" title="1、响应格式均为byte"></a>1、响应格式均为byte</h2><p>在使用Python3进行redis数据库操作时，发现存进redis的数据，取出时不管是key 、各种value 格式均是byte 。这很让人难受，不过查看官方文档后，发现其中的redis 模块中的Redis()（包括StrictRedis()）方法，其中的<code>decode_responses</code> 参数默认为False 。只须在生成类的方法参数中将其设置为True即可。</p><pre class="lang:python decode:true " title="redis_setting">redis.StrictRedis(host=db_host, port=db_port, password=db_password, decode_responses=True)</pre><h2 id="2、关于Redis、StrictRedis两个类"><a href="#2、关于Redis、StrictRedis两个类" class="headerlink" title="2、关于Redis、StrictRedis两个类"></a>2、关于Redis、StrictRedis两个类</h2><p>两者都是用于实现Redis命令的，只不过官方文档中说明Redis类是向后兼容旧版本的。听起来没什么大不了的差别好像。。</p><p>不过其实两者的差别还是有的，使用时官方推荐StrictRedis。</p><p>差别有如下：</p><ul><li>LREM：参数 ‘num’ 和 ‘value’ 的顺序交换了一下，cli是 lrem queueName 0 ‘string’ 。  这里的0时所有的意思。 但是Redis这个类，把控制和string调换了。</li><li>ZADD：实现时 score 和 value 的顺序不小心弄反了，后来有人用了，就这样了</li><li>SETEX: time 和 value 的顺序反了</li></ul><h2 id="3、这个也不算坑，一个小记"><a href="#3、这个也不算坑，一个小记" class="headerlink" title="3、这个也不算坑，一个小记"></a>3、这个也不算坑，一个小记</h2><p><img src="/images/2017/05/Lua_Error.png" alt></p><p>编译安装Lua环境时，碰到一个报错。面向搜索引擎解决问题后找到出错点</p><pre class="lang:sh decode:true" title="readline">sudo apt-get install libreadline-dev</pre><p>———————————-Fighting———————————</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C词法分析器的Python简单实现</title>
      <link href="/2017/05/18/C-Lexical-Analyzer-ImplementBy-Python/"/>
      <url>/2017/05/18/C-Lexical-Analyzer-ImplementBy-Python/</url>
      
        <content type="html"><![CDATA[<p>在学习编译原理的课程设计中，需要设计一个词法分许程序。于是尝试用Python来简单实现C语言词法分析器。其中其实并没有什么具体需要克服的难处，只要将部分的词法分析DFA设计好，实现起来思路便更清晰。</p><p><img src="/images/2017/05/DFA.jpg" alt></p><p>&nbsp;</p><a id="more"></a><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>C语言中我们需要提取出关键字，标识符，分隔符，运算符，不同数据类型的常量。其中标识符、标识符及分隔符的提取更简单，而运算符因为各运算符组合具有不同意义需详细分解，例如：&gt;&gt;、&gt;=、&gt;&gt;=，常量更是最让人头疼的，例如：整型 八进制 00123u 十六进制 0x23fflu 、浮点型 123.434f 指数型 0123e-002。</p><p>词法分析器还需要能显示出行数、检测出出错位置，并跳过错误继续分析。另外我们还需要对单行注释、多行注释进行跳过，以及跳过暂时不能处理的宏定义、预编译。</p><h2 id="2、部分有穷状态自动机实现"><a href="#2、部分有穷状态自动机实现" class="headerlink" title="2、部分有穷状态自动机实现"></a>2、部分有穷状态自动机实现</h2><h3 id="2-1、关键字及标识符"><a href="#2-1、关键字及标识符" class="headerlink" title="2.1、关键字及标识符"></a>2.1、关键字及标识符</h3><pre class="lang:python decode:true" title="Analyzer_keyword">if prog[flag].isalpha() or prog[flag]==r'_':#_字母开头 标识符和关键字            tmp=flag            while prog[flag].isalnum() or prog[flag]==r'_':flag+=1            #走到符合条件的最右边            fragment=str(reduce(lambda x,y:x+y,prog[tmp:flag]))            if fragment in keyword:#判断为关键字，keyword为关键字list                print("&lt; "+fragment+",- &gt;",end=' ')            else:#判断为标识符                print("&lt; IDENTIFY,"+fragment+" &gt;",end=' ')</pre><h3 id="2-2、数字（最复杂的一个）"><a href="#2-2、数字（最复杂的一个）" class="headerlink" title="2.2、数字（最复杂的一个）"></a>2.2、数字（最复杂的一个）</h3><pre class="lang:python decode:true" title="Analyzer_Num">#prog 待分析串 flag标记当前位置 line当前行 befspace上一个换行位置#skip(prog,flag) 出错后跳过无效字符elif prog[flag].isdigit():#判断数字常量    if prog[flag] == '0':#当开始字符为0        if prog[flag+1].lower()=='x':#0x开头为十六进制            flag+=2            tmp=flag            while prog[flag].isdigit() or \                    (prog[flag].lower()&gt;='a' and prog[flag].lower()&lt;='f'): #判断十六进制                flag+=1            numch=str(reduce(lambda x,y:x+y,prog[tmp:flag]))#拼接十六进制数字            num = str(int(numch, 16))#拼接为十进制数字            if prog[flag].lower()=='u' :#判断是否有符号、长整，当前flag指向十六进制后一位                if prog[flag+1].lower()=='l':#0x23ul                    if prog[flag + 2].isalnum():#0x23uls报错，并跳过                        print("&lt;ERROR,INT_UN_LONG_DEFINE,LINE "+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                        flag += 3                        flag = skip(prog, flag)                    else:                        print("&lt; INT_UN_LONG,"+num+" &gt;",end=' ')                        flag+=2                elif prog[flag+1].isalnum():#0x23u2出错                    print("&lt;ERROR,INT_UN_DEFINE,LINE "+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                    flag += 1                    flag=skip(prog,flag)                else:                    print("&lt; INT_UN,"+num+" &gt;",end=' ')#                    flag+=1            elif prog[flag].lower()=='l':#同上                if prog[flag+1].lower()=='u':                    if prog[flag + 2].isalnum():                        print("&lt; ERROR,INT_UN_LONG_DEFINE ,LINE "+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                        flag += 3                        flag = skip(prog, flag)                    else:                        print("&lt; INT_UN_LONG,"+num+" &gt;",end=' ')                        flag+=2                elif prog[flag+1].isalnum():                    print("&lt; ERROR,INT_LONG_DEFINE,LINE "+str(line)+str(flag-befspace)+" &gt;", end=' ')                    flag += 1                    flag = skip(prog, flag)                else:                    print("&lt; INT_LONG,"+num+" &gt;",end=' ')                    flag+=1            elif prog[flag].isalpha():#十六进制后接字符则报错                print("&lt; ERROR,INT_DEFINE,LINE "+str(line)+" "+str(flag-befspace)+" &gt;",end=' ')                flag+=1                flag = skip(prog, flag)            else:                print("&lt; INT," + num + " &gt;", end=' ')            pass        elif prog[flag+1]=='.':#0.开头为浮点数            tmp=flag            flag+=2            haspro=False#是否有+、-、e            hasneg=False            haseE=False            while prog[flag].isdigit() or prog[flag].lower()=='e' or prog[flag]=='-' or prog[flag]=='+':                if (prog[flag]=='+' or prog[flag]=='-') and not haseE:break#需满足一些条件                elif (prog[flag] == '+' or prog[flag] == '-') and (haspro or hasneg):break                elif (prog[flag]=='+' or prog[flag]=='-') and haseE:                    if prog[flag-1].lower()!='e':break                    else:                        if prog[flag]=='+':haspro=True                        else:hasneg=True                elif prog[flag].lower()=='e' and haseE:break                elif prog[flag]=='+':haspro=True                elif prog[flag] =='-':hasneg = True                elif prog[flag].lower()=='e':haseE=True                flag+=1            befpron=str(reduce(lambda x,y:x+y,prog[tmp:flag]))#拼接            findpro=befpron.find('+')            findneg=befpron.find('-')            findeE=befpron.lower().find('e')            IsFLOAT=False            IsERROR=False            theskip=flag            if prog[flag].lower()=='f':#0.23e+002f浮点数声明判断                if prog[flag+1].isalnum():#0.23e+002f3报错                    print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag+1- befspace) + " &gt;",                          end=' ')                    IsERROR=True                    flag = skip(prog, flag+2)                else:                    IsFLOAT=True                    theskip=flag+1            elif prog[flag].isalnum():#同上                print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag-befspace) + " &gt;",                      end=' ')                IsERROR = True                flag = skip(prog, flag+1)            if not IsERROR:                if (hasneg or haspro) and haseE:#有符号指数型                    pos=(findpro if haspro&gt;hasneg else findneg)                    if pos!=flag-tmp-1:#处理e+23                        suffix=int(reduce(lambda x,y:str(int(x)*10+int(y)),befpron[pos+1:]))                        suffix=suffix if haspro else -suffix                        num=str(float(str(reduce(lambda x,y:x+y,befpron[0:findeE])))*10**suffix)                        if IsFLOAT:                            print("&lt; FLOAT," + num + " &gt;", end=' ')                            flag=theskip                        else:print("&lt; DOUBLE," + num + " &gt;", end=' ')                    else:#0.12e+报错                        print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                              end=' ')                        flag = skip(prog, flag)                elif haseE and not (haspro or hasneg):#无符号指数e                    if findeE!=flag-tmp-1:                        suffix = int(str(reduce(lambda x, y: x + y, befpron[findeE+1:])))                        num = str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE])))                                  * 10 ** suffix)                        if IsFLOAT:                            print("&lt; FLOAT," + num + " &gt;", end=' ')                            flag=theskip                        else:print("&lt; DOUBLE," + num + " &gt;", end=' ')                    else:                        print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                              end=' ')                        flag = skip(prog, flag)                    pass                else:#单纯的浮点数0.23                    num=str(float(befpron))                    if IsFLOAT:                        print("&lt; FLOAT," + num + " &gt;", end=' ')                        flag = theskip                    else:                        print("&lt; DOUBLE," + num + " &gt;", end=' ')        elif prog[flag+1].isdigit():#浮点数和八进制均有可能            tmp=flag            flag+=2            haspoint=False#是否有小数点、符号、指数            haseE=False            haspro=False            hasneg=False            while prog[flag].isdigit() or prog[flag].lower()=='e' or prog[flag]=='-' or prog[flag]=='+' or prog[flag]=='.':                if (prog[flag]=='+' or prog[flag]=='-') and not haseE:break#需满足的一些条件                elif (prog[flag] == '+' or prog[flag] == '-') and (haspro or hasneg):                    break                elif (prog[flag]=='+' or prog[flag]=='-') and haseE:                    if prog[flag-1].lower()!='e':break                    else:                        if prog[flag]=='+':haspro=True                        else:hasneg=True                elif (haseE or haspoint) and prog[flag]=='.':break                elif prog[flag].lower() == 'e' and haseE:break                elif prog[flag]=='.' and haspoint:break                elif prog[flag] == '+' :haspro = True                elif prog[flag] == '-':hasneg = True                elif prog[flag].lower() == 'e' :haseE = True                elif prog[flag]=='.' :haspoint=True                flag+=1            befpron = str(reduce(lambda x, y: x + y, prog[tmp:flag]))#拼接            findpro = befpron.find('+')            findneg = befpron.find('-')            findeE = befpron.lower().find('e')            findpoint = befpron.find('.')            IsFLOAT = False            IsERROR = False            theskip = flag            if (haspoint or haseE) and prog[flag].lower() == 'f':#同上                if prog[flag + 1].isalnum():                    print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag + 1 - befspace) + " &gt;",                          end=' ')                    IsERROR = True                    flag = skip(prog, flag + 2)                else:                    IsFLOAT = True                    theskip = flag + 1            elif prog[flag].isalnum():                print("&lt; ERROR,NUM_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                      end=' ')                IsERROR = True                flag = skip(prog, flag + 1)            if not IsERROR:                if haseE and (haspro or hasneg):                    pos = (findpro if haspro &gt; hasneg else findneg)                    if pos != flag - tmp - 1:  # 处理e+23                        suffix = int(reduce(lambda x, y: str(int(x) * 10 + int(y)), befpron[pos + 1:]))                        suffix = suffix if haspro else -suffix                        num = str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE]))) * 10 ** suffix)                        if IsFLOAT:                            print("&lt; FLOAT," + num + " &gt;", end=' ')                            flag=theskip                        else:print("&lt; DOUBLE," + num + " &gt;", end=' ')                    else:  # 0.12e+报错                        print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                              end=' ')                        flag = skip(prog, flag)                elif haseE :                    if haseE!=flag-tmp-1:                        suffix = int(str(reduce(lambda x, y: x + y, befpron[findeE + 1:])))                        num=str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE])))*10**suffix)                        if IsFLOAT:                            print("&lt; FLOAT," + num + " &gt;", end=' ')                            flag=theskip                        else:print("&lt; DOUBLE," + num + " &gt;", end=' ')                    else:                        print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                              end=' ')                        flag = skip(prog, flag)                elif haspoint:                    if IsFLOAT:                        print("&lt; FLOAT," + str(float(befpron)) + " &gt;", end=' ')                        flag = theskip                    else:                        print("&lt; DOUBLE," + str(float(befpron)) + " &gt;", end=' ')                else:                    isoctal=True                    for char in befpron:                        if int(char)&gt;=8:isoctal=False                    if not isoctal:                        print("&lt; ERROR,OCTAL_OUTOFRANG,LINE"+str(line)+" "+str(flag-befspace)+" &gt;",end=' ')                    else:                        print("&lt; INT,"+str(int(befpron,8))+"&gt;" ,end=' ')        elif prog[flag+1] in operetor or prog[flag+1] in delimiter:#简单的0            print("&lt; INT,0 &gt;",end=' ')            flag+=1        else:#其他字母或符号抛异常            flag+=2            print("&lt; ERROR,NUM_DEFINE,LINE"+str(line)+" "+str(flag-befspace)+" &gt;",end=' ')    else:#非0开头可为浮点数或整数        haspoint=False#同上        haseE=False        haspro = False        hasneg = False        tmp=flag        while prog[flag].isdigit() or prog[flag].lower() == 'e' or prog[flag] == '-' or prog[flag] == '+' or \                        prog[flag] == '.':            if (prog[flag] == '+' or prog[flag] == '-') and not haseE:break            elif (prog[flag] == '+' or prog[flag] == '-') and (haspro or hasneg):break            elif (prog[flag] == '+' or prog[flag] == '-') and haseE:                if prog[flag - 1].lower() != 'e':                    break                else:                    if prog[flag] == '+':                        haspro = True                    else:                        hasneg = True            elif (haseE or haspoint) and prog[flag] == '.':break            elif prog[flag].lower() == 'e' and haseE:break            elif prog[flag] == '.' and haspoint:break            elif prog[flag] == '+':                haspro = True            elif prog[flag] == '-':                hasneg = True            elif prog[flag].lower() == 'e':                haseE = True            elif prog[flag] == '.':                haspoint = True            flag += 1        befpron = str(reduce(lambda x, y: x + y, prog[tmp:flag]))        findpro = befpron.find('+')        findneg = befpron.find('-')        findeE = befpron.lower().find('e')        findpoint = befpron.find('.')        IsFLOAT = False        IsERROR = False        theskip = flag        if (haspoint or haseE) and prog[flag].lower() == 'f':            if prog[flag + 1].isalnum():                print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag + 1 - befspace) + " &gt;",                      end=' ')                IsERROR = True                flag = skip(prog, flag + 2)            else:                IsFLOAT = True                theskip = flag + 1        elif prog[flag].isalnum():            print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                  end=' ')            IsERROR = True            flag = skip(prog, flag + 1)        if not IsERROR:            if haseE and (haspro or hasneg):#有符号指数型                pos = (findpro if haspro &gt; hasneg else findneg)                if pos != flag - tmp - 1:  # 处理e+23                    suffix = int(reduce(lambda x, y: str(int(x) * 10 + int(y)), befpron[pos + 1:]))                    suffix = suffix if haspro else -suffix                    num = str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE]))) * 10 ** suffix)                    if IsFLOAT:                        print("&lt; FLOAT," + num + " &gt;", end=' ')                        flag = theskip                    else:                        print("&lt; DOUBLE," + num + " &gt;", end=' ')                else:  # 0.12e+报错                    print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                          end=' ')                    flag = skip(prog, flag)            elif haseE :#指数型浮点数                if haseE != flag - tmp - 1:                    suffix = int(str(reduce(lambda x, y: x + y, befpron[findeE + 1:])))                    num = str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE]))) * 10 ** suffix)                    if IsFLOAT:                        print("&lt; FLOAT," + num + " &gt;", end=' ')                        flag = theskip                    else:                        print("&lt; DOUBLE," + num + " &gt;", end=' ')                else:                    print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                          end=' ')                    flag = skip(prog, flag)            elif haspoint:#小数点浮点数                if IsFLOAT:                    print("&lt; FLOAT," + str(float(befpron)) + " &gt;", end=' ')                    flag = theskip                else:                    print("&lt; DOUBLE," + str(float(befpron)) + " &gt;", end=' ')            else:#纯整数                num = str(int(befpron))                if prog[flag].lower() == 'u':                    if prog[flag + 1].lower() == 'l':                        if prog[flag + 2].isalnum():                            print("&lt;ERROR,INT_UN_LONG_DEFINE,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                            flag += 3                            flag = skip(prog, flag)                        else:                            print("&lt;INT_UN_LONG," + num + "&gt;", end=' ')                            flag += 2                    elif prog[flag + 1].isalnum():                        print("&lt; ERROR,INT_LONG_DEFINE ,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                        flag += 1                        flag = skip(prog, flag)                    else:                        print("&lt;INT_UN," + num + "&gt;", end=' ')                elif prog[flag].lower() == 'l':                    if prog[flag + 1].lower() == 'u':                        if prog[flag + 2].isalnum():                            print("&lt; ERROR,INT_UN_LONG_DEFINE ,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                            flag += 3                            flag = skip(prog, flag)                        else:                            print("&lt; INT_UN_LONG," + num + "&gt;", end=' ')                            flag += 2                    elif prog[flag + 1].isalnum():                        print("&lt; ERROR,INT_LONG_DEFINE ,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                        flag += 1                        flag = skip(prog, flag)                    else:                        print("&lt; INT_LONG," + num + " &gt;", end=' ')                elif prog[flag].isalpha():                    print("&lt; ERROR,INT_DEFINE,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                    flag = skip(prog, flag)                else:            print("&lt; INT," + num + " &gt;", end=' ')</pre><p>边上也有同学想用Python 的正则表达式，直接将符合前言中的那几种分别表示出来，进行直接匹配。但是其中还是有些复杂的结构无法表示，并且容易出误判，而无法显示出错位置。</p><p>不得不说其实不少代码冗余，本文全部的代码实现，欢迎拍砖 <a href="https://github.com/single-wolf/show-me-the-code/blob/master/analyzer.py" target="_blank" rel="noopener">https://github.com/single-wolf/show-me-the-code/blob/master/analyzer.py</a></p><p>最近也喜欢上Python ，分享个练手的有趣东西 <a href="https://github.com/Show-Me-the-Code/show-me-the-code" target="_blank" rel="noopener">https://github.com/Show-Me-the-Code/show-me-the-code</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 加锁处理</title>
      <link href="/2017/05/05/Lock-In-MySQL/"/>
      <url>/2017/05/05/Lock-In-MySQL/</url>
      
        <content type="html"><![CDATA[<p>分享一篇详细、较全面的MySQL InnoDB加锁介绍，虽然年代略旧不过其中基本锁的机制还是没变的。</p><p>MySQL/InnoDB的加锁分析，一直是一个比较困难的话题。本文，准备就MySQL/InnoDB的加锁问题，展开较为深入的分析与讨论，主要是介绍一种思路，运用此思路，拿到任何一条SQL语句，都能完整的分析出这条语句会加什么锁？会有什么样的使用风险？甚至是分析线上的一个死锁场景，了解死锁产生的原因。</p><p><strong>注：</strong>MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</p><a id="more"></a><blockquote><p>全文转载自 <a href="http://hedengcheng.com/" target="_blank" rel="noopener">何登成的技术博客</a> <a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></p><p>详尽的各语句加锁情况 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html" target="_blank" rel="noopener">Locks Set by Different SQL Statements in InnoDB</a></p></blockquote><ul><li><strong>MVCC**</strong>：Snapshot Read vs Current Read**<br>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (<a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">Multi-Version Concurrency Control</a>) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</li></ul><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><p>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p><ul><li><p><strong>快照读：</strong>简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)</p><ul><li>select * from table where ?;</li></ul></li><li><p><strong>当前读：</strong>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p><ul><li>select * from table where ? lock in share mode;</li><li>select * from table where ? for update;</li><li>insert into table values (…);</li><li>update table set ? where ?;</li><li>delete from table where ?;<br>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</li></ul></li></ul><p>为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：</p><p><img src="/images/2017/05/MySQL_Lock1.png" alt></p><p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p><p><strong>注</strong>：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕。</p><p>&nbsp;</p><ul><li><strong>Cluster Index**</strong>：聚簇索引**<br>InnoDB存储引擎的数据组织方式，是聚簇索引表：完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列。关于聚簇索引表的组织方式，可以参考MySQL的官方文档：<a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-index-types.html" target="_blank" rel="noopener">Clustered and Secondary Indexes</a> 。本文假设读者对这个，已经有了一定的认识，就不再做具体的介绍。接下来的部分，主键索引/聚簇索引 两个名称，会有一些混用，望读者知晓。</li></ul><p>&nbsp;</p><ul><li><strong>2PL**</strong>：Two-Phase Locking**<br>传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：<a href="http://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener">Two-Phase Locking</a>。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。</li></ul><p><img src="/images/2017/05/MySQL_Lock2.png" alt></p><p>从上图可以看出，2PL就是将加锁/解锁分为两个完全不相交的阶段。加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。</p><p>&nbsp;</p><ul><li><strong>Isolation Level</strong><br>隔离级别：<a href="http://en.wikipedia.org/wiki/Isolation_%28database_systems%29" target="_blank" rel="noopener">Isolation Level</a>，也是RDBMS的一个关键特性。相信对数据库有所了解的朋友，对于4种隔离级别：Read Uncommited，Read Committed，Repeatable Read，Serializable，都有了深入的认识。本文不打算讨论数据库理论中，是如何定义这4种隔离级别的含义的，而是跟大家介绍一下MySQL/InnoDB是如何定义这4种隔离级别的。</li></ul><p>MySQL/InnoDB定义的4种隔离级别：</p><ul><li><p><strong>Read Uncommited</strong><br>可以读取未提交记录。此隔离级别，不会使用，忽略。</p></li><li><p><strong>Read Committed (RC)</strong><br>快照读忽略，本文不考虑。</p></li></ul><p>针对当前读，<strong>RC隔离级别保证对读取到的记录加锁 (记录锁)</strong>，存在幻读现象。</p><ul><li><strong>Repeatable Read (RR)</strong><br>快照读忽略，本文不考虑。</li></ul><p>针对当前读，<strong>RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)</strong>，不存在幻读现象。</p><ul><li><strong>Serializable</strong><br>从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。</li></ul><p>Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。</p><p>&nbsp;</p><ul><li><strong>一条简单SQL的加锁实现分析</strong><br>在介绍完一些背景知识之后，本文接下来将选择几个有代表性的例子，来详细分析MySQL的加锁处理。当然，还是从最简单的例子说起。经常有朋友发给我一个SQL，然后问我，这个SQL加什么锁？就如同下面两条简单的SQL，他们加什么锁？</li></ul><p>&nbsp;</p><ul><li><strong>SQL1**</strong>：**select * from t1 where id = 10;</li><li><strong>SQL2**</strong>：**delete from t1 where id = 10;<br>&nbsp;</li></ul><p>针对这个问题，该怎么回答？我能想象到的一个答案是：</p><ul><li><p><strong>SQL1**</strong>：**不加锁。因为MySQL是使用多版本并发控制的，读不加锁。</p></li><li><p><strong>SQL2**</strong>：**对id = 10的记录加写锁 (走主键索引)。<br>这个答案对吗？说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。如果让我来回答这个问题，我必须还要知道以下的一些前提，前提不同，我能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？</p></li><li><p><strong>前提一：</strong>id列是不是主键？</p></li><li><p><strong>前提二：</strong>当前系统的隔离级别是什么？</p></li><li><p><strong>前提三：</strong>id列如果不是主键，那么id列上有索引吗？</p></li><li><p><strong>前提四：</strong>id列上如果有二级索引，那么这个索引是唯一索引吗？</p></li><li><p><strong>前提五：</strong>两个SQL的执行计划是什么？索引扫描？全表扫描？<br>&nbsp;</p></li></ul><p>没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？</p><p>&nbsp;</p><p><strong>注：</strong>下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。</p><p>&nbsp;</p><ul><li><strong>组合一**</strong>：**id列是主键，RC隔离级别</li><li><strong>组合二**</strong>：**id列是二级唯一索引，RC隔离级别</li><li><strong>组合三**</strong>：**id列是二级非唯一索引，RC隔离级别</li><li><strong>组合四**</strong>：**id列上没有索引，RC隔离级别</li><li><strong>组合五**</strong>：**id列是主键，RR隔离级别</li><li><strong>组合六**</strong>：**id列是二级唯一索引，RR隔离级别</li><li><strong>组合七**</strong>：**id列是二级非唯一索引，RR隔离级别</li><li><strong>组合八**</strong>：**id列上没有索引，RR隔离级别</li><li><strong>组合九**</strong>：**Serializable隔离级别<br>&nbsp;</li></ul><p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。</p><p>&nbsp;</p><p>注：在前面八种组合下，也就是RC，RR隔离级别下，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了，主要讨论SQL2：delete操作的加锁。</p><p>&nbsp;</p><p><strong>组合一：id主键+RC</strong></p><p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：</p><p><img src="/images/2017/05/MySQL_Lock3.png" alt></p><p><strong>结论：</strong>id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</p><p>&nbsp;</p><p><strong>组合二：id唯一索引+RC</strong></p><p>这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：</p><p><img src="/images/2017/05/MySQL_Lock4.png" alt></p><p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><p>&nbsp;</p><p><strong>结论</strong>：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</p><p>&nbsp;</p><p><strong>组合三：id非唯一索引+RC</strong></p><p>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：</p><p><img src="/images/2017/05/MySQL_Lock5.png" alt></p><p>根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p><p>&nbsp;</p><p><strong>结论</strong>：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p><p>&nbsp;</p><p><strong>组合四：id无索引+RC</strong></p><p>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：</p><p><img src="/images/2017/05/MySQL_Lock6.png" alt></p><p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p><p>&nbsp;</p><p>有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。</p><p>&nbsp;</p><p>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p><p>&nbsp;</p><p><strong>结论：</strong>若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</p><p>&nbsp;</p><p><strong>组合五：id主键+RR</strong></p><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。</p><p>&nbsp;</p><p>组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%B8%80%EF%BC%9Aid%E4%B8%BB%E9%94%AE+RC" target="_blank" rel="noopener">id主键，Read Committed</a>]一致。</p><p>&nbsp;</p><p><strong>组合六：id唯一索引+RR</strong></p><p>与组合五类似，组合六的加锁，与组合二：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%BA%8C%EF%BC%9Aid%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id唯一索引，Read Committed</a>]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p><p>&nbsp;</p><p><strong>组合七：id非唯一索引+RR</strong></p><p>还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，如何防止幻读呢？问题的答案，就在组合七中揭晓。</p><p>&nbsp;</p><p>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p><p><img src="/images/2017/05/MySQL_Lock7.png" alt></p><p>此图，相对于组合三：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%B8%89%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id列上非唯一锁，Read Committed</a>]看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？</p><p>&nbsp;</p><p>其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p><p>&nbsp;</p><p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p><p>&nbsp;</p><p>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p><p>&nbsp;</p><p>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p><p>&nbsp;</p><p>有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？</p><p>&nbsp;</p><p>首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。</p><p>&nbsp;</p><p><strong>结论：</strong>Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p><p>&nbsp;</p><p><strong>组合八：id无索引+RR</strong></p><p>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p><p><img src="/images/2017/05/MySQL_Lock8.png" alt></p><p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p><p>&nbsp;</p><p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p><p>&nbsp;</p><p>当然，跟组合四：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E5%9B%9B%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id无索引, Read Committed</a>]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了 <a href="http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html" target="_blank" rel="noopener">innodb_locks_unsafe_for_binlog</a> 参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：<a href="http://hedengcheng.com/?p=220" target="_blank" rel="noopener">MySQL+InnoDB semi-consitent read原理及实现分析</a> 。</p><p>&nbsp;</p><p><strong>结论：</strong>在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p><p>&nbsp;</p><p><strong>组合九：Serializable</strong></p><p>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。</p><p>&nbsp;</p><p>Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。</p><p>&nbsp;</p><p><strong>结论：</strong>在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p><p>&nbsp;</p><ul><li><strong>一条复杂的SQL</strong><br>写到这里，其实MySQL的加锁实现也已经介绍的八八九九。只要将本文上面的分析思路，大部分的SQL，都能分析出其会加哪些锁。而这里，再来看一个稍微复杂点的SQL，用于说明MySQL加锁的另外一个逻辑。SQL用例如下：</li></ul><p><img src="/images/2017/05/MySQL_Lock9.png" alt></p><p>如图中的SQL，会加什么锁？假定在Repeatable Read隔离级别下 (Read Committed隔离级别下的加锁情况，留给读者分析。)，同时，假设SQL走的是idx_t1_pu索引。</p><p>&nbsp;</p><p>在详细分析这条SQL的加锁情况前，还需要有一个知识储备，那就是一个SQL中的where条件如何拆分？具体的介绍，建议阅读我之前的一篇文章：<a href="http://hedengcheng.com/?p=577" target="_blank" rel="noopener">SQL中的where条件，在数据库中提取与应用浅析</a> 。在这里，我直接给出分析后的结果：</p><p>&nbsp;</p><ul><li><strong>Index key**</strong>：**pubtime &gt; 1 and puptime &lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。</li><li><strong>Index Filter**</strong>：**userid = ‘hdc’ 。此条件，可以在idx_t1_pu索引上进行过滤，但不属于Index Key。</li><li><strong>Table Filter**</strong>：**comment is not NULL。此条件，在idx_t1_pu索引上无法过滤，只能在聚簇索引上过滤。<br>在分析出SQL where条件的构成之后，再来看看这条SQL的加锁情况 (RR隔离级别)，如下图所示：</li></ul><p><img src="/images/2017/05/MySQL_Lock10.png" alt></p><p>从图中可以看出，在Repeatable Read隔离级别下，由Index Key所确定的范围，被加上了GAP锁；Index Filter锁给定的条件 (userid = ‘hdc’)何时过滤，视MySQL的版本而定，在MySQL 5.6版本之前，不支持<a href="http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">Index Condition Pushdown</a>(ICP)，因此Index Filter在MySQL Server层过滤，在5.6后支持了Index Condition Pushdown，则在index上过滤。若不支持ICP，不满足Index Filter的记录，也需要加上记录X锁，若支持ICP，则不满足Index Filter的记录，无需加记录X锁 (图中，用红色箭头标出的X锁，是否要加，视是否支持ICP而定)；而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要X锁。最后，选取出了一条满足条件的记录[8,hdc,d,5,good]，但是加锁的数量，要远远大于满足条件的记录数量。</p><p>&nbsp;</p><p><strong>结论：</strong>在Repeatable Read隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。Index Key确定的范围，需要加上GAP锁；Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加X锁，否则需要X锁；Table Filter过滤条件，无论是否满足，都需要加X锁。</p><p>&nbsp;</p><ul><li><strong>死锁原理与分析</strong><br>本文前面的部分，基本上已经涵盖了MySQL/InnoDB所有的加锁规则。深入理解MySQL如何加锁，有两个比较重要的作用：</li></ul><p>&nbsp;</p><ul><li>可以根据MySQL的加锁规则，写出不会发生死锁的SQL；</li><li>可以根据MySQL的加锁规则，定位出线上产生死锁的原因；<br>下面，来看看两个死锁的例子 (一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁)：</li></ul><p><img src="/images/2017/05/MySQL_Lock11.png" alt></p><p><img src="/images/2017/05/MySQL_Lock12.png" alt></p><p>上面的两个死锁用例。第一个非常好理解，也是最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。</p><p>&nbsp;</p><p>第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p><p>&nbsp;</p><p><strong>结论：</strong>死锁的发生与否，并不在于事务中有多少条SQL语句，<strong>死锁的关键在于</strong>：两个(或以上)的Session<strong>加锁的顺序</strong>不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。</p><p>&nbsp;</p><p><strong>总结</strong></p><p>&nbsp;</p><p>写到这儿，本文也告一段落，做一个简单的总结，要做的完全掌握MySQL/InnoDB的加锁规则，甚至是其他任何数据库的加锁规则，需要具备以下的一些知识点：</p><p>&nbsp;</p><ul><li>了解数据库的一些基本理论知识：数据的存储格式 (堆组织表 vs 聚簇索引表)；并发控制协议 (MVCC vs Lock-Based CC)；Two-Phase Locking；数据库的隔离级别定义 (Isolation Level)；</li><li>了解SQL本身的执行计划 (主键扫描 vs 唯一键扫描 vs 范围扫描 vs 全表扫描)；</li><li>了解数据库本身的一些实现细节 (过滤条件提取；Index Condition Pushdown；Semi-Consistent Read)；</li><li>了解死锁产生的原因及分析的方法 (加锁顺序不一致；分析每个SQL的加锁顺序)<br>有了这些知识点，再加上适当的实战经验，全面掌控MySQL/InnoDB的加锁规则，当不在话下。<blockquote><p>以上转载自<a href="https://www.icerainwill.com" target="_blank" rel="noopener">你懂的越多，懂你的越少</a> » <a href="https://www.icerainwill.com/?p=663" target="_blank" rel="noopener">MySQL 加锁处理分析</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017百度、腾讯春招笔试</title>
      <link href="/2017/05/03/2017-Interview-Baidu-And-Tecent/"/>
      <url>/2017/05/03/2017-Interview-Baidu-And-Tecent/</url>
      
        <content type="html"><![CDATA[<p>在经历惨烈的春招后，还是回头看看，好好总结总结。还是需要多练习、多见识，锻炼自己的编程思想，这样在临场时思路更清晰、编码更稳健、排错更及时。</p><p>需要申明的是，下面都是自己的解题思路或者查询到的解题方法，不见得是最优解法，欢迎交流，指错扔砖。</p><a id="more"></a><h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="1、构造回文"><a href="#1、构造回文" class="headerlink" title="1、构造回文"></a>1、构造回文</h2><p>题目描述：给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。</p><p>输入例子：</p><blockquote><p>abcda</p><p>google<br>输出例子：<br>2</p><p>2<br>第一时间想到的是递归遍历出这个最长回文串，但是提交发现运行超时，输出描述上写着1&lt;=s.length&lt;=1000 ，看来确实很大。</p></blockquote><p>后来看讨论中给出一个思路：将求最长回文串问题转化为，求原字符串和其反串(即原字符串逆转)的最长公共子序列(不是子串，可不连续但是顺序一致)的长度，通过动态规划法即可简洁的写出。详尽的关于求最长公共子序列的动态规划算法可参考 万仓一黍 <a href="http://www.cnblogs.com/grenet/archive/2010/06/03/1750454.html" target="_blank" rel="noopener">http://www.cnblogs.com/grenet/archive/2010/06/03/1750454.html</a></p><pre class="lang:java mark:13-19 decode:true">import java.util.Scanner;public class Main{    public static void main(String args[]){        Scanner sc= new Scanner(System.in);        while(sc.hasNext()){            String input=sc.next();            int len=input.length();            int i,j;            char str[]=input.toCharArray();            int alth[][]=new int[len+1][len+1];            for(i=0;i&lt;=len;i++)                alth[0][i]=alth[i][0]=0;            for(i=1;i&lt;=len;i++)//动态规划                for(j=1;j&lt;=len;j++){                    if (str[j-1]==str[len-i])                        alth[i][j]=alth[i-1][j-1]+1;                    else                        alth[i][j]=Math.max(alth[i-1][j],alth[i][j-1]);                }            System.out.println(len-alth[len][len]);        }        sc.close();    }}</pre><h2 id="2、字符移位"><a href="#2、字符移位" class="headerlink" title="2、字符移位"></a>2、字符移位</h2><p>题目描述： 小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？</p><p>输入例子：</p><blockquote><p>AkleBiCeilD<br>输出例子：<br>kleieilABCD<br>题目中的不能申请额外空间一开始让我很迷惑，原来是指空间复杂度为O(1) 常数级而不是不能定义变量之类的。</p></blockquote><p>但是后来在java 实现中会发现：标准输入中只能等到String 对象，但是显然String 对字符操作不方便(当然你要是转空子直接遍历 、CharAt()判断、输出也能得到想要的输出)，在String 类的一些操作类中char [] 的一些方法 如：replace()、replaceAll() ，看似很简洁其实你查看java源码会发现其中使用了很多StringBuffer、StringBuilder，不符合空间复杂度。</p><p>所以建议用C、C++来编写，核心代码：</p><pre class="lang:c decode:true">do{    swap=0;same=0;//swap记录交换次数，name记录遇到大写相遇次数    for(int i=begin;i&lt;len-1;i++){//begin初始为0，标记下一次遍历开始点        if(str[i]&lt;'a'&amp;&amp;str[i+1]&gt;='a'){//遇到aA情况，交换        tmp=str[i];str[i]=str[i+1];str[i+1]=tmp;        swap++;    }    else if(str[i]&lt;'a'&amp;&amp;str[i+1]&lt;'a') {//遇到AA情况        same++ ;if(same==1) begin=i;    }    }}while(swap!=0&amp;&amp;same!=0);//两个记录中有一为0表明排序完成</pre><h2 id="3、有趣的数字"><a href="#3、有趣的数字" class="headerlink" title="3、有趣的数字"></a>3、有趣的数字</h2><p>题目描述：：有n个数，两两组成二元组，差最小的有多少对呢？差最大呢？</p><p>输入描述：输入包含多组测试数据，对于每组测试数据：N - 本组测试数据有n个数，a1,a2…an - 需要计算的数据，1&lt;=N&lt;=100000,0&lt;=ai&lt;=INT_MAX.</p><p>输出描述：对每组，输出两个数，第一个数表示差最小的对数，第二个数表示差最大的对数。</p><p>输入例子：</p><blockquote><p>6</p><p>45 12 45 32 5 6<br>输出例子：<br>1  2<br>其中也没有什么特殊算法，咋一看感觉只需要n^2，不过时间复杂度太大。</p></blockquote><pre class="lang:default decode:true">    1.先排序        1.1.特殊情况：如果排完序之后发现数组中所有数都相同，直接输出结果             结果为：差最大个数 = 差最小个数 = （n * (n-1))/2;(两两组合)    2.统计数组中每种数字的个数（可用map）    3.计算差最小个数        3.1.如果数组中没有重复数字，说明最小差不为0，最小差肯定是数组中相邻两个数的差            因此，遍历一边数组，计算并统计最小差。        3.2.如果数组中有重复数字，说明最小差是0，此时，遍历一边map，数字个数不为0的            数字会产生最小差0，利用公式计算即可    4.计算差最大个数        只有一种情况，最大值与最小值的两两组合，即最大值个数 * 最小值个数    算法复杂度：排序O(nlogn), 统计O(n)    就是很细，有些情况容易忽略</pre><h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="1、回家"><a href="#1、回家" class="headerlink" title="1、回家"></a>1、回家</h2><p>题目描述：一个数轴上共有N个点，第一个点的坐标是度度熊现在位置，第N-1个点是度度熊的家。现在他需要依次的从0号坐标走到N-1号坐标。</p><p>但是除了0号坐标和N-1号坐标，他可以在其余的N-2个坐标中选出一个点，并直接将这个点忽略掉，问度度熊回家至少走多少距离？</p><p>输入例子：</p><blockquote><p>4</p><p>1 4 -1 3<br>输出例子：<br>4<br>求解是先找出那个需要直接忽略掉的坐标点，而判断一个点是不是最值得忽略，判断去除这个点后能让要走的距离减少最多。这样题目就很清晰了</p></blockquote><pre class="lang:java decode:true">    //当n为2或3，直接输出    if(n==2) System.out.println(Math.abs(pos[0]-pos[1]));    else if(n==3) System.out.println(Math.abs(pos[0]-pos[2]));    else{        int []log=new int[n-2];//记录中间坐标去除后可减少长度        for(i=1;i&lt;n-1;i++){            log[i-1]=Math.abs(pos[i]-pos[i-1])+Math.abs(pos[i+1]-pos[i])                    -Math.abs(pos[i+1]-pos[i-1]);//坐标i去除后减少的长度             if(log[i-1]&gt;log[max]) max=i-1;//记录最值得去除点         }         pos[max+1]=(pos[max]+pos[max+2])/2;//将最值得去除点改值，使不影响计算         for(i=1;i&lt;n;i++) sum+=Math.abs(pos[i]-pos[i-1]);//总路径         System.out.println(sum);    }</pre><h1 id="2、不等式数列"><a href="#2、不等式数列" class="headerlink" title="2、不等式数列"></a>2、不等式数列</h1><p>题目描述：对于1到n的一个排列，度度熊发现可以在中间根据大小关系插入合适的大于和小于符号(即 ‘&gt;’ 和 ‘&lt;’ )使其成为一个合法的不等式数列。但是现在手中只有k个小于符号即(‘&lt;’’)和n-k-1个大于符号(即’&gt;’)，想知道对于1至n任意的排列中有多少个排列可以使用这些符号使其为合法的不等式数列。</p><p>如n=3、k=1，则有3&gt;1&lt;2、2&gt;1&lt;3、1&lt;3&gt;2，1&lt;3&gt;2，满足条件的有4种</p><p>输入描述：</p><blockquote><p>包含两个整数n和k(k &lt; n ≤ 1000)<br>输出描述：<br>满足条件的排列数，对2017取模<br>解题思路：</p></blockquote><p>用dp[i][j]表示有 i 个数字及 j 个小于号所能组成的数量(大于号数量当然是i - j - 1 个)</p><p>归纳：在dp[i][j]的前提下，加入第 i+1 个数字即 i+1，分为四种情况</p><ol><li><p>如果将i+1插入当前序列的开头，即有了1&lt;2（或2&gt;1），加入后成为3&gt;1&lt;2，会发现等于同时加入了一个大于号！(此时可以无视1与2内部的关系，因为 i+1&gt;i )</p></li><li><p>如果将i+1插入当前序列末尾,即1&lt;2（或2&gt;1）变成了 1&lt;2&lt;3，会发现等于同时加入了一个小于号！ (此时可以无视1与2之间的关系，因为i+1&gt;i)</p></li><li><p>如果将i+1加入一个小于号之间，即已经有 1&lt;2了，向中间加入3,会发现变成了1&lt;3&gt;2，等于同时加入了一个大于号！</p></li><li><p>如果将i+1加入一个大于号中间，即有了2&gt;1，变成了2&lt;3&gt;1，等于同时加入了一个小于号！<br>则可知dp[i][j]的值等于上述值的和:</p></li><li><p>dp[i-1][j]—-只加了一个大于号及 i</p></li><li><p>dp[i - 1][j - 1] —-只加了一个小于号及 i</p></li><li><p>dp[i - 1][j] * j  —-在其中的每个小于号之间，加入 i 和大于号</p></li><li><p>dp[i - 1][j - 1] * (i- j - 1) —-在其中的每个大于号之间，加入 i 和小于号<br>可得 dp[i][j] = (dp[i - 1][j - 1] * (i - j) + dp[i - 1][j] * (j + 1)) 再对2017取模</p></li></ol><p>之后问题便迎刃而解。</p><pre class="lang:java decode:true">        int[][] dp = new int[n+1][k+1];          for (int i = 1; i &lt; n+1; i++)            dp[i][0] = 1;  //初始值全为1        for (int i = 2; i &lt; n+1; i++) {              for (int j = 1; j &lt;= k &amp;&amp; j &lt; i; j++) {                  dp[i][j] = (dp[i-1][j-1]*(i-j)+dp[i-1][j]*(j+1))%2017;              }          }</pre><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 主从同步及全文索引</title>
      <link href="/2017/04/29/MySQL-FulltextIndex-And-Sync/"/>
      <url>/2017/04/29/MySQL-FulltextIndex-And-Sync/</url>
      
        <content type="html"><![CDATA[<p>这两个都是自己在实际操作上遇到的具体问题，很常见也很实用。MySQL主从复制的需求是因为在将GitHub上一个<span style="color: #00ff00;"><a href="https://github.com/boramalper/magnetico" target="_blank" rel="noopener">BitTorrent DHT搜索引擎</a></span>架设到服务器时，想通过复制实现异步数据同步。而全文索引也是想提高千万数据前提下模糊查询速度，将在之后写出。</p><p><img src="/images/2017/04/mysql_rep1.jpg" alt></p><a id="more"></a><h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>其中很多都是官方文档中意译过来的，英文文档可能更详细 <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-howto.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/replication-howto.html</a></p><h2 id="一、实现机制"><a href="#一、实现机制" class="headerlink" title="一、实现机制"></a>一、实现机制</h2><p>主从同步是在主从复制的基础上个实现的。</p><p>MySQL支持两种复制方式：基于行复制和基于语句复制。但本质上都是通过在主库上记录二进制日志（binlog），然后从库上通过一个I/O线程从主库上读取binlog，然后传输到从库的中继日志中，然后从库的SQL线程从中继日志中读取中继日志，然后应用到从库的数据库中。这样就实现了主从同步。</p><p>当然实现A-&gt;B-&gt;C也是这个道理，只不过C读取的是B的 binlog。</p><h2 id="二、配置步骤"><a href="#二、配置步骤" class="headerlink" title="二、配置步骤"></a>二、配置步骤</h2><h3 id="1、创建复制帐号"><a href="#1、创建复制帐号" class="headerlink" title="1、创建复制帐号"></a>1、创建复制帐号</h3><p>创建单独的复制帐号，主从推荐都加，而权限只需要<a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_replication-slave" target="_blank" rel="noopener"><code>REPLICATION SLAVE</code></a> 即可。另外开启MySQL远程连接自然也是必须的。</p><pre class="lang:mysql decode:true" title="MySQL Create User">限制帐号登录IP为slaveipmysql&gt; CREATE USER 'repl'@'slaveip' IDENTIFIED BY 'slavepass';mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'slaveip';</pre><h3 id="2、主库配置"><a href="#2、主库配置" class="headerlink" title="2、主库配置"></a>2、主库配置</h3><p>主库必须开启二进制日志选项，并指定唯一的 serve-id，在配置文件my.cn或my.ini的[mysqld]部分修改，修改后重启。</p><pre class="lang:mysql decode:true" title="mysqld">[mysqld]log-bin=mysql-binserver-id=1#binlog-ignore-db=库名 #可选，设置不同步的库，可设置多个#binlog-do-db=库名     #可选，开启后只同步这些数据库#expire_logs_days=10  #可选，设置保留时间#sync_binlog=5        #可选，设置写入频率，以降低性能减少库崩溃损失</pre><blockquote><p>server-id 必填，并且取值在1 ~ (2^32)-1，不为0</p><p><span id="result_box" class lang="zh-CN"><span class>在复制设置中尽可能使InnoDB事务的持久性和一致性，您可在master my.cnf文件中使用innodb_flush_log_at_trx_commit = 1和sync_binlog = 1。</span></span></p></blockquote><h3 id="3、确定主库当前binlog位置"><a href="#3、确定主库当前binlog位置" class="headerlink" title="3、确定主库当前binlog位置"></a>3、确定主库当前binlog位置</h3><p>通过命令行在主库开启一个会话，阻止所有表写入操作（确保位置准确）</p><pre class="lang:mysql decode:true" title="flush tables">mysql&gt; FLUSH TABLES WITH READ LOCK;#离开当前会话需再输入，保存效果mysql&gt; FLUSH TABLES</pre><p>然后查看当前binlog 文件名(File)和位置(Position)，需记住并在之后用到</p><pre class="lang:mysql decode:true" title="Master Status">mysql &gt; SHOW MASTER STATUS;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 73       | test         | manual,mysql     |+------------------+----------+--------------+------------------+</pre><p>在结束第四步后则释放锁</p><pre class="lang:mysql decode:true" title="unlock">mysql&gt; UNLOCK TABLES;</pre><h3 id="4、创建数据快照"><a href="#4、创建数据快照" class="headerlink" title="4、创建数据快照"></a>4、创建数据快照</h3><p>这是后就有三种情况了：</p><ul><li>主从库都没有数据，也没有要导入的数据；</li><li>主从库都没有数据，但有需要导入的数据；</li><li>主库有存在的数据，但从库是新的空库；<br>第一种情况可直接跳到下一步，配置从库。</li></ul><p>第二种情况也可直接跳到下一步，配置好从库后，将数据导入主库即自动同步到从库。当然也可分别导入主、从库，然后再从头进行主从同步配置。</p><p>第三种情况先将主库中数据导出，再导入到从库。</p><pre class="lang:sh decode:true" title="mysqldump"># --master-data 选项可自动追加从库复制过程需要的 CHANGE MASTER TO# 如果不加，则需要主库锁住所有的表# --ignore-table 排除哪些库# --databases    指定哪些库shell&gt; mysqldump --all-databases --master-data &gt; dbdump.db</pre><h3 id="5、从库配置"><a href="#5、从库配置" class="headerlink" title="5、从库配置"></a>5、从库配置</h3><p>从库修改配置，并重启数据库。</p><pre class="lang:mysql decode:true" title="slave-mysqld">[mysqld]server-id=2#以下为 A-&gt;B-&gt;C 额外配置#log-bin=bin     #可选，从库开启二进制日志#relay-log=relay-bin #可选#log-slave-updates=1 #可选，允许从库将重放的事件也记录到自身的二进制日志中#read_only=1     # 防止从库被修改</pre><p>从库启动复制配置</p><pre class="lang:mysql decode:true" title="CHANGE MASTER TO">mysql&gt; CHANGE MASTER TO    -&gt;     MASTER_HOST='master_host_name',#主库IP    -&gt;     MASTER_USER='replication_user_name',#复制帐号    -&gt;     MASTER_PASSWORD='replication_password',#密码    -&gt;     MASTER_LOG_FILE='recorded_log_file_name',#步骤三的File    -&gt;     MASTER_LOG_POS=recorded_log_position;#步骤三的Position    -&gt;     MASTER_CONNECT_RETRY=10; #断开重连时间</pre><p>启动复制，并查看状态</p><pre class="lang:mysql decode:true" title="START SLAVE">mysql&gt; START SLAVE; #开启同步，结束则为STOPmysql&gt; SHOW SLAVE STATUS\G*************************** 1\. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.10                  Master_User: repl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000003          Read_Master_Log_Pos: 73               Relay_Log_File: relay-bin.000001                Relay_Log_Pos: 400        Relay_Master_Log_File: mysql-bin.000003             Slave_IO_Running: Yes #            Slave_SQL_Running: Yes #都为yes则正常            ...            Seconds_Behind_Master: 0</pre><h1 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>个人在实践中遇到的情况是这样的：在InnoDB引擎的一个70万+记录的表中，要模糊查询一个text 类型的字段。常见的like 模糊查询需要消耗1.7 + sec ，已经不让人满意了，更不用说更大量的数据。</p><h1 id="二、过程"><a href="#二、过程" class="headerlink" title="二、过程"></a>二、过程</h1><p>发现全文索引(FULLTEXT)可能是个不错的办法（当然也可使用一些搜索引擎软件，不过对于几十万量级好像没必要），不过在文档中发现：</p><p>1、MySQL是从5.6版本才开始支持InnoDB引擎的全文索引，语法层面上大多数兼容之前MyISAM的全文索引模式。但是不支持中、韩、日文</p><p>2、从MySQL 5.7.3开始InnoDB支持全文索引插件，用户可以以Plugin的模式来定义自己的分词规则，或是引入社区开发的全文索引解析器。于是可以使用支持中文的全文索引插件。</p><p>3、从MySQL5.7.6版本开始提供了一种内建的全文索引 ngram parser，可以很好的支持CJK字符集（中文、日文、韩文）。内建在代码中，该解析器默认安装，你可以通过指定索引属性（<code>WITH PARSER ngram</code>）来利用该parser。</p><pre class="lang:mysql decode:true" title="ngram parser">#创建mysql&gt; create table ft_test(id int, content text, fulltext (content) with parser ngram);#修改mysql&gt; alter table ft_test add fulltext content(content) with parser ngram;</pre><p>当然如果数据量大的话，这可能需要花不少时间（对我可怜的ECS、VPS够呛的）当然这是值得的，通过全文索引能将查询时间降低到0.06 sec 左右。</p><p>而N-Gram是使用一种特殊的方式来进行分词，举个简单的例子，假设要对单词’abcd’进行分词，那么其分词结果为：</p><pre><code>N=1 : &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;;N=2 : &apos;ab&apos;, &apos;bc&apos;, &apos;cd&apos;;N=3 : &apos;abc&apos;,&apos;bcd&apos;;N=4: &apos;abcd&apos;;</code></pre><p>N取决于<code>ngram_token_size</code>的设置，默认值为2。</p><p>在执行查询时，用户传递的搜索词也会基于N-Gram进行分解后进行检索。<code>而关于停词和分词处理 可参考官方博文 [http://mysqlserverteam.com/innodb全文索引：n-gram-parser/](http://mysqlserverteam.com/innodb全文索引：n-gram-parser/)</code></p><p>阿里的这篇特性讲解也很详细 <a href="http://mysql.taobao.org/monthly/2015/10/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2015/10/01/</a></p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进阶小记</title>
      <link href="/2017/04/15/Linux-Advanced-Notes/"/>
      <url>/2017/04/15/Linux-Advanced-Notes/</url>
      
        <content type="html"><![CDATA[<p>记得命令但是参数不清楚？找到感兴趣的站点，但上面的RSS不知道怎么用？远程控制服务器只能开启一个终端且中断后很痛苦？用起Vim 来感觉不过就是像用没鼠标的记事本？想一个命令不记参数就能实时查看系统性能？</p><p><img src="/images/2017/04/bash.jpg" alt><a id="more"></a></p><p>菜鸟入门，一步步学习ing !</p><p>环境：Ubuntu 16.04，秉承不重复造轮子的原则记录下学习的过程</p><h1 id="Cheat：终极命令行“备忘单”"><a href="#Cheat：终极命令行“备忘单”" class="headerlink" title="Cheat：终极命令行“备忘单”"></a>Cheat：终极命令行“备忘单”</h1><p>适合任何一个和我一样记不清参数的童鞋，简单好使。需先安装Python，pip及git，详细教程 <a href="https://linux.cn/article-3760-1.html" target="_blank" rel="noopener">https://linux.cn/article-3760-1.html</a>。</p><blockquote><p>sudo apt-get install python python-pip git</p><p>pip install docopt pygments //安装依赖</p><p>git clone <a href="https://github.com/chrisallenlane/cheat.git" target="_blank" rel="noopener">https://github.com/chrisallenlane/cheat.git</a></p><p>cd cheat</p><p>python setup.py install</p></blockquote><h1 id="liferea：Linux-免费RSS阅读器"><a href="#liferea：Linux-免费RSS阅读器" class="headerlink" title="liferea：Linux 免费RSS阅读器"></a>liferea：Linux 免费RSS阅读器</h1><p>RSS：简易信息聚合。通俗点说就是将网站信息包装成RSS这种XML标准的文件内容，以<span class="RichText CopyrightRichText-richText">定制个性化推送信息的服务</span>。是当前信息过剩的时代，为你提供你关注信息的一种便利渠道。有人道：支持RSS是一种美德。</p><p>RSS阅读器顾名思义，即是阅读你订阅的这些RSS信息的工具。Ubuntu上安装只需简单地<code>apt-get</code>即可，无需配置，然后添加你订阅的地址即可接受推送信息。此外，除了通过RSS阅读器外，还可以通过邮件订阅的方式，例如：在这个网站<a href="https://blogtrottr.com/" target="_blank" rel="noopener">https://blogtrottr.com/</a> ，输入需要订阅的RSS源地址、邮箱地址，即可收到实时的信息推送，甚至是国内被墙了的技术博客可能看到，很不错。</p><h1 id="ShadowSocks"><a href="#ShadowSocks" class="headerlink" title="ShadowSocks"></a>ShadowSocks</h1><blockquote><p>sudo add-apt-repository ppa:hzwhuang/ss-qt5（找软件）</p><p>sudo apt-get update （更新你的软件库）</p><p>sudo apt-get install shadowsocks-libqtshadowsocks shadowsocks-qt5 (正式安装)<br>科学上网利器不必多说，Firefox 配置网络 即可使用。</p></blockquote><p>记得记得 勾选 <span style="color: #00ff00;">*<em>使用SOCK代理DNS *</em><span style="color: #000000;"> ～血一般的教训</span></span></p><h1 id="tmux：终端复用利器"><a href="#tmux：终端复用利器" class="headerlink" title="tmux：终端复用利器"></a>tmux：终端复用利器</h1><p>可以实现通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。可以横向和纵向分割窗口，且窗格可以自由移动和调整大小。可在多个缓冲区进行复制和粘贴，支持跨窗口搜索；非正常断线后不需重新detach。</p><p>工具很小可直接<code>apt-get</code>，详细的教程有：<a href="http://blog.opskumu.com/tmux.html" target="_blank" rel="noopener">http://blog.opskumu.com/tmux.html</a>，就像先给你看火热脱衣舞女勾起你性趣，只有等你自己回去撸一发，才会发现用起来真的感觉真爽 (^O^)</p><h1 id="Vim练级攻略"><a href="#Vim练级攻略" class="headerlink" title="Vim练级攻略"></a>Vim练级攻略</h1><p>Vim ？练级？不存在的！除了插入，删除，<code>dd</code> 删除一行就还能怎么用了？</p><p>收藏好下面这几篇博文，每天练其中的一两个操作，几周之后阁下就会发现Vim才是真正的文本编辑器。</p><p>酷壳（一个值得订阅的IT博客）</p><ul><li>简明的Vim练级攻略  <a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">http://coolshell.cn/articles/5426.html </a></li><li>Vim的分屏功能 <a href="http://coolshell.cn/articles/1679.html" target="_blank" rel="noopener">http://coolshell.cn/articles/1679.html</a></li><li>无插件Vim编辑技巧 <a href="http://coolshell.cn/articles/11312.html" target="_blank" rel="noopener">http://coolshell.cn/articles/11312.html</a></li></ul><h1 id="dstat：实时系统性能查看"><a href="#dstat：实时系统性能查看" class="headerlink" title="dstat：实时系统性能查看"></a>dstat：实时系统性能查看</h1><p>安装依旧是那么简单，之后添加<code>alias dstat=&#39;dstat -cdlmnpsy&#39;</code>。执行dstat即可实时看到想要的数据。</p><p><img src="/images/2017/04/LinuxTools.png" alt="Linux 性能检测工具汇总，来自https://www.ibm.com/developerworks/cn/java/j-lo-performance-tuning-practice/index.html"></p><p>———————后续更新中———————</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP、BM算法（下）</title>
      <link href="/2017/04/10/Algorithm-KMP-And-BM-2/"/>
      <url>/2017/04/10/Algorithm-KMP-And-BM-2/</url>
      
        <content type="html"><![CDATA[<p>继上篇KMP、BM算法（上），这篇中的BM算法比KMP算法的效率更高，构思精巧。但是算法实现起来也更困难，更难以理解。</p><p><img src="/images/2017/04/BM_.jpg" alt></p><a id="more"></a><p>可以先简单了解大概思想：阮一峰 <a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html</a></p><h1 id="一：算法思想："><a href="#一：算法思想：" class="headerlink" title="一：算法思想："></a><strong>一：算法思想：</strong></h1><blockquote><p>图片转载来自 Alexia <a href="http://www.cnblogs.com/lanxuezaipiao/p/3452579.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanxuezaipiao/p/3452579.html</a><br><strong>前提：假设文本串text长度为n，模式串pattern长度为m，从右走往左匹配</strong></p></blockquote><p>1、</p><ul><li>第一步，将pattern 从右往左匹配，发现最后一个字符 c 与 d 不匹配。我们称这样不匹配的字符为“坏字符”（text 红色）。而且 pattern 中并没有 d ，于是我们知道需将 pattern 右移长度m 即 5 以重新匹配。（右移1、2、3、4也不会匹配，聪明的你肯定想到了）</li><li>现在到达 BM 行位置，再从右往左匹配，发现最后一个字符 c 与 b 不匹配。对的，这个时候 b 就是“坏字符”。然而这pattern 中包含了 b ，我们就可以直接将pattern 移动到其中的 b与“坏字符”对应的位置（聪明的你肯定看出来了），但是pattern 中有两个 b，移动就需要选择近的那个避免漏掉。<br><img src="/images/2017/04/BM1.png" alt></li></ul><p>2、在继续前面的移动后，可以看到在BM行中从右到左匹配，符合匹配的依次是c、a、b 但是之后发现pattern 中的a 并不匹配 b。如果这时依然使用之前的策略，将其移动到 之后对应的b 的位置，反而走了回头路，这样我们就需要将pattern  右移一步。<strong>这就是其中的“坏字符”算法思想</strong></p><p><img src="/images/2017/04/BM2.png" alt></p><p>3、</p><ul><li>再接着看下面，在使用一次“坏字符”算法后，BM 行从右往左发现 pattern 中依次为 b、a是匹配的，之后  b不匹配 a时，运用上面的“坏字符”算法，我们可以右移一位。（这样当然也可以）</li><li>但是这次，我们需要利用起已经匹配的 “ab” 两个字符，就叫它“好后缀”。在pattern 中发现在其中有和“好后缀”匹配的 “ab”，于是我们就可以将pattern 右移使得其对应的位置。<strong>这就是其中的“好后缀” 算法思想</strong><br><img src="/images/2017/04/BM3.png" alt></li></ul><p>4、</p><ul><li>接着看下面这个，在使用一次“坏字符”算法后，BM 行从右往左发现 pattern 中依次为 c、a、b是匹配的，之后  a 不匹配 b时，”bac” 是 “好后缀”，但是pattern 中并没有和其相匹配的其他串了，这时我们再用回“坏字符”算法”，但是又得注意不往左移动。（再怎么拼凑，左移注定没有意义的）<br><img src="/images/2017/04/BM2.png" alt></li></ul><p>这便是BM算法中核心的两个算法思想：“坏字符”和“好后缀”算法。BM算法中，每一步的移动步数就是这两种算法中的最大值。</p><h1 id="二：算法情况探讨："><a href="#二：算法情况探讨：" class="headerlink" title="二：算法情况探讨："></a>二：算法情况探讨：</h1><h3 id="（1）坏字符算法"><a href="#（1）坏字符算法" class="headerlink" title="（1）坏字符算法"></a>（1）坏字符算法</h3><p>当出现一个坏字符时, BM算法向右移动模式串, 让模式串中最靠右的对应字符与坏字符相对，然后继续匹配。坏字符算法有两种情况。（为什么是最靠右？往最靠右相对不是有左移的情况吗？是的，但这由<strong>第二个算法限制它不左移动</strong>，别急）</p><p><strong>y 为文本串，x 为模式串，shift 为移动步数，u 有已匹配的串。</strong></p><p>情况一：</p><p><img src="/images/2017/04/BM5.png" alt></p><p>情况二：</p><p><img src="/images/2017/04/BM6.png" alt></p><h3 id="（2）好后缀算法"><a href="#（2）好后缀算法" class="headerlink" title="（2）好后缀算法"></a>（2）好后缀算法</h3><p>情况一：模式串中有子串和好后缀完全匹配，则将最靠右的那个子串移动到好后缀的位置继续进行匹配。</p><p><img src="/images/2017/04/BM7.png" alt></p><p>情况二：如果不存在和好后缀完全匹配的子串，则在好后缀中找到具有如下特征的最长子串,使得P[m-s…m]=P[0…s]。（P[]为pattern ）</p><p><img src="/images/2017/04/BM8.png" alt></p><p>情况三：如果完全不存在和好后缀匹配的子串，则右移整个模式串。shift=m。</p><p><strong>BM算法中，每一步的向右移动的步数都是这两种算法中的最大值。（不往左移动）</strong></p><h1 id="三：算法实现："><a href="#三：算法实现：" class="headerlink" title="三：算法实现："></a>三：算法实现：</h1><p>使用坏字符算法计算pattern需要右移的距离，存放在bmBc[]，而按好后缀算法计算pattern右移的距离则要存放在bmGs[]。下面讲下怎么计算bmBc[]和bmGs[]这两个预处理数组。</p><h3 id="（1）计算数组bmBc-："><a href="#（1）计算数组bmBc-：" class="headerlink" title="（1）计算数组bmBc[ ]："></a>（1）计算数组bmBc[ ]：</h3><p>我们使用字符作为下标而不是位置数字作为下标。<strong>bmBc[字符] 对应的数组值即是该字符离pattern 最右端的距离</strong>，但如果是纯8位字符也只需要256个空间大小，而且对于大模式，可能本身长度就超过了256，所以这样做是值得的（这也是为什么数据越大，BM算法越高效的原因之一）。</p><p><img src="/images/2017/04/BM9.png" alt></p><p>bmBc[]的计算分两种情况，与前一一对应。</p><p>情况一：字符在模式串中有出现，bmBc[‘v’]表示字符v在模式串中最后一次出现的位置，距离模式串串尾的长度，如上图所示。</p><p>情况二：字符在模式串中没有出现，如模式串中没有字符v，则bmBc[‘v’] = strlen(pattern)。</p><p>写成代码也非常简单：</p><pre class="lang:c decode:true" title="bmBc">void PreBmBc(char *pattern, int m, int bmBc[]){    int i;    for(i = 0; i &lt; 256; i++)        bmBc[i] = m;    for(i = 0; i &lt; m - 1; i++)//i&lt;m-1避免bmBc[m-1]=0        bmBc[pattern[i]] = m - 1 - i;}</pre><p>图中v是text中的坏字符（对应位置i+j）,在pattern中对应不匹配的位置为i，那么pattern实际要右移的距离就是：bmBc[‘v’] - m + 1 + i。(没错可能为负数)</p><h3 id><a href="#" class="headerlink" title></a><img src="/images/2017/04/BM10.png" alt></h3><h3 id="（2）计算bmGs-数组"><a href="#（2）计算bmGs-数组" class="headerlink" title="（2）计算bmGs[ ]数组"></a>（2）计算bmGs[ ]数组</h3><p>这里的bmGs[]的下标，是数字而不是字符了，是字符在pattern中位置，<strong>bmGs[ i ]应表示在 pattern 中当“好后缀”前不匹配位置在i 时，模式串应移动的距离</strong>。假设好后缀长度用数组suff[ ]表示。我们需要先把这个辅助数组suff[ ]求出。</p><p>而<strong>数组suff[ i ]表示pattern中以 i 位置字符为后缀和以最后一个字符为后缀的公共后缀串的长度</strong>。（好吧，需要举一个栗子）</p><pre class="lang:c# decode:true" title="suff">suffix[m-1] = m;//m为pattern长度suffix[i] = k      for [ pattern[i-k+1] ....,pattern[i]] == [pattern[m-1-k+1]，pattern[m-1]]</pre><p>i     :            0 1   2 3 4  5  6 7<br>pattern: b c  a b a  b  a  b</p><ul><li>当i=7时，按定义suff[7] = strlen(pattern) = 8</li><li>当i=6时，以pattern[6]为后缀的后缀串为bcababa，以最后一个字符b为后缀的后缀串为bcababab，两者没有公共后缀串，所以suff[6] = 0</li><li>当i=5时，以pattern[5]为后缀的后缀串为bcabab，以最后一个字符b为后缀的后缀串为bcababab，两者的公共后缀串为abab，所以suff[5] = 4</li><li>以此类推，当i=0时，以pattern[0]为后缀的后缀串为b，以最后一个字符b为后缀的后缀串为bcababab，两者的公共后缀串为b，所以suff[0] = 1<pre class="lang:c decode:true" title="suffixs">void suffix(char *pattern, int m, int suff[])\\生成suff[ ]数组{int i,j;suff[m - 1] = m;for(i = m - 2; i &gt;= 0; i--){    j = i;    while(j &gt;= 0 &amp;&amp; pattern[j] == pattern[m - 1 - i + j])         j--;    suff[i] = i - j;}}</pre>另一种改进算法就是利用了已经得到的suff[ ]值，计算现在正在计算的suff[]值。</li></ul><p>i 是当前正准备计算suff[]值的那个位置。f 是上一个成功进行匹配的起始位置。g 是上一次进行成功匹配的失配位置。</p><p>若 i 在 g 和 f 之间，那么一定有P[i]=P[m-1-f+i]（P[ ]为pattern）；并且如果suff[m-1-f+i] &lt; i-g, 则suff[i] = suff[m-1-f+i]，这不就利用了前面的suff了吗。（难以理解需中再熟悉suff[ ]定义）</p><p><img src="/images/2017/04/BM14.png" alt></p><pre class="lang:c decode:true " title="suffixes">void suffixes(char *x, int m, int *suff) {   int f, g, i;   suff[m - 1] = m;   g = m - 1;   for (i = m - 2; i &gt;= 0; --i) {      if (i &gt; g &amp;&amp; suff[i + m - 1 - f] &lt; i - g)         suff[i] = suff[i + m - 1 - f];      else {         if (i &lt; g)            g = i;         f = i;         while (g &gt;= 0 &amp;&amp; x[g] == x[g + m - 1 - f])            --g;         suff[i] = f - g;      }   }}</pre><p>求出辅助数组suff[ ]后，再来讨论号后缀的几种情况中bmGs[ ]的值。</p><p>情况一：<img src="/images/2017/04/BM11.png" alt></p><p>情况二：</p><p><img src="/images/2017/04/BM12.png" alt></p><p>情况三：</p><p><img src="/images/2017/04/BM13.png" alt></p><pre class="lang:c decode:true" title="preBmGs">void preBmGs(char *x, int m, int bmGs[]) {   int i, j, suff[XSIZE];   suffixes(x, m, suff);//计算suff[ ]   for (i = 0; i &lt; m; ++i)//情况三      bmGs[i] = m;   j = 0;   for (i = m - 1; i &gt;= 0; --i)//情况二         for (; j &lt; m - 1 - i; ++j)            if (bmGs[j] == m)               bmGs[j] = m - 1 - i;   for (i = 0; i &lt;= m - 2; ++i)//情况一      bmGs[m - 1 - suff[i]] = m - 1 - i;}</pre><p>再举一个栗子：</p><p><img src="/images/2017/04/BM15.png" alt></p><pre class="lang:c decode:true" title="BM">//完整代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define SIZE 256#define MAX(x, y) (x) &gt; (y) ? (x) : (y)#define ASIZE 256 #define XSIZE 256void BoyerMoore(char *pattern, int m, char *text, int n);int main(){    char text[256], pattern[256];    while(1)    {        scanf("%s%s", text, pattern);        if(text == 0 || pattern == 0) break;        BoyerMoore(pattern, strlen(pattern), text, strlen(text));    }    return 0;}void preBmBc(char *x, int m, int bmBc[]){// void PreBmBc(char *pattern, int m, int bmBc[]) {   int i;   for (i = 0; i &lt; ASIZE; ++i)      bmBc[i] = m;   for (i = 0; i &lt; m - 1; ++i)      bmBc[x[i]] = m - i - 1;}void suffixes(char *x, int m, int *suff) {   int f, g, i;   suff[m - 1] = m;   g = m - 1;   for (i = m - 2; i &gt;= 0; --i) {      if (i &gt; g &amp;&amp; suff[i + m - 1 - f] &lt; i - g)         suff[i] = suff[i + m - 1 - f];      else {         if (i &lt; g)            g = i;         f = i;         while (g &gt;= 0 &amp;&amp; x[g] == x[g + m - 1 - f])            --g;         suff[i] = f - g;      }   }}void preBmGs(char *x, int m, int bmGs[]) {   int i, j, suff[XSIZE];   suffixes(x, m, suff);   for (i = 0; i &lt; m; ++i)      bmGs[i] = m;   j = 0;   for (i = m - 1; i &gt;= 0; --i)      if (suff[i] == i + 1)         for (; j &lt; m - 1 - i; ++j)            if (bmGs[j] == m)               bmGs[j] = m - 1 - i;   for (i = 0; i &lt;= m - 2; ++i)      bmGs[m - 1 - suff[i]] = m - 1 - i;}void BoyerMoore(char *pattern, int m, char *text, int n){    int i, j, bmBc[ASIZE], bmGs[XSIZE];    // Preprocessing    preBmBc(pattern, m, bmBc);    preBmGs(pattern, m, bmGs);    // Searching    j = 0;    while(j &lt;= n - m)    {        for(i = m - 1; i &gt;= 0 &amp;&amp; pattern[i] == text[i + j]; i--);        if(i &lt; 0)        {            printf("The position is %d\n", j);            j += bmGs[0];            return;        }        else        {            j += MAX(bmBc[text[i + j]] - m + 1 + i, bmGs[i]);        }    }    printf("No find.\n");}</pre><p>&nbsp;</p><p>参考资料：</p><p>Boyer-Moore algorithm <a href="http://igm.univ-mlv.fr/~lecroq/string/node14.html" target="_blank" rel="noopener">http://igm.univ-mlv.fr/~lecroq/string/node14.html</a></p><p><a href="http://weibo.com/lanxuezaipiao/" target="_blank" rel="noopener">Alexia(minmin) </a>   <a href="http://www.cnblogs.com/lanxuezaipiao/p/3452579.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanxuezaipiao/p/3452579.html</a></p><p>阮一峰 <a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP、BM算法（上）</title>
      <link href="/2017/04/07/Algorithm-KMP-And-BM-1/"/>
      <url>/2017/04/07/Algorithm-KMP-And-BM-1/</url>
      
        <content type="html"><![CDATA[<p>对于吃力的KMP算法，遇到一篇详细的讲解文章和大家分享下：</p><h1 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a><strong>一：背景</strong></h1><p><img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_1.png" alt></p><a id="more"></a><p>给定一个主字符串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，即串的模式匹配问题。今天来介绍解决这一问题的常用算法之一，Knuth-Morris-Pratt 算法（简称 KMP），这个算法是由高德纳（Donald Ervin Knuth）和沃恩 · 普拉特在 1974 年构思，同年詹姆斯 ·H· 莫里斯也独立地设计出该算法，最终由三人于 1977 年联合发表。<br>在继续下面的内容之前，有必要在这里介绍下两个概念：<strong>前缀</strong>和<strong>后缀</strong>。</p><p>由上图所得， “前缀” 指除了最后一个字符以外，一个字符串的全部头部组合；”后缀” 指除了第一个字符以外，一个字符串的全部尾部组合。</p><h1 id="二：朴素字符串匹配算法"><a href="#二：朴素字符串匹配算法" class="headerlink" title="二：朴素字符串匹配算法"></a><strong>二：朴素字符串匹配算法</strong></h1><p>初遇串的模式匹配问题，我们脑海中的第一反应，必是朴素字符串匹配（暴力匹配），即遍历 S 的每个字符，以该字符为始与 P 比较，全部匹配就输出；否则直到 S 结束。代码如下：</p><pre class="lang:c++ decode:true" title="Normal">/* 字符串下标始于0 */int NaiveStringSearch(string S, string P){    int i = 0;    //S的下标    int j = 0;    //P的下标    int s_len = S.size();    int p_len = P.size();    while (i &lt; s_len &amp;&amp; j &lt; p_len)    {        if (S[i] == P[j])  //若相等，都前进一步        {            i++;            j++;        }        else  //不相等        {            i = i - j + 1;            j = 0;        }    }    if (j == p_len)  //匹配成功        return i - j;    return -1;}</pre><p>&nbsp;</p><p>上述算法的时间复杂度为 <span id="MathJax-Element-1-Frame" class="MathJax_SVG" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"></span>，其中 <span id="MathJax-Element-2-Frame" class="MathJax_SVG" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/math&gt;"></span> 为 S 的长度，<span id="MathJax-Element-3-Frame" class="MathJax_SVG" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/math&gt;"></span> 为 P 的长度。这种时间复杂度很难满足我们的需求，接下来进入正题：时间复杂度为 <span id="MathJax-Element-4-Frame" class="MathJax_SVG" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;&amp;#x398;&lt;/mo&gt;&lt;/mrow&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"></span> 的 KMP 算法。</p><h1 id="三：KMP-字符串匹配算法"><a href="#三：KMP-字符串匹配算法" class="headerlink" title="三：KMP 字符串匹配算法"></a><strong>三：KMP 字符串匹配算法</strong></h1><h2 id="3-1-算法流程"><a href="#3-1-算法流程" class="headerlink" title="3.1 算法流程"></a><strong>3.1 算法流程</strong></h2><p>（1）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_2.png" alt></p><p>首先，主串 “BBC ABCDAB ABCDABCDABDE” 的第一个字符与模式串 “ABCDABD” 的第一个字符，进行比较。因为 B 与 A 不匹配，所以模式串后移一位。</p><p>（2）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_3.png" alt></p><p>因为 B 与 A 又不匹配，模式串再往后移。</p><p>（3）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_4.png" alt></p><p>就这样，直到主串有一个字符，与模式串的第一个字符相同为止。</p><p>（4）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_5.png" alt></p><p>接着比较主串和模式串的下一个字符，还是相同。</p><p>（5）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_6.png" alt></p><p>直到主串有一个字符，与模式串对应的字符不相同为止。</p><p>（6）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_7.png" alt></p><p>这时，最自然的反应是，将模式串整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把 “搜索位置” 移到已经比较过的位置，重比一遍。</p><p>（7）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_8.png" alt></p><p>一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是 “ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把 “搜索位置” 移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。</p><p>（8）</p><table><thead><tr><th align="center">                j</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">A</td><td align="center">B</td><td align="center">D</td><td align="center">'\0'</td></tr><tr><td align="center">next[j]</td><td align="center">-1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td></tr></tbody></table>怎么做到这一点呢？可以针对模式串，设置一个跳转数组`int next[ ]`，这个数组是怎么计算出来的，后面再介绍，这里只要会用就可以了。<p>（9）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_9.png" alt></p><p>已知空格与 D 不匹配时，前面六个字符 “ABCDAB” 是匹配的。根据跳转数组可知，不匹配处 D 的 next 值为 2，因此接下来<strong>从模式串下标为 2 的位置开始匹配</strong>。</p><p>（10）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_10.png" alt></p><p>因为空格与Ｃ不匹配，C 处的 next 值为 0，因此接下来模式串从下标为 0 处开始匹配。</p><p>（11）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_11.png" alt></p><p>因为空格与 A 不匹配，此处 next 值为 - 1，表示模式串的第一个字符就不匹配，那么直接往后移一位。</p><p>（12）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_12.png" alt></p><p>逐位比较，直到发现 C 与 D 不匹配。于是，下一步从下标为 2 的地方开始匹配。</p><p>（13）<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95_13.png" alt></p><p>逐位比较，直到模式串的最后一位，发现完全匹配，于是搜索完成。</p><h2 id="3-2-next-数组是如何求出的"><a href="#3-2-next-数组是如何求出的" class="headerlink" title="3.2 next 数组是如何求出的"></a><strong>3.2 next 数组是如何求出的</strong></h2><p>next 数组的求解基于 “前缀” 和“后缀”，即<code>next[j]</code>等于<code>P[0]...P[j-1]</code>最长的相同前后缀的长度（请暂时忽视 j 等于 0 时的情况，下面会有解释）。我们依旧以上述的表格为例，为了方便阅读，我复制在下方了。</p><div class="table-responsive"><table><thead><tr><th align="center">               j</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">A</td><td align="center">B</td><td align="center">D</td><td align="center">'\0'</td></tr><tr><td align="center">next[j]</td><td align="center">-1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td></tr></tbody></table></div>（1）j=0，对于模式串的首字符，我们统一为`next[0]=-1`；（2）j=1，前面的字符串为`A`，其最长相同前后缀长度为 0，即`next[1]=0`；（3）j=2，前面的字符串为`AB`，其最长相同前后缀长度为 0，即`next[2]=0`；（4）j=3，前面的字符串为`ABC`，其最长相同前后缀长度为 0，即`next[3]=0`；（5）j=4，前面的字符串为`ABCD`，其最长相同前后缀长度为 0，即`next[4]=0`；（6）j=5，前面的字符串为`ABCDA`，其最长相同前后缀为`A`，即`next[5]=1`；（7）j=6，前面的字符串为`ABCDAB`，其最长相同前后缀为`AB`，即`next[6]=2`；（8）j=7，前面的字符串为`ABCDABD`，其最长相同前后缀长度为 0，即`next[7]=0`。那么，为什么根据最长相同前后缀的长度就可以实现在不匹配情况下的跳转呢？举个代表性的例子：假如`j=6`时不匹配，此时我们是知道其位置前的字符串为`ABCDAB`，仔细观察这个字符串，首尾都有一个`AB`，既然在`j=6`处的 D 不匹配，我们为何不直接把`j=2`处的 C 拿过来继续比较呢，因为都有一个`AB`啊，而这个`AB`就是`ABCDAB`的最长相同前后缀，其长度 2 正好是跳转的下标位置。有的读者可能存在疑问，若在`j=5`时匹配失败，按照我讲解的思路，此时应该把`j=1`处的字符拿过来继续比较，但是这两个位置的字符是一样的啊，都是`B`，既然一样，拿过来比较不就是无用功了么？其实不是我讲解的有问题，也不是这个算法有问题，而是这个算法还未优化，关于这个问题在下面会详细说明，不过建议读者不要这里纠结，跳过这个，下面你自然会恍然大悟。思路如此简单，接下来的问题就是代码实现了，如下：<pre class="lang:c++ decode:true" title="GetNext">/* P为模式串，下标从0开始 */void GetNext(string P, int next[]){    int p_len = P.size();    int i = 0;   //P的下标    int j = -1;  //共有元素长度    next[0] = -1;<pre><code>while (i &amp;lt; p_len){    if (j == -1 || P[i] == P[j])    {        i++;        j++;        next[i] = j;    }    else        j = next[j];}</code></pre><p>}</p></pre><br>&nbsp;<p></p><p>一脸懵逼，是不是。。。<br>上述代码是求解每个位置的 next 值，即求解每个位置前面字符串的最长相同前后缀的长度。下面具体分析，我把代码分为 3 部分来讲：<br><strong>（1）i 的作用是什么？</strong><br>i 为模式串 P 的下标，从 0 开始，程序中我们依次求出<code>next[i]</code>的值，这很简单。<br><strong>（2）j 的作用是什么？</strong><br>从<code>next[i]=j;</code>可以很容易推断出，j 代表前后缀最长共有元素的长度。<br><strong>（3）if…else… 语句里做了什么？</strong><br>首先我们必须要明确一个事实：若此时<code>i=3</code>，那我们接下来要求解的便是<code>P[0]...p[3]</code>的最长相同前后缀的长度，也就是<code>next[4]</code>，而非<code>next[3]</code>，这从下面的代码就可以得到证明：</p><pre class="lang:c++ decode:true" title="for">i++;j++;next[i] = j;</pre><p>有了这个事实，下面具体分析：<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95__14-1024x328.png" alt></p><p>假设 i 和 j 的位置如上图，由<code>next[i]=j</code>得，也就是对于位置 i 来说，区段** 0 到 i-1** 的最长相同前后缀分别是** 0 到 j-1** 和** i-j 到 i-1**，即这两区段内容相同。<br>按照算法流程，<code>if(P[i]==P[j])</code>，则<code>i++;j++;next[i]=j;</code>；若不等，则<code>j=next[j]</code>，见下图：<img src="/images/2017/04/KMP%E7%AE%97%E6%B3%95___15-1024x328.png" alt></p><p><code>next[j]</code>的含义是** 0 到 j-1** 区段中最长相同前后缀的长度，如图，用左侧两个椭圆来表示最长相同前后缀，即这两个椭圆代表的区段内容相同；同理，右侧也有相同的两个椭圆。所以 else 语句就是利用第一个椭圆和第四个椭圆内容相同来加快得到** 0 到 i-1** 区段的相同前后缀的长度。<br>细心的朋友会问 if 语句中<code>j==-1</code>存在的意义是何？第一，程序刚运行时，j 是被初始为 - 1，直接进行<code>P[i]==P[j]</code>判断无疑会报错；第二，else 语句中<code>j=next[j]</code>，j 是不断后退的，若 j 在后退中被赋值为 - 1（也就是 j=next[0]），在<code>P[i]==P[j]</code>判断也会报错。综上两点，其意义就是为了特殊边界判断。</p><h1 id="四：完整代码"><a href="#四：完整代码" class="headerlink" title="四：完整代码"></a><strong>四：完整代码</strong></h1><pre class="lang:c++ decode:true" title="All_KMP">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;/* P为模式串，下标从0开始 */void GetNext(string P, int next[]){    int p_len = P.size();    int i = 0;   //P的下标    int j = -1;  //共有元素长度    next[0] = -1;    while (i &lt; p_len)    {        if (j == -1 || P[i] == P[j])        {            i++;            j++;            next[i] = j;        }        else            j = next[j];    }}/* 在S中找到P第一次出现的位置 */int KMP(string S, string P, int next[]){    GetNext(P, next);    int i = 0;  //S的下标    int j = 0;  //P的下标    int s_len = S.size();    int p_len = P.size();    while (i &lt; s_len &amp;&amp; j &lt; p_len)    {        if (j == -1 || S[i] == P[j])  //P的第一个字符不匹配或S[i] == P[j]        {            i++;            j++;        }        else            j = next[j];  //当前字符匹配失败，进行跳转    }    if (j == p_len)  //匹配成功        return i - j;    return -1;}int main(){    int next[100] = { 0 };    cout &lt;&lt; KMP("bbc abcdab abcdabcdabde", "abcdabd", next) &lt;&lt; endl; //15    return 0;}</pre><h1 id="五：KMP-优化"><a href="#五：KMP-优化" class="headerlink" title="五：KMP 优化"></a><strong>五：KMP 优化</strong></h1><div class="table-responsive"><table><thead><tr><th align="center">               j</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">A</td><td align="center">B</td><td align="center">D</td><td align="center">'\0'</td></tr><tr><td align="center">next[j]</td><td align="center">-1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td></tr></tbody></table></div>以 3.2 的表格为例（已复制在上方），若在`j=5`时匹配失败，按照 3.2 的代码，此时应该把`j=1`处的字符拿过来继续比较，但是这两个位置的字符是一样的，都是`B`，既然一样，拿过来比较不就是无用功了么？这我在 3.2 已经解释过，之所以会这样是因为 KMP 不够完美。那怎么改写代码就可以解决这个问题呢？很简单。<pre class="lang:c++ decode:true " title="GetNextval">/* P为模式串，下标从0开始 */void GetNextval(string P, int nextval[]){    int p_len = P.size();    int i = 0;   //P的下标    int j = -1;  //共有元素长度    nextval[0] = -1;<pre><code>while (i &amp;lt; p_len){    if (j == -1 || P[i] == P[j])    {        i++;        j++;        if (P[i] != P[j])            nextval[i] = j;        else            nextval[i] = nextval[j];  //既然相同就继续往前找前缀    }    else        j = nextval[j];}</code></pre><p>}</p></pre><br>&nbsp;<p></p><p>在此也给各位读者提个醒，KMP 算法严格来说分为 KMP 算法（未优化版）和 KMP 算法（优化版），所以建议读者在表述 KMP 算法时，最好告知你的版本，因为两者在某些情况下区别很大，这里简单说下。<br><strong>KMP 算法（未优化版）：</strong> next 数组表示最长的相同前后缀的长度，我们不仅可以利用 next 来解决模式串的匹配问题，也可以用来解决类似字符串重复问题等等，这类问题大家可以在各大 OJ 找到，这里不作过多表述。<br><strong>KMP 算法（优化版）：</strong> 根据代码很容易知道（名称也改为了 nextval），优化后的 next 已不再表示最长的相同前后缀的长度，此时我们利用优化后的 next 可以在模式串匹配问题中以更快的速度得到我们的答案（相较于未优化版）。</p><blockquote><p>转载自KMP算法-刘毅 <a href="http://www.61mon.com/index.php/archives/183/" target="_blank" rel="noopener">http://www.61mon.com/index.php/archives/183/</a></p><p>更直白易懂的算法讲解可参考（无算法实现）：阮一峰 <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">KMP算法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postfix、Dovecot搭建邮箱</title>
      <link href="/2017/04/05/Postfix-Dovecot-Build-Mailserver/"/>
      <url>/2017/04/05/Postfix-Dovecot-Build-Mailserver/</url>
      
        <content type="html"><![CDATA[<p>本着为了一些需要邮箱服务的程序（Denyhost）方便，随便搭建了一个本地的postfix邮箱服务器，但是又想着搭都既然搭了干脆再折腾下让它能真正用起来。献上可爱的postfix图片一张。<img src="/images/2017/04/postfix.jpg" alt></p><a id="more"></a><p><strong>邮箱工作过程：</strong></p><hr><p>在搭建邮箱服务器时我也是莫名跟着各种教程，但因为各方教程的目标、时间、软件版本不同导致稀里糊涂走了很多弯路。所以首先应该了解的是邮件系统本身是怎么样的？</p><p><img src="/images/2017/04/Mail.png" alt></p><p>具体MTA、MUA、MSA、MDA专有名词解释可参考 <a href="http://www.docin.com/p-483517859.html" target="_blank" rel="noopener">电子邮箱系统组成部分</a></p><p>&nbsp;</p><p><strong>开始之前：</strong></p><hr><ul><li><strong>Postfix:</strong> 是一个标准的MTA「Mail Transfer Agent」服务器，它负责通过SMTP协议管理发送到本机的邮件以及由本机发向外界的邮件。在本例中，Postfix会把邮件的本地投递工作「接受到邮件之后将邮件存档到本地磁盘」交给Dovecot的<strong>LMTP</strong>服务「Local Mail Transfer Protocol service」处理。当然，当大家想通过服务器向外界发送邮件时，Postfix还将负责验证权限以确保服务器不被滥用。「很多邮件服务器根本没有对SMTP做用户验证，这将导致任何匿名用户都可以通过服务器向外界发送邮件，从而使得服务器变成垃圾中转站」</li><li><strong>Dovecot:</strong> 是一个非常优秀的IMAP/POP服务器用以接收外界发送到本机的邮件。通常，Dovecot的工作内容包括：验证用户身份以确保邮件不会被泄露。在本例中，Dovecot将负责所有的「身份验证」工作，我们会配置Dovecot查询本地的MySQL数据库以确认用户身份</li><li><strong>MySQL:</strong> 不必多说，它将存储所有的用户信息，其中包括：需要监听的域名信息、用户邮箱地址、登录密码、邮箱别名「alias」等</li><li><strong>Ubuntu:</strong> 本例中的OS将选择Ubuntu16.04作为标准，其他Linux发行版的相关操作不在描述<br>&nbsp;</li></ul><p><strong>动手配置：</strong></p><hr><p>本人参考的是Linode文档中 <a href="https://www.linode.com/docs/email/postfix/email-with-postfix-dovecot-and-mysql" target="_blank" rel="noopener">Email with Postfix,Dovecot,and MySQL</a></p><p>这篇更中文友好且有原理配图 <a href="https://my.oschina.net/barat/blog/413923" target="_blank" rel="noopener">Postfix+Dovevot+MySQL搭建邮箱服务器</a></p><p>没错如果要问我为什么不自己写，既然有写的又好又全面的文档干嘛不用。</p><p>&nbsp;</p><p><strong>配置过程的坑：</strong></p><hr><ul><li><p>postfix的main.cf配置文件中，别忽略这行配置</p><p> mydestination= localhost`<br>后面参数只需localhost，多了会造成Postfix投递Dovecot的LMTP服务不正常</p></li><li><p>SSL证书可以使用Letsencrypt免费证书，配置过程同给Apache等服务器配置一样，只需要将Letsencrypt生成的证书拷贝到你需要的路径即可</p><pre>`smtpd_tls_cert_file=/etc/dovecot/dovecot.pemsmtpd_tls_key_file=/etc/dovecot/private/dovecot.pem`</pre></li><li><p>可以使用telnet 命令检查端口是否正常开放（谁知道你有没有默认的iptables firewall 拦截了某些端口）</p><pre class="lang:sh decode:true " title="send email using telnet">#连接目标主机端口telnet example.com 25#返回了220 及邮件服务器exmaple.com postfix#表示服务器端口开启正常#打招呼ehlo example.com#返回一系列250-#表示个服务正常</pre><p>当然你也可以使用telnet命令发送、查收邮件，参考 <a href="https://mediatemple.net/community/products/dv/204404584/sending-or-viewing-emails-using-telnet" target="_blank" rel="noopener">SENDING OR VIEWING EMAILS USING TELNET</a></p></li><li><p>能收到外服务器发来的邮件，但往外邮件服务器发邮件一直连接超时？</p><pre>`Mar 26 15:33:03 mail postfix/smtp[30204]: connect to mx3.qq.com[183.57.48.35]:25: Connection timed outMar 26 15:33:33 mail postfix/smtp[30204]: connect to mx2.qq.com[183.60.15.138]:25: Connection timed outMar 26 15:34:03 mail postfix/smtp[30204]: connect to mx2.qq.com[14.17.41.170]:25: Connection timed out`</pre><p>首先查看iptables的配置确保没有阻塞关键端口</p><pre>`sudo iptables -L</pre></li></ul><p>如果没有什么异常的话，那可能是你的主机提供商给你封了目标端口25的ip包，尝试申请开启，如果未果那可能就要使用别的邮箱服务器代投。</p><ul><li>最后提醒：好习惯日常备份<br>&nbsp;</li></ul><p><strong>使用Rainloop搭建WebMail</strong><!--more--></p><p>没错就算是搭建好服务器以后，你看到的邮件、操作邮件的命令依然是苍白的命令行。这时就需要搭建一个高大上WebMail来帮你管理邮件。</p><p><img src="/images/2017/04/rainlopp-1024x576.png" alt></p><p>rainloop是个php语言开发的精简、美观的WebMail，在官网<a href="http://www.rainloop.net" target="_blank" rel="noopener">www.rainloop.net</a>可以下载到最新版本。</p><p>按照<a href="http://www.rainloop.net/docs/installation/" target="_blank" rel="noopener">配置文档</a>安装完成后，输入网址后面加上/?admin 即可进入后台管理界面，在域名菜单栏中添加你的服务器所在域名即可使用。另外还有丰富的插件包支持。</p><p><a href="https://mail.zhongm.in" target="_blank" rel="noopener"><img src="/images/2017/04/rainloop2-1024x560.png" alt></a></p><p>这样就有了属于自己的邮箱服务器及webmail。感觉还不错，附上自己的Webmail <a href="https://mail.zhongm.in" target="_blank" rel="noopener">https://mail.zhongm.in</a></p><p>关于postfix 的详细配置，可参见postfix 文档 <a href="http://www.postfix.org/documentation.html" target="_blank" rel="noopener">http://www.postfix.org/documentation.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Postfix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell学习--GitHub刷存在</title>
      <link href="/2017/03/20/Learning-Shell-Notes/"/>
      <url>/2017/03/20/Learning-Shell-Notes/</url>
      
        <content type="html"><![CDATA[<p>一个小小的脚本，能够自动提交GitHub，将你的帐号的图表刷成绿色的。</p><p><img src="/images/2017/03/github.jpg" alt></p><a id="more"></a><p>只需在GitHub仓库中有这个脚本，就能自动签到（懒人行为: -) ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Author: kingcc&amp;lt;laikinfox@gmail.com&amp;gt;</span></span><br><span class="line"><span class="comment"># Date  : 2016/10/1</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###Redesign for myself :)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line"><span class="comment">#日志目录可修改成自己的</span></span><br><span class="line">DIR=<span class="string">"<span class="variable">$( cd "$( dirname "$0"  )</span>"</span> &amp;amp;&amp;amp; <span class="built_in">pwd</span>  )<span class="string">"</span></span><br><span class="line"><span class="string">PRO="</span><span class="variable">$DIR</span>/GreenGraphrun.sh<span class="string">"</span></span><br><span class="line"><span class="string">LOG="</span>/home/zmvps/git.log<span class="string">"</span></span><br><span class="line"><span class="string">CMD="</span>00 00 * * * <span class="variable">$PRO</span>&amp;gt;&amp;gt;<span class="variable">$LOG</span> 2&amp;gt;&amp;amp;1<span class="string">"</span></span><br><span class="line"><span class="string">echo "</span><span class="variable">$CMD</span><span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#启动密钥管理器，并添加密钥</span></span><br><span class="line"><span class="string">cd <span class="variable">$DIR</span></span></span><br><span class="line"><span class="string">eval "</span>$(ssh-agent -s)<span class="string">"</span></span><br><span class="line"><span class="string">ssh-add</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#循环提交</span></span><br><span class="line"><span class="string">commits=<span class="variable">$(($RANDOM%20+1)</span>)</span></span><br><span class="line"><span class="string">i=0</span></span><br><span class="line"><span class="string">while((<span class="variable">$i</span>&amp;lt;<span class="variable">$commits</span>))</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">commitTimesp=`sed -n '/run/p' ./README.md`</span></span><br><span class="line"><span class="string">commitTimesh=<span class="variable">$&#123;commitTimesp#*run &#125;</span></span></span><br><span class="line"><span class="string">commitTimes=<span class="variable">$&#123;commitTimesh% times.&#125;</span></span></span><br><span class="line"><span class="string">sed -i "</span>s/<span class="variable">$commitTimes</span>/$((<span class="variable">$commitTimes</span>+1))/<span class="string">" ./README.md</span></span><br><span class="line"><span class="string">git add -A &amp;amp;&amp;amp; git commit -m "</span>$((<span class="variable">$commitTimes</span>+1))<span class="string">"</span></span><br><span class="line"><span class="string">i=<span class="variable">$(($i+1)</span>)</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">git push origin master</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#配置crontab，定时运行</span></span><br><span class="line"><span class="string">(crontab -l 2&amp;gt;/dev/null | grep -Fv <span class="variable">$PRO</span>; echo "</span><span class="variable">$CMD</span><span class="string">") | crontab -</span></span><br><span class="line"><span class="string">pkill -8 ssh-agent</span></span><br><span class="line"><span class="string">cd ~</span></span><br></pre></td></tr></table></figure><p>README.md</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This script has run 1 <span class="built_in">times</span>.</span><br></pre></td></tr></table></figure><h2 id="Shell学习及踩坑记："><a href="#Shell学习及踩坑记：" class="headerlink" title="Shell学习及踩坑记："></a>Shell学习及踩坑记：</h2><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><ul><li>用于设置周期性执行的命令，各用户配置文件均在 <code>/var/spool/cron/crontabs</code></li><li>创建及编辑 <code>crontab -e [username]</code></li><li>需要添加计划只需在配置文件添加一行，格式如[执行频率  用户 程序]，频率如</li></ul><table style="height: 423px; font-size: 14px;" border="0" summary="Example timetables for cron jobs" width="620" cellspacing="0" cellpadding="0"><thead><tr><th>分</th><th>小时</th><th>月中日</th><th>月份</th><th>周中日期</th><th>说明</th></tr></thead><tbody><tr><td>`0`</td><td>`1`</td><td>`15`</td><td>`1,11`</td><td>`*`</td><td>在 1、 和 11 月的 15 日的 1 a.m. 运行命令。也可以把这个时间表写成 ` 0 1 15 jan,nov *`。不要在逗号后面加空格。</td></tr><tr><td>`0-59/15`</td><td>`*`</td><td>`*`</td><td>`*`</td><td>`*`</td><td>这个调度计划每 15 分钟运行命令一次。</td></tr><tr><td>`30`</td><td>`*`</td><td>`*`</td><td>`*`</td><td>`wed,fri`</td><td>这个时间表只在星期三和星期五每小时的 30 分时执行命令一次。（在列表中可以使用日和月份的名称，但是在范围中不可以）。</td></tr><tr><td>`0,30`</td><td>`0-5,17-23`</td><td>`*`</td><td>`*`</td><td>`*`</td><td>在午夜到 5 a.m. 以及 7 p.m. 到 11 p.m. 之间整点时和 30 分时运行命令。</td></tr><tr><td>`0`</td><td>`0`</td><td>`1`</td><td>`1`</td><td>`*`</td><td>在每年 1 月 1 日午夜执行命令一次。</td></tr><tr><td>`0`</td><td>`0`</td><td>`*`</td><td>`*`</td><td>`0`</td><td>在每个星期日午夜运行命令。这相当于每周一次。</td></tr><tr><td>`30`</td><td>`0`</td><td>`10,20,30`</td><td>`*`</td><td>`6`</td><td>因为月中日和周中日受到限制，这个时间表在每星期六和每月的 10、20 和 30 日（二月除外）的 12:30 a.m. 运行命令。</td></tr></tbody></table><h3 id="小坑："><a href="#小坑：" class="headerlink" title="小坑："></a>小坑：</h3><ul><li>crontab 预定义5个环境变量（其中PATH=/usr/bin:/bin SHELL=/bin/sh），故使用crontab执行周期指令时因为PATH 而报错，或程序中的一些指令在sh不支持（如上文中的$RANDOM）。解决方法分别是 1、在脚本前加入<code>./etc/profile .~/.bash_profile</code> 等并使用绝对路径的；2、在配置文件前添加一行 <code>SHELL=/bin/bash</code></li><li>crontab 默认并没有在日志服务中开启，编辑 <code>/etc/rsyslog.d/20-default.conf</code> 去掉cron前的#号，并重启rsyslog服务即可为cron开启日志服务，目录在 <code>/var/log/cron.log</code> 。</li><li>当写 crontab 时，如果命令中有 % 号的时候，需要使用\转移，否则计划任务会执行失败<br>参考 IBM 使用cron进行自动维护 <a href="https://www.ibm.com/developerworks/cn/education/aix/au-usingcron/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/aix/au-usingcron/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Java 容器类（Set、List、Map）</title>
      <link href="/2017/02/28/Container-Classes-Java/"/>
      <url>/2017/02/28/Container-Classes-Java/</url>
      
        <content type="html"><![CDATA[<p>Java.util中有许多经常能用到的又好用的容器类。就让我们来缕一缕其中的关系。</p><p><img src="/images/2017/02/image1.png" alt></p><a id="more"></a><p>根据上图我们详细地看到各个容器类的之间的继承，和实现关系。</p><p>也许有人要问：我知道的Array怎么没在这？</p><p>没错，<em>数组的确也是常用的数据结构，但是其只能放基本数据类型，所以并算不是容器类。（值得一提的是java.util包中确实有一个Arrays类，其中包含许多针对基本类型数组 [] 的静态实用工具方法，而在java.lang.reflect包中也有一个Array类，其中也包含了访问及创建数组的静态方法，只不过对基本类型数组和集合型数组都可用）</em></p><pre class="lang:java decode:true" title="Arrays&amp;Array">import java.reflect.Array;import java.util.*;//仅为展示，跳过步骤ArrayList&lt;Integer&gt; arr=new ArrayList&lt;Integer&gt;();int [] arr2=new int[5];//类Array访问数组，对两者皆有效int get2=Array.getInt(arr.2);//get2  =Array.getInt(arr2.2);//工具类Arrays 折半查找get2  =Arrays.binarySearch(arr, 2);</pre><p>从上图可以了解到，Collection和Map是Java容器中两个基本数据类型。这两者的区别也很明确：</p><ul><li><blockquote><p>Collection 单列集合，即每个位置只能保存一个元素。</p></blockquote></li><li><blockquote><p>Map 双列集合，以键值对映射的形式存储，且不能包含重复的键、每个键最多只能映射一个值。<br>上面两种均是接口，不能实例化。同样为接口的还有Set、List。</p></blockquote></li><li><blockquote><p>Set （集）即是一组没有重复对象的集合（不一定是有序）。</p></blockquote></li><li><blockquote><p>List （链表）其实和数组一样是相当基础数据结构，上一个元素指向下一个元素。<br>接下来才是我们常使用到的容器类：</p></blockquote></li><li><p>ArrayList</p></li><li><p>LinkList</p></li><li><p>Vector</p></li><li><p>HashSet</p></li><li><p>TreeSet</p></li><li><p>HashTable</p></li><li><p>HashMap</p></li><li><p>TreeMap<br>&nbsp;</p></li></ul><h1 id="ArrayList、LinkList、Vector"><a href="#ArrayList、LinkList、Vector" class="headerlink" title="ArrayList、LinkList、Vector"></a>ArrayList、LinkList、Vector</h1><p>这三兄弟都实现了List接口，而其中 ArrayList、Vector两者则都是基于Array的List。具体的功能和异同：</p><p><strong>ArrayList</strong>：也叫动态数组，继承自AbstractList类，实现List接口</p><ul><li><p>其大小可以动态地增加、减少，也可以随着放入的元素而增加大小（当然你也可以在构造的时候指定大小）</p></li><li><p>可以放置不同类型、重复的对象（这样不方便使用）</p></li><li><p>其维护插入顺序（根据检索），但是随机访问（基于内存）</p></li><li><p>函数并不是同步加锁的</p></li><li><p><em>Vector*</em>：也叫向量类</p></li><li><p>其大小也是可以动态地变化</p></li><li><p>可以放置不同类型、重复的对象</p></li><li><p>同样也是维护插入顺序</p></li><li><p>维护插入顺序，同样也是随机访问（这是Vector、ArrayList通过检索访问速度快的优势）</p></li><li><p>函数实现了同步加锁（线程安全）</p></li><li><p><em>LinkList*</em>：是继承于AbstractSequentialList的双向链表（大小可变），实现List、Deque、Queue接口</p></li><li><p>可以被当作堆栈、队列或双端队列（实现了接口）</p></li><li><p>维护插入顺序（基于检索），但是顺序访问（链表性质：顺序访问速度快，检索访问速度慢）</p></li><li><p>可以放置不同类型、重复的对象</p></li><li><p>函数不是同步的</p></li></ul><h1 id><a href="#" class="headerlink" title></a><img src="/images/2017/02/map.jpg" alt></h1><h1 id="HashMap、TreeMap、HashTable"><a href="#HashMap、TreeMap、HashTable" class="headerlink" title="HashMap、TreeMap、HashTable"></a>HashMap、TreeMap、HashTable</h1><p>这三者都实现了Map接口，都是以键值对形式存储元素，同时这三者也是将键的值作为自变量，使用一套算法计算值的存储位置以实现键值对映射，和解决冲突。均可放置不同类型的，不重复的对象。</p><p><strong>HashTable</strong>：也叫哈希表，扩展了Dictionary类</p><ul><li><p>包含唯一的元素，其键和值都不能为空</p></li><li><p>函数是同步加锁的</p></li><li><p>遍历时可以使用Enumeration，也可以使用Iterator</p></li><li><p><em>HashMap*</em>：和哈希表很相似，哈希值的处理方法</p></li><li><p>最多只允许一条记录的键为空，允许多条记录的值为空</p></li><li><p>遍历时使用Iterator</p></li><li><p>函数不是同步加锁的</p></li><li><p><em>TreeMap*</em>：和前两者最大不同就是可以保存插入顺序</p></li><li><p>TreeMap能够把它保存的记录根据键排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p></li><li><p>最多只允许一条记录的键为空，允许多条记录的值为空</p></li><li><p>函数并不是同步的</p></li><li><p>遍历时也是使用Iterator</p></li></ul><h1 id="HashSet、TreeSet"><a href="#HashSet、TreeSet" class="headerlink" title="HashSet、TreeSet"></a>HashSet、TreeSet</h1><p>这两者都是实现了Set接口。均可放置不同类型的对象。</p><p><strong>HashSet</strong>：扩展了AbstractSet，并实现了Set接口。</p><ul><li><p>既不允许存储相同的元素，也不保存元素的顺序</p></li><li><p>基于HashMap实现的，将其中的值存储了一个 PRESENT，它是一个静态的 Object 对象</p></li><li><p>检索速度快，遍历时使用Iterator</p></li><li><p>函数不是同步的</p></li><li><p><em>TreeSet*</em>：和上面HashMap、TreeMap之间关系很像。</p></li><li><p>不允许存储相同的元素，但是能保存元素的顺序</p></li><li><p>函数不同步<br>仅为整理关系，提供选择资料，不提供各容器类方法注记。</p></li></ul><p>2017-03-20 更新：自己用脑洞图画的关系图（包含Java中基本数据结构）<img src="/images/2017/03/Collection.png" alt></p><p>相关资料：</p><p>HashSet用法：<a href="http://blog.csdn.net/tingzhiyi/article/details/52152487" target="_blank" rel="noopener">http://blog.csdn.net/tingzhiyi/article/details/52152487</a></p><p><a href="http://www.blogjava.net/angelloveme/archive/2011/08/10/356242.html" target="_blank" rel="noopener">HashMap,HashTable,TreeMap区别和用法</a></p><p>Map总结：<a href="http://www.chawenti.com/articles/20110.html" target="_blank" rel="noopener">http://www.chawenti.com/articles/20110.html</a></p><p><a href="http://mrbool.com/overview-of-java-arraylist-hashtable-hashmap-hashetlinkedlist/30383" target="_blank" rel="noopener">Java 容器类讲解</a></p><p>API:<a href="http://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener"> http://docs.oracle.com/javase/8/docs/api/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wordpress 搬家笔记</title>
      <link href="/2017/02/23/Wordpress-Migrate-Notes/"/>
      <url>/2017/02/23/Wordpress-Migrate-Notes/</url>
      
        <content type="html"><![CDATA[<p>继PC上Ubuntu系统崩溃（鼠标无法使用、网卡无法启动），我的博客也祸不单行地崩了一天（在那小的可怜的虚拟主机上）。于是开始打算着，把博客搬到自己的几块钱一个月ECS（就这便宜货也隔三岔五有人想黑）上，这样怎么说也算掌控在自己手中。<strong>搬家开始！！！</strong></p><p><strong><img src="/images/2017/02/wordpress.jpg" alt></strong></p><a id="more"></a><p>在中文官网上有关于搬站的教程。<a href="https://codex.wordpress.org/zh-cn:WordPress博客搬家" target="_blank" rel="noopener">zh-cn:WordPress 博客搬家</a></p><p>而我们属于将WordPress迁移到新的服务器，算是最简单的一种。</p><p>只需几个步骤：</p><ol><li>安装一个新的Wordpress博客（可从官网下载）</li><li>进入旧的管理面板，进入工具 &gt; 导出，在菜单”限定作者“中选择”所有作者”。点击下载导出的文件</li><li>在新博客中进入工具 &gt; 导入， 选择 Wordpress 选项</li><li>在接下来的页面中，选择文件导出，点击上传文件然后导入。</li><li>接下来会显示一个页面。在分配作者中，在已存在的使用者中分配一个作者或者创建一个新的。</li><li>点击提交，即完成。</li></ol><p><strong>接着我们来细数踩过的坑：</strong></p><p>环境安装自然不比多说：Ubuntu 16.04  Apache2.4.18  Mysql5.7.17  PHP7</p><p>其中需要注意的是开启Apache rewrite模块：</p><pre class="lang:sh decode:true" title="Apache rewrite">#Shell输入a2再双击tab可以看到一些有用的命令a2enmod rewrite</pre><hr><p><strong>在步骤1安装Wordpress：</strong></p><p>首先将解压后的目录放在<code>/var/www</code>下或者其中的/html下也行。</p><p>然后开始在Mysql中随便创建一个数据库。之后将这些相应的信息填写到wp-config.php相应的define中（只有wp-config-sample.php?没错就是它，把它改下名即可）。</p><p>修改Apapche 相应的配置文件：</p><p>将<code>/etc/apache2/site-avaliable/defauilt.conf</code>（目录名或文件名有所出入，但大致一样）其中的<code>ServerName</code>改为自己的域名（没域名可不填）、<code>DocumentRoot</code>改为存放Wordpress解压目录的路径，例如：<code>/var/www/html/wordpress</code></p><p>之后重启Apache（逢修改都需操作），访问所在主机地址即可进入安装界面。（如若发生404错误请查看上述路径是否正确）</p><hr><p><strong>在步骤3选择Wordpress选项需要ftp密码：</strong></p><p>在wp-config.php中添加下列代码：</p><pre class="lang:php decode:true" title="wp-config.php">define("FS_METHOD","direct");define("FS_CHMOD_DIR", 0777);define("FS_CHMOD_FILE", 0777);</pre><p>之后便不会弹出上述FTP问题，但是有时在你安装插件时还是会出现一个问题：<strong>无法创建文件</strong></p><p>归根结底还是Linux权限问题，为了一劳永逸你可以将网站所在目录权限值修改：</p><pre class="lang:sh decode:true" title="wordpress-right">#开放所有用户权限sudo chmod -R 775 wordpress/#亦可通过权限组解决(www-data为系统默认)sudo chown -R root:www-data wordpress/sudo chmod -R 775 wordpress/</pre><p>之后照例重启Apache服务器。</p><hr><p><strong>导入后能看到主页但是点开文章显示出错：</strong></p><p>这是因为Wordpress开启了固定链接功能（利于SEO和静态插件），而你从原来博客上导入的链接现在不可用了。</p><p>解决：只需在仪表盘中设置-&gt;固定链接-&gt;常用设置里改动，并保存修改即可。</p><p>刷新你的首页，再点击文章就可看到有效了。</p><p>如果还是弹出404错误则需一步步检查，拍错：</p><ol><li>确定步骤一中Apache配置文档DocumentRoot指向的路径无误</li><li>确定已开启rewrite模块</li><li>确定wordpress所在目录权限问题（如上）</li><li>AllowOverride Not Enabled，推荐不修改全局配置apache.conf。而是在自己的网站配置文件中添加：<pre class="lang:default decode:true " title="allowoverride">#路径根据自己网站修改&lt;Directory /var/www/html/wordpress&gt;Options FollowSymLinksAllowOverride All&lt;/Directory&gt;</pre></li></ol><hr><p><strong>80端口遭封，改81端口：</strong></p><p><span style="color: #00ff00;">到现在坑应该没了吧，可以愉快的写东西了吧！我当时也这么想的 : )</span></p><p><span style="color: #00ff00;"><del>然而阿里爸爸立马就把我80端口封了！</del>哦不，怎么能这么说封，是被和谐了XD</span></p><p>没事，我们继续折腾。开个81端口接着搞</p><p>修改Apache监听端口：</p><ol><li>将文件/etc/apache2/ports.conf中的Listen 80 改成 81</li><li>将文件/etc/apache2/site-avaliable/dedault.conf 中的VirtualHost *:80 也该为81<br>之后照常重启，浏览器输入域名或者IP，后面加上:81，可以用啦！</li></ol><hr><p><strong>配置HTTPS：</strong></p><p>换了端口，加了:81 嫌逼格不够高？没https？</p><p>没关系我们接着折腾。先普及证书和CA知识，这是_编程随想_（膜拜）的一篇博文：<a href="http://kb.cnblogs.com/page/194742/" target="_blank" rel="noopener">http://kb.cnblogs.com/page/194742/</a></p><p>此处为cnblog地址，原文地址不翻墙看不到 : (</p><p>之后查阅了各种配置博客，但都因时间，版本参差不齐折腾的很痛苦。</p><p>总结就是：</p><ul><li><p>知名的免费证书有：StartSSL，Let’s Encrypt，COMODO。郑重严肃地推荐<strong>别用</strong>StartSSL免费证书，因为已经<strong>不被Google、Mozilla信任</strong>。（可怜的我折腾半天以为自己错了）。推荐使用Let’s Encrpyt，自动部署无需配置，太爽了！</p></li><li><p>SSL配置文档默认是在/etc/apache2/site-avaliable/default-ssl.config，像上述那样修改DocumentRoot和ServerName。</p></li><li><p>此外还需修改文档中的一些证书设置（均填绝对路径，证书存放路径无所谓）：<br>&nbsp;</p><blockquote><p><em>SSLCertificateFile–服务器证书（可以是完整证书链，格式可为pem,crt）</em></p><p><em>SSLCertificateKeyFile–服务器密钥证书（格式可为pem、key）</em></p><p><em>SSLCertificateChainFile–服务器证书链文件（如果1为完整证书链，可省略或和其相同）</em><br>还有一些证书配置，但这三个足以。（一般发送CSR 后CA  会将1 ，3发送给你）</p></blockquote></li></ul><p>配置好后，照常重启。</p><hr><p><strong>HTTPS重定向出错：</strong></p><p>如果你和我一样（处于艰难的网络管辖下XD）是通过放弃80端口建立的博客。</p><p>那么可能会遇到和我一样的问题。</p><p>明明已经配置好https，但是访问时自动跳转成如下地址栏：</p><pre class="lang:default decode:true " title="Error">#输入的https://zhongm.in#自动跳转到(可能你的不是81)https://zhongm.in:81</pre><p>结果显示连接失败（非443端口使用https协议肯定失败），为什么会这样呢？</p><p>其实还是WordPress固定链接的问题（它将自己的链接转变成https链接时并没有去除其中的:81，所以导致这样的错误跳转）。</p><p>解决方法（修改WordPress目录wp-includes/下 link-template.php代码）：</p><pre class="lang:php decode:true" title="link-template.php">//找到代码3419行开始的set_utl_scheme()//将代码3438行开始的else中内容添加两行，如下}else{      if($scheme === 'https')              $url = str_replace(':81','',$url);      $url = preg_replace( '#^\w+://#', $scheme . '://', $url );}</pre><p>当然，另一种更直接的解决方式就是完全放弃http，强制所有访问都走https。只需在配置文件中添加：</p><pre class="lang:default decode:true" title="forcehttps">#将其中域名换成自己的RewriteEngine onRewriteCond %{SERVER_NAME} =zhongm.inRewriteRule ^ https://%{SERVER_NAME}%{REQUEST_URI} [END,QSA,R=permanent]</pre><p>当然在博客中的常规设置中，将网站URL设置成https 也一样的效果</p><p>照常重启，就能见到漂亮的URL，和高逼格的https绿色锁。<img src="/images/2017/02/wordpress2.png" alt></p><p>网上SSL、Apache 配置参差不齐，小伙伴们找准版本。</p><p>Apache HTTP 服务器2.4文档：<a href="http://httpd.apache.org/docs/2.4/" target="_blank" rel="noopener">http://httpd.apache.org/docs/2.4/</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>都应该懂点的那些--Docker</title>
      <link href="/2017/02/01/Docker-Everyone-Should-Know/"/>
      <url>/2017/02/01/Docker-Everyone-Should-Know/</url>
      
        <content type="html"><![CDATA[<p><code>Docker</code>是一个开源的应用容器虚拟化平台。具体做的就是快速的帮助开发者搭建应用周期里所需的各种环境，快速地部署项目以缩短开发周期。正是<code>Docker</code>给应用开发带来的高效率，使其在短短几年便越发地火热，项目也日趋成熟。</p><p><img src="/images/2017/02/docker1-1024x640.jpg" alt><a id="more"></a></p><hr><p><strong>Docker简介</strong></p><p>核心设计思路：<strong>build，ship and run any app,any where</strong></p><ul><li><code>build</code>:构建镜像，封装依赖</li><li><code>ship</code>:pull Docker镜像（Docker Image）</li><li><code>run</code>：运行Docker容器（Docker Container）</li><li><code>any app</code>:任何可以<strong>Dockerize</strong>(容器化)的app</li><li><code>any where</code>:物理机、云主机、虚拟机…<br>与虚拟机（VM）的比较：</li></ul><p><img src="/images/2017/02/docker3.png" alt="docker3"></p><p><img src="/images/2017/02/docker2.png" alt="docker2"></p><hr><p><strong>Docker使用</strong></p><p>如果你还没有安装它，你可以访问<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a>开始了解，其中包含了各种系统下的安装教材。</p><p>安装完成之后，试着创建一个简单的HelloWorld（在哪都这样Q.Q）</p><pre class="lang:sh decode:true" title="HelloWorld">docker run Hello-World</pre><blockquote><p>docker–引用docker程序</p><p>run–用于创建或运行容器的子命令</p><p>Hello-World–用于创建容器的镜像名<br>Docker引擎收到命令后将进行如下操作</p></blockquote><ol><li>检查本地是否有Hello-World软件镜像</li><li>没有则从Docker Hub下载镜像</li><li>使用镜像创建容器并运行<br>窗口输出Hello-World则表明容器成功运行。（同样的，在你熟练掌握后可以尝试着从Docker Hub获取别的镜像，例如：尝试新的软件、新的操作系统、以及一些有风险的实验）</li></ol><p>其中镜像、容器是Docker的基本概念（参考<a href="https://docs.docker.com/engine/getstarted/step_two/" target="_blank" rel="noopener">https://docs.docker.com/engine/getstarted/step_two/</a>）,如果懒得每次敲sudo的话可以：</p><pre class="lang:sh decode:true" title="no-root">#Create the docker group$ sudo groupadd docker#Add your user to the docker group$ sudo usermod -aG docker $USER#Log out and log back in so that your group membership is re-evaluated</pre><p>&nbsp;</p><hr><p>除了下载镜像，你也可以自己创建镜像：</p><blockquote><ol><li>首先你需要编写Dockerfile文件（用来描述组成镜像的文件、环境和命令）</li><li>在Dockerfile所在的目录使用<code>docker build -t imagename</code>创建你的新镜像<br>当然如果你要是在<code>docker hub</code>上注册了帐号，还可以把镜像推送到你的的<code>docker hub</code>去，感觉就像是用<code>GitHub</code>一样。</li></ol></blockquote><p>（参考<a href="https://docs.docker.com/engine/getstarted/step_four/" target="_blank" rel="noopener">https://docs.docker.com/engine/getstarted/step_four/</a>）</p><hr><p>刚才只实现了在单个主机上单容器应用的部署，而<code>Docker</code>还提供了更强大的应用部署功能-<code>Docker</code>三剑客</p><ul><li><p>Compose</p></li><li><p>Machine</p></li><li><p>Swarm</p><blockquote><p><strong>Compose：</strong>多容器应用部署利器<br>在部署需要多容器的应用时，<span id="result_box" class lang="zh-CN"><span class>使用Compose文件将配置和容器间的依赖写在配置文件里，</span><span class>然后，使用单个命令从配置中创建和启动所有服务。</span></span></p></blockquote></li><li><p>使用Dockerfile定义应用程序的环境，以便可以在任何地方重现它。</p></li><li><p>在docker-compose.yml中定义组成应用程序的服务，以便它们可以在孤立的环境中一起运行。</p></li><li><p>最后，运行docker-compose up和Compose将启动并运行整个应用程序。</p></li></ul><hr><blockquote><p>**Swarm &amp;&amp; Machine :跨主机集群部署工具</p><p>**<br>Machine：简化的Docker命令行安装工具。<span id="result_box" class lang="zh-CN"><span class>它允许您在虚拟主机上安装Docker Engine，并使用<code>docker-machine</code>命令管理主机。</span></span></p></blockquote><p>Swarm：管理Docker集群（Docker Machine），增强Docker跨主机能力。<span id="result_box" class lang="zh-CN"><span class>它将一个Docker主机池变成一个单一的虚拟Docker主机。</span> <span class>因为Docker Swarm服务于标准的Docker API，任何已经与Docker守护进程通信的工具都可以使用Swarm透明扩展到多个主机</span></span>，并使用<code>docker-swarm</code>命令管理个节点主机。</p><p>为了与集群部署相适应，Docker 也可以为容器提供四种网络模式</p><ul><li>host 模式，使用 –net=host 指定。</li><li>container 模式，使用 –net=container:NAME_or_ID 指定。</li><li>none 模式，使用 –net=none 指定。</li><li>bridge 模式，使用 –net=bridge 指定，默认设置。<br>并通过<code>docker-network</code>进行管理</li></ul><hr><p><strong>Referenced：</strong></p><p>Docker学习笔记：<a href="http://blog.opskumu.com/docker.html" target="_blank" rel="noopener">http://blog.opskumu.com/docker.html</a></p><p>Docker官方文档：<a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH端口转发与反向连接</title>
      <link href="/2017/01/26/Port-Forwarding-And-Reverse-Connnection-ssh/"/>
      <url>/2017/01/26/Port-Forwarding-And-Reverse-Connnection-ssh/</url>
      
        <content type="html"><![CDATA[<p><code>SSH</code>两个常用的功能：端口转发、反向连接，偶尔自己会傻傻分不清。</p><p><img src="/images/2017/01/ssh2.jpg" alt><a id="more"></a></p><p><strong>端口转发：</strong></p><p><code>OpenSSH</code>能够创建一个加密隧道，并在这个加密的会话中封装另一种协议。</p><p>下面的命令将告诉<code>SSH</code>在本地主机和远程主机建立一条加密隧道，并使得本机的8099端口的信息转发到本地主机SSH端口（发送过程依然如普通会话进行加密），远程主机会话端口（22）再转发至目标主机8080端口（响应则是相反）。示意图如上：</p><p>&nbsp;</p><pre class="lang:sh decode:true" title="ssh隧道">% ssh -2 -N -f -g -L 8099:localhost:8080 root@remotehost</pre><p>这条SSH命令使用以下选项：</p><blockquote><p>-2 –强制使用协议版本二，默认</p><p>-N –禁止执行任何远端程序（<strong>若是端口转发或反向连接需带有此选项，否则打开的只是普通<code>SSH</code>会话</strong>）</p><p>-f –强制<code>SSH</code>后台运行，可选。-C 可启用压缩</p><p>-g –允许远程主机连接转发端口</p><p>-L –指明本地端口8099和远程转发端口8080，及远程地址</p><p>root@remotehost –为目标地址<br>上述的代码是通过端口转发，使得能够能够通过访问本地端口8089，实现访问远程主机的8080端口（假设在ECS上的Tomcat）的效果<img src="/images/2017/01/ssh1.png" alt></p></blockquote><p><strong>反向连接：</strong></p><ul><li>什么是反向连接？<br>反向连接是主机A SSH主动连接主机B，在主机A和主机B之间建立一个远程连接（此时 A控制B），再通过这个连接主机B可以主动的向主机A发送一些请求，实现主机B控制 A。</li><li>为什么需要主机A主动去连接主机B呢？<br>这是因为主机A在局域网内，如果没有对主机A进行端口映射，对于主机B来说主机A是不可见的，如果在主机B这边向主机A发送连接请求，这个请求是不可达的。而主机B有自己独立的IP，对于主机A来说是可见的，可以直接向主机B请求连接。</li><li>SSH反向连接的过程<br>方法就是主机A主动去连接主机B，主机B响应主机A的连接请求，它们之间就建立了一个远程连接。然后主机B在本地再创建一个本地连接，重定向到主机A和主机B刚才建立的远程连接上，之后对这个本地连接的操作都会反馈到远程连接上去。整个过程类似于文件的DU<code>P</code>，这就在主机A和主机B之间建立了连接通道，此时对于主机B来说，主<br>机A已经是可见了。连接流程如下：</li><li>主机A ssh客户端向主机B sshd服务端发送请求，建立远程连接。</li><li>主机B sshd服务端创建本地连接到远程连接的映射（反向连接通道）。</li><li>主机B ssh客户端向主机B sshd服务端的连接通道发送请求， 建立主机B ssh和主机A sshd的连接。完成连接后，主机A对于主机B可见的形式就是存在于主机B的那个本地连接。</li><li><em>实例：*</em></li></ul><p>本地主机A 在各种<code>NAT</code>环境下的局域网内，远程主机B 是具有公网IP的ECS</p><p>首先确保两台主机的SSH正常开启，22端口正常监听。</p><p>在本地主机A 中运行：</p><pre class="lang:sh decode:true" title="SSH2">ssh -f -N -R 8099:localhost:22 root@remotehost</pre><p>命令参数中的：</p><blockquote><p>-R –指明远程主机对远程连接的本地连接映射端口8099</p><p>其他参数同上端口转发<br>之后在远程主机B 中运行（因本次实验机B 为ECS，故需新建一个SSH会话方可进入主机B ）：</p></blockquote><pre class="lang:sh decode:true" title="SSH 4">ssh localhost -p 8099</pre><p>将远程主机B 连接到本地连接映射端口，输入本地主机A 密码即可通过B 控制A （又因实验机B 为ECS，此处还需建立一个SSH会话以监控 主机A B的情况）。</p><p>本地主机A 网络端口情况：<img src="/images/2017/01/ssh4.png" alt></p><p>本地主机B 网络端口情况：<img src="/images/2017/01/ssh5.png" alt></p><p>当前状态如下：A、B 间有三条SSH连接（多出的两条均因实验机B 的特殊情况），其中可以看到A、B 各自对远程连接进行了本地连接映射。</p><p>其中可能出现一个小问题：就是当反向连接以建立后（即B 已能成功控制A ），若是因通信故障等原因导致异常中断，则B 将无法在与A 建立连接，除非在重新回去操作A 连接B ，不过可以通过一个脚本来监控连接状态并自动重连（不过需要实现设置<strong>免密码<code>SSH</code>登录</strong>，具体设置参考 <a href="http://chenlb.iteye.com/blog/211809" target="_blank" rel="noopener">http://chenlb.iteye.com/blog/211809</a>或在最下端下载脚本）。</p><pre class="lang:sh decode:true" title="ssh 5">#!/bin/bashwhile true;doRET=`ps aux | grep "ssh -f -N -R 8099:localhost:22" | grep -v "grep"`if [ "$RET" = "" ]; thenecho "restart ssh server"ssh -f -N -R 8099:localhost:22 root@remotehostfisleep 10done</pre><p>&nbsp;</p><p>参考资料：</p><ul><li><a href="http://www.linuxweblog.com/ssh-tunneling" target="_blank" rel="noopener">http://www.linuxweblog.com/ssh-tunneling</a></li><li><a href="http://c20031776.blog.163.com/blog/static/68471625201121115051135/" target="_blank" rel="noopener">http://c20031776.blog.163.com/blog/static/68471625201121115051135/</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></li><li><a href="https://github.com/single-wolf/ShellScript/tree/master/SSH" target="_blank" rel="noopener">https://github.com/single-wolf/ShellScript/tree/master/SSH</a><br>&nbsp;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下vlan的学习（下）</title>
      <link href="/2017/01/17/Learning-Linux-Vlan-2/"/>
      <url>/2017/01/17/Learning-Linux-Vlan-2/</url>
      
        <content type="html"><![CDATA[<p>下面介绍在一个物理机上通过几个虚拟机使用软件模拟实现<code>VLAN</code>的具体步骤<img src="/images/2017/01/VLAN3.png" alt></p><p>&nbsp;</p><a id="more"></a><p>更多具体的概念可查看博文 <a href="http://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/</a>-Linux上基础设备详解</p><p><strong>准备工作</strong></p><p>物理主机：<code>Ubuntu 16.04</code></p><p><code>KVM</code>安装（安装后可自行检测）：</p><pre class="lang:sh decode:true" title="KVM">sudo apt-get install qemu-kvm qemu-system libvirt-bin virt-manager bridge-utils vlan</pre><p>虚拟机创建：</p><ul><li><p>启动虚拟系统管理器</p><pre class="lang:sh decode:true" title="virt-manager">sudo virt-manager</pre></li><li><p>将Linux镜像文件放入KVM默认查找目录<code>/var/lib/libvirt/images</code>中，随后按提示步骤创建即可（如果担心自己的物理机配置不够支撑，可以将虚拟机配置分配低一点，或者你可以选择更小的实验用Linux镜像，如cirros，可以在<a href="http://download.cirros-cloud.net/" target="_blank" rel="noopener">http://download.cirros-cloud.net/</a>下载.img文件，创建时选择导入现有磁盘映像）<img src="/images/2017/01/VLAN4.png" alt></p></li><li><p><em>配置VLAN*</em></p></li></ul><p>VLAN结构图(其中的eth0为物理网卡名，我的为<code>wlp3s0b1</code>)<img src="/images/2017/01/VLAN3.png" alt></p><p>编辑<code>/etc/network/interface</code>，配置wlp3s0b1.10、wlp3s0b1.20、brvlan10和brvlan20，添加下列配置（其中的wlp3s0b1是我的物理网卡名，因人而异）</p><pre class="lang:default decode:true" title="interface change">#auto wlp3s0b1.10  iface wlp3s0b1.10 inet manual          vlan-raw-device wlp3s0b1auto brvlan10  iface brvlan10 inet manual          bridge_stp off        bridge_waitport 0        bridge_fd 0        bridge_ports wlp3s0b1.10auto wlp3s0b1.20  iface wlp3s0b1.20 inet manual          vlan-raw-device wlp3s0b1auto brvlan20  iface brvlan20 inet manual          bridge_stp off        bridge_waitport 0        bridge_fd 0        bridge_ports wlp3s0b1.20</pre><p>重启网络后<code>ifconfig</code>，可以看到配置生效<img src="/images/2017/01/VLAN6.png" alt></p><p>使用<code>brctl show</code>查看<code>Bridge</code>情况，可以看到wlp3s0b1.10与brvlan10相连，wlp3s0b1.20与brvlan20相连。<img src="/images/2017/01/VLAN7.png" alt></p><p>配置VM1虚拟网卡与brvlan10相连，再启动VM1（如未在列表找到桥接，可重启管理器）<img src="/images/2017/01/VLAN8.png" alt></p><p>同理配置VM2虚拟网卡与brvlan20相连，我们再额外配置一个VM3与brvlan20相连。分别启动VM2、VM3。</p><p>再使用<code>brctl show</code>查看Bridge情况（brvlan10连着两个设备wlp3s0b1.10和vnet0，而brvlan20连着三个设备wlp3s0b1.20、vnet1、vnet2）<img src="/images/2017/01/VLAN9.png" alt></p><p>使用<code>virsh</code>确认各个虚拟机的虚拟网卡<img src="/images/2017/01/VLAN10.png" alt></p><p>可知现在VM1处于VLAN10，而VM2、VM3处于VLAN20</p><p>为VM1、VM2、VM3配置同一网段的IP<img src="/images/2017/01/VLAN11.png" alt>)<img src="/images/2017/01/VLAN12.png" alt>)<img src="/images/2017/01/VLAN13.png" alt></p><p><strong>验证<code>VLAN</code>连通性</strong>（VM2 与 VM3 互能 ping通）<img src="/images/2017/01/VLAN14.png" alt>)<img src="/images/2017/01/VLAN15.png" alt></p><p><strong>验证VLAN隔离性</strong>（VM1不能 ping 通 VM2、VM3）</p><p>原因如下：</p><ol><li>VM1向VM2发 Ping 包之前，需要知道VM2的IP 192.168.100.10 所对应的 MAC 地址。VM2 会在网络上广播 ARP 包，其作用就是问 “谁知道 192.168.100.10 的 MAC 地址是多少？”</li><li>ARP是二层协议，VLAN 的隔离作用使得ARP只能在VLAN10 范围内广播，只有 brvlan10 和wlp3s0b1.10 能收到，VLAN20 里的设备是收不到的。VM2 无法应答 VM1 发出的ARP包。</li><li>VM1拿不到VM2 vnet0的MAC地址，也就Ping不到VM2。</li></ol><p><strong>验证VLAN原理</strong></p><p>用各个虚拟机ping物理机，发现均显示不可达（无网关且处于不同网段）。</p><p>之后将虚拟机的IP手动改成与物理机同一网段，依然无法ping通，虽然在虚拟网卡中能抓包到ARP包，但是物理网卡却并没有接受到。<img src="/images/2017/01/VLAN16.png" alt></p><p>在用物理机ping各个虚拟机，一直处于等待，虽然能在物理网卡上抓到发出去的ICMP，但是并没有返回的ICMP包。且虚拟网卡也没有收到。</p><p><strong>看起来物理网卡wlp3s0b1就相当于虚拟交换机上的 <code>trunk</code> 口，允许 vlan10 和 vlan20 的数据通过，而<code>VLAN</code>和<code>Bridge</code>一起实现了隔离和交换的功能。</strong></p><p><strong>参考博文：</strong></p><p>Linux上基础设备详解：<a href="http://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/</a></p><p>动手实现Linux <code>VLAN</code>：<a href="http://www.cnblogs.com/CloudMan6/p/5326737.html" target="_blank" rel="noopener">http://www.cnblogs.com/CloudMan6/p/5326737.html</a></p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> VLAN </tag>
            
            <tag> KVM </tag>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下vlan的学习（上）</title>
      <link href="/2017/01/15/Learning-Linux-Vlan-1/"/>
      <url>/2017/01/15/Learning-Linux-Vlan-1/</url>
      
        <content type="html"><![CDATA[<p><code>VLAN</code>（Virtual Local Area Network），翻译为“虚拟局域网”，是一种建构于局域网交换技术的网络管理的技术，网管人员可以借此通过控制交换机有效分派出入局域网的数据包到正确的出入端口，达到对不同实体局域网中的设备进行逻辑分群管理，并降低局域网内大量数据流通时，因无用数据包过多导致拥塞的问题，以及提升局域网的信息安全保障。<strong>简单地理解就是将网络分割成多个广播域</strong>。<a id="more"></a></p><p>有关广播域及其分割广播域的作用，在此不做介绍（我渣渣的计网基础做不来概念复习）。</p><p>下面通过在一个物理机上多个虚拟机，使用软件模拟的方式来实现VLAN的功能：</p><p>首先需要了解<strong>物理网卡、子网卡、虚拟网卡三者的关系</strong>：</p><ul><li>物理网卡（eth0）：是指电脑上面的实际的网络接口设备。</li><li>子网卡也叫网卡子IP（eth0：1）：子网卡在这里并不是实际上的网络接口设备，但是可以作为网络接口在系统中出现，如eth0:1、eth1:2这种网络接口。它们必须要依赖于物理网卡，虽然可以与物理网卡的网络接口同时在系统中存在并使用不同的IP地址，而且也拥有它们自己的网络接口配置文件。但是当所依赖的物理网卡不启用时（Down状态）这些子网卡也将一同不能工作。</li><li>这些虚拟VLAN网卡也不是实际上的网络接口设备，也可以作为网络接口在系统中出现，但是与子网卡不同的是，他们没有自己的配置文件。他们只是通过将物理网加入不同的VLAN而生成的VLAN虚拟网卡。</li><li><em>创建子网卡：*</em></li></ul><p>物理网卡信息如下（当前为无线网卡）：<img src="/images/2017/01/VLAN1.png" alt="VLAN1"></p><ul><li>快速创建及删除：<pre class="lang:sh decode:true" title="快速创建删除子网卡">sudo ifconfig wlp3s0b1:0 192.168.1.106 up#快速创建sudo ifconfig wlp3s0b1:0 down#删除（系统重启后设置消失）</pre>可以看到图中子网卡的MAC地址与物理网卡一致。<img src="/images/2017/01/VLAN2.png" alt="VLAN2"></li><li>修改网卡配置文件：</li><li><em>在Ubuntu下*</em>，网卡的配置文件为 <code>/etc/network/interface</code>，在文件中添加一下内容：<pre class="lang:sh decode:true" title="Ubuntu">auto wlp3s0b1:0iface wlp3s0b1:0 inet staticaddress 192.168.1.106netmask 255.255.255.0</pre>保存后，重启网络使配置文件生效（其中配置文件具体参数解释可参照<a href="http://www.cnblogs.com/pied/archive/2013/07/23/3205636.html" target="_blank" rel="noopener">Linux下interface文件修改</a>）：<pre class="lang:sh decode:true">sudo service networking restart</pre></li><li><em>在CentOS下*</em>，网卡的配置文件保存在<code>/etc/sysconfig/network-scripts</code>目录下，一个网卡对应一个配置文件。仿照本机网卡的配置文件来编写子网卡的配置文件，内容如下（增加配置文件eth0:0）：<pre class="lang:sh decode:true " title="CentOS下子网卡配置文件">DEVICE=eth0:0                 //虚拟网络接口，随意                                    ONBOOT=yes                    //系统启动时激活BOOTPROTO=static             //使用静态ip地址                IPADDR=192.168.6.106          //该虚拟网络接口的ip别名，随意NETMASK=255.255.255.0         //子网掩码，对应ip别名GATEWAY=192.168.6.1           //网关，对应ip别名HWADDR=00:10:5A:5E:B1:E4      //网卡MAC地址，无需更改                   USERCTL=no                    //是否给予非root用户设备管理权限</pre><blockquote><p>注意：</p><ol><li>子网卡名不能瞎取，应该根据物理网卡名来决定（使用ifconfig  -a查看所有网卡）</li><li><span class="Apple-style-span">在设置ip别名时，如果增加的是和局域网同一网段的ip（如文中的192.168.1.106），那么除了本机外局域网内其他机器都可以ping通这个ip。如果增加的是奇形怪状的ip，那么就只有本机可以ping通而已。</span><br>在之后将介绍虚拟网卡及<code>VLAN</code>的实验过程。</li></ol></blockquote></li></ul><p>参考资料：</p><ul><li><a href="http://www.cnblogs.com/JohnABC/p/5951340.html" target="_blank" rel="noopener">http://www.cnblogs.com/JohnABC/p/5951340.html</a></li><li><a href="http://blog.chinaunix.net/uid-11861796-id-2813605.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-11861796-id-2813605.html</a></li><li><a href="http://www.cnblogs.com/CloudMan6/p/5326737.html" target="_blank" rel="noopener">http://www.cnblogs.com/CloudMan6/p/5326737.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> VLAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Tomcat中使用ThreadLocal绑定信息</title>
      <link href="/2016/12/17/Bind-Info-In-ThreadLocal/"/>
      <url>/2016/12/17/Bind-Info-In-ThreadLocal/</url>
      
        <content type="html"><![CDATA[<p>在最近完成的课设中，发现通过<code>ThreadLocal</code>进行信息与线程的绑定可以方便之后的代码编写。部分出自参考 <a href="http://www.liaoxuefeng.com/article/00146129217054923f7784c57134669986a8875c10e135e000" target="_blank" rel="noopener">设计一个可扩展的用户登录系统（3）</a> 。<a id="more"></a></p><p>以一个登录为例，我们需要将已完成登录的用户信息与其操作的线程进行绑定，而<code>ThreadLocal</code>能够很好地实现这个功能。</p><pre class="lang:java decode:true">public class UserContext implements AutoCloseable {    static final ThreadLocal&lt;User&gt; current = new ThreadLocal&lt;User&gt;();    public UserContext(User user) {        current.set(user);    }    public static User getCurrentUser() {        return current.get();    }    public void close() {        current.remove();    }}</pre><p>我们将一个User类绑定到当前线程，并使用统一<code>的filter</code>进行操作：</p><pre class="lang:java decode:true">public class MyFilter implements Filter {    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {        //根据cookie判断user，省略方法体        User user = tryGetAuthenticatedUser(request, response);        try (UserContext context = new UserContext(user)) {            chain.doFilter(request, response);        }    }}</pre><p>但是在测试过程中发现，只要有用户进行了登录验证就会有一些未进行登录验证的用户请求线程里自带了user信息。</p><p>原来是tomcat在启动后一开始收到请求，它就会创建一个基于本身配置<code>minSapreThreads</code>参数的线程池，之后的每次请求线程都是从这个线程池中取出工作线程，而不是创建一个新的线程。<strong>（线程池-&gt;取出工作线程-&gt;处理请求-&gt;将线程放回池中）</strong></p><p>我们就需要在这个UserContext中创建方法解除绑定：</p><pre class="lang:java decode:true ">    //清除TheadLocal信息    public static void destroy(){        current.remove();    }</pre><p>接着同样可以在同一的<code>f</code>ilter中进行解绑操作。这样在之后的代码编写中我们就只需要通过这样的一句简单的代码获取到绑定到当前线程中的User信息：</p><pre class="lang:java decode:true">UserContext.getCurrentUser();</pre><p>参考：<a href="http://www.linuxidc.com/Linux/2015-02/113260.htm" target="_blank" rel="noopener">关于tomcat线程池的理解</a></p><p>每天进步一点点！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 包管理工具学习笔录（apt、yum）</title>
      <link href="/2016/12/11/Learning-Linx-Pakeage-Management-Notes/"/>
      <url>/2016/12/11/Learning-Linx-Pakeage-Management-Notes/</url>
      
        <content type="html"><![CDATA[<p>谨遵BOSS指令，本周学习包管理工具。选择从<code>apt</code>、<code>yum</code>入手。</p><p>下面从常见命令，环境（<code>Ubuntu 16.04</code>、<code>CentOS 6.8</code>）等来看两者的异同。<a id="more"></a></p><p>首先新手（如我）从Windows到开始跑Linux时，装东西总是照着那几个命令敲，会想（软件包是什么玩意？安装时是在哪下载资源的？）</p><p><strong>Linux中所谓包</strong>：大多数现代的类Unix操作系统（Linux）中软件通常分布的形式。软件包通常包含编译的二进制文件和其他软件组成资源，包括安装脚本。包还包含有价值的元数据，以及它们的依赖（安装和运行它们所需的其他包的列表）。（Ubuntu下包格式为.deb    CentOS下则是.rpm）</p><p><strong>包管理工具的源：</strong>没错你通过包管理工具安装的包就是在这下载的，其实就是一个镜像服务器的链接列表。系统默认的源服务器都是国外的（如果你是买的ECS很有可能是运营商的，例如某云），国内使用可能速度比较慢，可以通过修改配置文件，将其改为国内更快的镜像服务器，例如中科大、网易的开源镜像。</p><p>我们来以配置阿里云开源镜像为例：</p><p><strong>Ubuntu下源配置文件位置 <code>/etc/apt/sources.list.d/</code>（或是<code>sources.list</code>）</strong></p><pre class="lang:sh decode:true">deb-src http://mirrors.aliyun.com/ubuntu xenial main restricted  deb-src http://mirrors.aliyun.com/ubuntu xenial universe  deb-src http://mirrors.aliyun.com/ubuntu xenial multiverse  deb-src http://mirrors.aliyun.com/ubuntu xenial-updates main restricted  deb-src http://mirrors.aliyun.com/ubuntu xenial-updates universe  deb-src http://mirrors.aliyun.com/ubuntu xenial-updates multiversedeb-src http://mirrors.aliyun.com/ubuntu xenial-security main restricted  deb-src http://mirrors.aliyun.com/ubuntu xenial-security universe  deb-src http://mirrors.aliyun.com/ubuntu xenial-security multiversedeb http://mirrors.aliyun.com/ubuntu xenial main restricted  deb http://mirrors.aliyun.com/ubuntu xenial universe  deb http://mirrors.aliyun.com/ubuntu xenial multiverse  deb http://mirrors.aliyun.com/ubuntu xenial-updates main restricted  deb http://mirrors.aliyun.com/ubuntu xenial-updates universe  deb http://mirrors.aliyun.com/ubuntu xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu xenial-security main restricted  deb http://mirrors.aliyun.com/ubuntu xenial-security universe  deb http://mirrors.aliyun.com/ubuntu xenial-security multiverse</pre><blockquote><p>deb或者deb-src，分别表示直接通过.deb文件进行安装和通过源码的方式进行安装（无需编译推荐.deb）</p><p><a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com/</a> 源地址，此处用的阿里云开源镜像</p><p>xenial-版本代号，各个Ubuntu版本代号各不同（详见参考资料）</p><p>main、restricted、universe、multiverse-为软件包自由度<br>备份原配置文件后，修改完成并执行apt-get update将从新的服务器下载包</p></blockquote><p><strong>CentOS下源配置文件分为两部分</strong></p><ol><li>全局配置文件<code>/etc/yum.conf</code>，其中的[main]部分定义了全局配置选项。</li><li>各个源/服务器的具体配置,可以有一到多个. 常位于<code>/etc/yum.repo.d/</code>目录下的各文件。我们需要进行修改配置的正是其中的<code>CentOS-Base.repo</code></li></ol><p><strong>CentOS-Base.repo 是yum网络源的配置文件</strong></p><pre class="lang:sh decode:true">[base]name=CentOS-$releasever - Base  mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra  #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/gpgcheck=1  gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</pre><blockquote><p>[]中是用于区别各个不同的repository,必须有一个独一无二的名称</p><p>name-对repository 的描述,支持像$releasever $basearch这样的变量</p><p>mirrorlist - 镜像站点</p><p>baseurl -服务器设置中最重要的部分,只有设置正确,才能从上面获取软件。后面可以跟很多url，但是只能有一个baseurl，上图默认已被注释。</p><p>gpgcheck - RPM的数字证书是否生效 ，1则是生效<br>gpgkey - 数字证书的公钥文件保存位置</p><p>$releasever:代表发行版的版本,从[main]部分的distroverpkg获取,如果没有,则根据redhat-release包进行判断.<br>$arch:cpu体系,如i686,athlon等<br>$basearch:cpu的基本体系组,如i686和athlon同属i386,alpha和alphaev6同属alpha.</p><p>&nbsp;<br>配置过程很简单，先将原配置文件备份（好习惯），再将默认的<code>mirrorlist</code>加#注释掉，并将baseurl去注释后域名那部分换上中科大开源镜像<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a> 即可。配置完成后使用命令更新操作</p></blockquote><pre class="lang:sh decode:true ">yum makecache#把服务器的包信息下载到本地电脑缓存起来</pre><p>&nbsp;</p><p><strong>常见命令（sudo 就不说了）：</strong></p><p><strong>安装包：</strong></p><ul><li><p>apt:</p><pre class="lang:sh decode:true">apt-get install 包名</pre></li><li><p>yum:</p><pre class="lang:sh decode:true ">yum install 包名</pre></li><li><p><em>删除包：*</em></p></li><li><p>apt：</p><pre class="lang:sh decode:true">apt-get remove 包名apt-get autoremove 自动删除孤立组件</pre></li><li><p>yum:</p><pre class="lang:sh decode:true">yum remove 包名</pre></li><li><p><em>查询包：*</em></p></li><li><p>apt:</p><pre class="lang:sh decode:true">apt-cache search 关键字apt-cache show 包名</pre></li><li><p>yum:</p><pre class="lang:sh decode:true">yum list  包名yum info  显示yum search 关键字</pre></li><li><p><em>更新包：*</em></p></li><li><p>apt</p><pre class="lang:sh decode:true">apt-get update 包名apt-get upgrade 包名 更新已安装包</pre></li><li><p>yum</p><pre class="lang:sh decode:true">yum update 包名yum check-update 检查可用更新</pre><p>详细还是得靠<code>man</code>命令大法（英文也得忍着痛看，不过想看中文版需另外下包安装）</p></li></ul><p>查考资料：<a href="http://blog.csdn.net/halazi100/article/details/41311837" target="_blank" rel="noopener">yum配置全解</a>   <a href="https://www.digitalocean.com/community/tutorials/package-management-basics-apt-yum-dnf-pkg" target="_blank" rel="noopener">软件包管理基础知识</a>  <a href="http://blog.csdn.net/snaking616/article/details/52966634" target="_blank" rel="noopener">source.list配置及版本代号</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat熵池阻塞变慢详解（tomcat启动加速）</title>
      <link href="/2016/11/30/Speedup-Tomcat-Startup/"/>
      <url>/2016/11/30/Speedup-Tomcat-Startup/</url>
      
        <content type="html"><![CDATA[<p>重启在自己的ECS上tomcat时，发现启动特别的慢（简直无法忍受）。</p><p>查看日志却没发现有报错，但是也发现了一个很亮眼的数字(<strong>关于SercureRandom实例创建阻塞时间</strong>）：<a id="more"></a><img src="/images/2016/11/tomcat1.png" alt><br>整个183秒（真是0.0）的tomcat启动过程，这个玩意花了近180秒（要报警了）。</p><blockquote><p>转载自<a href="http://m.blog.csdn.net/article/details?id=49494701" target="_blank" rel="noopener">Tomcat8熵池阻塞变慢详解</a>,作者：<a href="http://blog.csdn.net/chszs" target="_blank" rel="noopener">chszs</a></p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>Tomcat 7/8都使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom类产生安全随机类SecureRandom的实例作为会话ID，这里花去了180秒，也即接近3分钟。</p><p>SHA1PRNG算法是基于SHA-1算法实现且保密性较强的伪随机数生成器。</p><p>在SHA1PRNG中，有一个种子产生器，它根据配置执行各种操作。</p><p>1）如果java.security.egd属性或securerandom.source属性指定的是”file:/dev/random”或”file:/dev/urandom”，那么JVM会使用本地种子产生器NativeSeedGenerator，它会调用super()方法，即调用SeedGenerator.URLSeedGenerator(/dev/random)方法进行初始化。</p><p>2）如果java.security.egd属性或securerandom.source属性指定的是其它已存在的URL，那么会调用SeedGenerator.URLSeedGenerator(url)方法进行初始化。</p><p>这就是为什么我们设置值为”file:///dev/urandom”或者值为”file:/./dev/random”都会起作用的原因。</p><p>在这个实现中，产生器会评估熵池（entropy pool）中的噪声数量。随机数是从熵池中进行创建的。当读操作时，/dev/random设备会只返回熵池中噪声的随机字节。/dev/random非常适合那些需要非常高质量随机性的场景，比如一次性的支付或生成密钥的场景。</p><p>当熵池为空时，来自/dev/random的读操作将被阻塞，直到熵池收集到足够的环境噪声数据。这么做的目的是成为一个密码安全的伪随机数发生器，熵池要有尽可能大的输出。对于生成高质量的加密密钥或者是需要长期保护的场景，一定要这么做。</p><p>那么什么是环境噪声？</p><p>随机数产生器会收集来自设备驱动器和其它源的环境噪声数据，并放入熵池中。产生器会评估熵池中的噪声数据的数量。当熵池为空时，这个噪声数据的收集是比较花时间的。这就意味着，Tomcat在生产环境中使用熵池时，会被阻塞较长的时间。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>有两种解决办法（其实归根结底就一种用伪随机函数生成器来替代随机函数生成器）：</p><p>1）在Tomcat环境中解决</p><p>可以通过配置JRE使用非阻塞的Entropy Source。</p><p>在catalina.sh中修改或加入这么一行：-Djava.security.egd=file:/dev/./urandom 即可。</p><p>加入后再启动Tomcat，整个启动耗时下降到Server startup in 2912 ms。</p><blockquote><p>本人尝试在catalina.sh中不同位置加入这行，均未成功。</p><p>应该是Java的配置影响，所以推荐下一种修改JVM配置方式<br>2）在JVM环境中解决</p></blockquote><p>打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容：</p><pre><code>securerandom.source=file:/dev/urandom`&lt;/pre&gt;替换成&lt;pre style=&quot;width: 100%; overflow: hidden;&quot;&gt;`securerandom.source=file:/dev/./urandom</code></pre><p>修改以后重启tomcat，速度瞬间提高两个数量级：</p><p><img src="/images/2016/11/tomcat2.png" alt></p><p>分享关于tomcat启动加速的wiki:<a href="http://wiki.apache.org/tomcat/HowTo/FasterStartUp" target="_blank" rel="noopener">How do i make Tomcat startup faster?</a></p><p>另一种解决方案：增大/dev/random的熵池<a href="http://mp.weixin.qq.com/s?__biz=MzIxMjAzMDA1MQ==&amp;mid=2648945568&amp;idx=1&amp;sn=7eff16ee9dd40e6f9f90073c0ef90a9e&amp;chksm=8f5b54acb82cddbaf80a1afd16d3222fed631d1ca1d78d84e9fce32bbed1fdcbecbd5d099c9d&amp;utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener"> http://mp.weixin.qq.com/s?__biz=MzIxMjAzMDA1MQ==&amp;mid=2648945568…</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Tomcat </category>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下Mysql编码设置</title>
      <link href="/2016/11/19/Mysql-Coding-Setting-Ubuntu/"/>
      <url>/2016/11/19/Mysql-Coding-Setting-Ubuntu/</url>
      
        <content type="html"><![CDATA[<p>在自己Ubuntu ECS上安装Mysql后，插入数据时发现因为编码而导致的中文显示乱码问题（如下图中疑问号处）<a id="more"></a></p><p><img src="/images/2016/11/Ubuntu-mysql1-2.png" alt="ubuntu-mysql1-2"></p><p>查询发现是因为通过apt-get命令下载的MySQL默认数据库编码格式是latin1（如下图），这种编码格式因为字节数的关系不能显示中文，所以<strong>需要把编码改为utf8以支持中文显示</strong>。</p><p>通过下图命令查看各编码设置情况（其中需要修改latin1）：</p><p><img src="/images/2016/11/Ubuntu-mysql1-4.png" alt="ubuntu-mysql1-4"></p><p><strong>解决方案：</strong></p><p><strong>1、查看版本信息（可登录MySQL后执行命令select version()查看）：</strong></p><ul><li>Linux系统环境 Ubuntu 14.04</li><li>Mysql版本 5.5.53<br>2、<strong>修改MySQL配置文件–/etc/mysql/mysql.cnf：</strong></li></ul><p>a） 打开mysql配置文件：</p><pre class="lang:sh decode:true">                vim/etc/mysql/my.cnf</pre><p>b） 在[client]下追加：</p><pre class="lang:sh decode:true">                default-character-set=utf8</pre><p>c） 在[mysqld]下追加：</p><pre class="lang:sh decode:true">                character-set-server=utf8</pre><p>d） 在[mysql]下追加：</p><pre class="lang:sh decode:true">                default-character-set=utf8</pre><p><strong>3、重启MySQL服务：</strong></p><pre class="lang:sh decode:true">sudo service mysql restart</pre><p>或是：</p><pre class="lang:sh decode:true ">sudo /etc/init.d/mysql restart</pre><p><strong>4、查看编码修改是否成功（登录MySQL后执行status查看状态和编码）：</strong><img src="/images/2016/11/Ubuntu-mysql1-5.png" alt="ubuntu-mysql1-5"></p><p><strong>5、</strong>可能有小伙伴说修改成功了，<strong>为什么我的原来创建的数据表还是显示不出中文？</strong></p><p>这是因为原来创建的数据库和数据表的字符集编码已经默认设置的了latin</p><p>-通过use data;选择需要修改字符集编码的数据库，并修改（data换成自己数据库名）</p><p>-修改数据表默认编码（type换成自己数据表名）</p><pre class="lang:sh decode:true ">mysql&gt; alter table type character set utf8;</pre><p><strong>6、如果还有悲催地发现还是不能显示中文，并输入：</strong></p><pre class="lang:sh decode:true ">mysql&gt;show create table type;</pre><p>你会发现表中每个字段定义后面都有一个<strong>character set latin1，</strong>那么想要继续用的话只能一一修改字段：</p><pre class="lang:sh decode:true">mysql&gt; alter table type modify type_name varchar(50) CHARACTER SET utf8;</pre><p>&nbsp;</p><blockquote><p>在用MYSQL中要注意：其中的数据库，表，列 对应的编码格式没有包含关系，<strong>最终决定内容以什么编码格式保存下来还是定义列时指定的编码</strong>（<span class="Apple-style-span"><code>Name</code> varchar(64) character set latin1 NOT NULL,</span>），在建库和表时设置编码格式只是相当与为自己的下一级设置默认编码格式。<br>&nbsp;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻墙姿势</title>
      <link href="/2016/11/17/To-Escape-GFW/"/>
      <url>/2016/11/17/To-Escape-GFW/</url>
      
        <content type="html"><![CDATA[<p>之前我发过一篇博文，引用了通过修改hosts文件达到访问墙外网站的目的（<a href="https://laod.cn/hosts/2016-google-hosts.html" target="_blank" rel="noopener">老D博客</a>），后来发现这种方法不仅需要手动更改，且速度慢。接下来分享<strong>更靠谱的翻墙姿势</strong>。<a id="more"></a></p><ul><li><p>免费且速度可靠的shadowsocks<br>基于shadowsocks的代理翻墙，目前国内有这家比较可靠的免费shadowdocks代理服务网站<a href="http://www.ishadowsocks.net/" target="_blank" rel="noopener">http://www.ishadowsocks.net/</a>，网站上有提示下载shadowsocks客户端，安装后编辑相应的服务器，每6小时更新一次服务器密码，你就可以享受非常稳定的翻墙体验，虽然速度一般，但正常浏览网页完全没问题。</p></li><li><p><em>2017-10-23日更新–上述网站现已关闭，已无免费的账号提供。想自己动手搭建Shadowsocks的童鞋可参考本站<a href="http://zhongm.in/2017/10/12/QuickInit-Shell-Script">一键配置脚本</a>*</em></p></li><li><p>赛风（这个就不用说了）<br>赛风以前确实挺靠谱的，但是目前经常出现掉线的情况。伤心(；′⌒`)</p></li><li><p>Latern（同样是免费）<br>小型即装即用的翻墙软件(<a href="https://github.com/getlantern/www.getlantern.org" target="_blank" rel="noopener">GitHub:getlantern</a>)，但是同样存在速度慢，且不稳定等问题。（不过你土豪花钱买专业版就当我没说）</p></li><li><p>各类VPN（VPN gate、VPN unlimited）<br>下图是<a href="https://cc.greatfire.org/" target="_blank" rel="noopener">翻墙中心</a>（当然没翻墙你是看不到的，不过你可以访问<a href="https://github.com/greatfire/wiki" target="_blank" rel="noopener">翻墙中心WiKi</a>）</p></li></ul><p>11-18各类翻墙姿势的数据<img src="/images/2016/11/greatfire1.png" alt="greatfire1"></p><p>希望帮助到各位，一起看墙外的世界！！！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PassWall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Ubuntu新手上路总结</title>
      <link href="/2016/11/17/The-Tiro-Summary-Of-Ubuntu/"/>
      <url>/2016/11/17/The-Tiro-Summary-Of-Ubuntu/</url>
      
        <content type="html"><![CDATA[<p>新装的Ubuntu一路熟悉到现在，进行个小结。</p><p>包括基本Linux命令，优化步骤。<a id="more"></a></p><p>新装系统后感觉小兴奋，之前一直只在虚拟机上跑，现在是实实在在上路啦！</p><p><strong>对无用的系统应用进行清除：</strong></p><ol><li><p>删除游戏：</p><pre class="lang:sh decode:true">sudo apt-get remove gnome-games-common</pre></li><li><p>删除自带email：</p><pre class="lang:sh decode:true">sudo apt-get remove empathy-doc evolution-common</pre></li><li><p>删除自带Office（可以考虑保留）</p><pre class="lang:sh decode:true">sudo apt-get remove openoffice.org-draw openoffice.org-math openoffice.org-impress openoffice.org-calc openoffice.org-writer</pre></li><li><p>自动删除不必要包：</p><pre class="lang:sh decode:true">sudo apt-get autoclean //清理旧版本软件缓存sudo apt-get clean //清理所有软件缓存sudo apt-get autoremove //删除系统不使用的孤立的组件</pre></li></ol><p><strong>提醒各位小伙伴：网上有关于删除系统组件，或设置开机不扫描硬盘等操作有一定风险，慎重操作。</strong></p><pre><code>* * *</code></pre><blockquote><p>基本命令操作</p></blockquote><blockquote><p>小技巧：新手上路记不清具体命令名可常使用Tab自动补全命令<br>看完了草鞋，分享一个假腿<strong><a href="http://blog.csdn.net/u014630636/article/details/51996498" target="_blank" rel="noopener">Ubuntu快速上手指南</a></strong>（包括输入法、JDK、Git等）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java正则表达式</title>
      <link href="/2016/11/01/Java-Regular-Expression/"/>
      <url>/2016/11/01/Java-Regular-Expression/</url>
      
        <content type="html"><![CDATA[<p>前一会在学习关于Java爬虫知识的时候接触到了正则，而在程序开发中，难免也会遇到需要匹配、查找、替换、判断字符串的情况发生，正则表达式正是解决这一问题非常有力的手段。（<strong>一些基本知识也方便日后查询</strong>）</p><a id="more"></a><p>自从jdk1.4推出java.util.regex包，就为我们提供了很好的JAVA正则表达式应用平台。<strong>使用中一个重要的细节：就是在转义字符 \ 前还需要加转义字符，如数字 \d 之前还需要加 \ 变成 \d。</strong></p><p>java.util.regex包主要包括以下三个类：</p><ul><li><strong>Pattern类：</strong>pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。</li><li><strong>Matcher类：</strong>Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。</li><li><strong>PatternSyntaxException：</strong>PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li><li><em>正则表达式语法：*</em><table class="reference"><tbody><tr><th>字符</th><th>说明</th></tr><tr><td>\</td><td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\"匹配"\"，"\("匹配"("。</td></tr><tr><td>^</td><td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与"\n"或"\r"之后的位置匹配。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与"\n"或"\r"之前的位置匹配。</td></tr><tr><td>*</td><td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。</td></tr><tr><td>+</td><td>一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。</td></tr><tr><td>?</td><td>零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。</td></tr><tr><td>{_n_}</td><td>_n _是非负整数。正好匹配 _n_ 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。</td></tr><tr><td>{_n_,}</td><td>_n _是非负整数。至少匹配 _n _次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。</td></tr><tr><td>{_n_,_m_}</td><td>_M_ 和 _n_ 是非负整数，其中 _n_ &lt;= _m_。匹配至少 _n_ 次，至多 _m_ 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>?</td><td>当此字符紧随任何其他限定符（*、+、?、{_n_}、{_n_,}、{_n_,_m_}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。</td></tr><tr><td>.</td><td>匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。</td></tr><tr><td>(_pattern_)</td><td>匹配 _pattern_ 并捕获该匹配的子表达式。可以使用 **$0…$9** 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。</td></tr><tr><td>(?:_pattern_)</td><td>匹配 _pattern_ 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (|) 组合模式部件的情况很有用。例如，'industr(?:y|ies) 是比 'industry|industries' 更经济的表达式。</td></tr><tr><td>(?=_pattern_)</td><td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 _pattern_ 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95|98|NT|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td>(?!_pattern_)</td><td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 _pattern_ 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95|98|NT|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td>_x_|_y_</td><td>匹配 _x_ 或 _y_。例如，'z|food' 匹配"z"或"food"。'(z|f)ood' 匹配"zood"或"food"。</td></tr><tr><td>[_xyz_]</td><td>字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。</td></tr><tr><td>[^_xyz_]</td><td>反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。</td></tr><tr><td>[_a-z_]</td><td>字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。</td></tr><tr><td>[^_a-z_]</td><td>反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。</td></tr><tr><td>\b</td><td>匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。</td></tr><tr><td>\B</td><td>非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。</td></tr><tr><td>\c_x_</td><td>匹配 _x_ 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。_x_ 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。</td></tr><tr><td>\d</td><td>数字字符匹配。等效于 [0-9]。</td></tr><tr><td>\D</td><td>非数字字符匹配。等效于 [^0-9]。</td></tr><tr><td>\f</td><td>换页符匹配。等效于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>换行符匹配。等效于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等效于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td></tr><tr><td>\t</td><td>制表符匹配。与 \x09 和 \cI 等效。</td></tr><tr><td>\v</td><td>垂直制表符匹配。与 \x0b 和 \cK 等效。</td></tr><tr><td>\w</td><td>匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。</td></tr><tr><td>\W</td><td>与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。</td></tr><tr><td>\x_n_</td><td>匹配 _n_，此处的 _n_ 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&amp;"1"等效。允许在正则表达式中使用 ASCII 代码。</td></tr><tr><td>\_num_</td><td>匹配 _num_，此处的 _num_ 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。</td></tr><tr><td>\_n_</td><td>标识一个八进制转义码或反向引用。如果 \_n_ 前面至少有 _n_ 个捕获子表达式，那么 _n_ 是反向引用。否则，如果 _n_ 是八进制数 (0-7)，那么 _n_ 是八进制转义码。</td></tr><tr><td>\_nm_</td><td>标识一个八进制转义码或反向引用。如果 \_nm_ 前面至少有 _nm_ 个捕获子表达式，那么 _nm_ 是反向引用。如果 \_nm_ 前面至少有 _n_ 个捕获，则 _n_ 是反向引用，后面跟有字符 _m_。如果两种前面的情况都不存在，则 \_nm_ 匹配八进制值 _nm_，其中 _n _和 _m_ 是八进制数字 (0-7)。</td></tr><tr><td>\<span class="parameter">nml</span></td><td>当 _n_ 是八进制数 (0-3)，_m_ 和 _l_ 是八进制数 (0-7) 时，匹配八进制转义码 _nml_。</td></tr><tr><td>\u_n_</td><td>匹配 _n_，其中 _n_ 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td></tr></tbody></table></li><li><em>Matcher类的方法*</em></li><li><em>索引方法*</em><br>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：<table class="reference"><tbody><tr><th style="width: 45px;">**序号**</th><th style="width: 532px;">**方法及说明**</th></tr><tr><td style="width: 45px;">1</td><td style="width: 532px;">public int start()返回以前匹配的初始索引。</td></tr><tr><td style="width: 45px;">2</td><td style="width: 532px;">public int start(int group)返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td></tr><tr><td style="width: 45px;">3</td><td style="width: 532px;">public int end()返回最后匹配字符之后的偏移量。</td></tr><tr><td style="width: 45px;">4</td><td style="width: 532px;">public int end(int group)返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr></tbody></table></li><li><em>研究方法*</em><br>研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：<table class="reference"><tbody><tr><th style="width: 49px;">**序号**</th><th style="width: 528px;">**方法及说明**</th></tr><tr><td style="width: 49px;">1</td><td style="width: 528px;">public boolean lookingAt()尝试将从区域开头开始的输入序列与该模式匹配。</td></tr><tr><td style="width: 49px;">2</td><td style="width: 528px;">public boolean find()尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td style="width: 49px;">3</td><td style="width: 528px;">public boolean find(int start）重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr><tr><td style="width: 49px;">4</td><td style="width: 528px;">public boolean matches()尝试将整个区域与模式匹配。</td></tr></tbody></table></li><li><em>替换方法*</em><br>替换方法是替换输入字符串里文本的方法：<table class="reference"><tbody><tr><th style="width: 43px;">**序号**</th><th style="width: 534px;">**方法及说明**</th></tr><tr><td style="width: 43px;">1</td><td style="width: 534px;">public Matcher appendReplacement(StringBuffer sb, String replacement)实现非终端添加和替换步骤。</td></tr><tr><td style="width: 43px;">2</td><td style="width: 534px;">public StringBuffer appendTail(StringBuffer sb)实现终端添加和替换步骤。</td></tr><tr><td style="width: 43px;">3</td><td style="width: 534px;">public String replaceAll(String replacement)替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td></tr><tr><td style="width: 43px;">4</td><td style="width: 534px;">public String replaceFirst(String replacement)替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td></tr><tr><td style="width: 43px;">5</td><td style="width: 534px;">public static String quoteReplacement(String s)返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</td></tr></tbody></table>PatternSyntaxException 类的方法PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。</li></ul><p>PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。</p><table class="reference"><tbody><tr><th style="width: 45px;">序号</th><th style="width: 532px;">方法及说明</th></tr><tr><td style="width: 45px;">1</td><td style="width: 532px;">public String getDescription()获取错误的描述。</td></tr><tr><td style="width: 45px;">2</td><td style="width: 532px;">public int getIndex()获取错误的索引。</td></tr><tr><td style="width: 45px;">3</td><td style="width: 532px;">public String getPattern()获取错误的正则表达式模式。</td></tr><tr><td style="width: 45px;">4</td><td style="width: 532px;">public String getMessage()返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。</td></tr></tbody></table>抛开空泛的概念，下面写出几个简单的Java正则用例：<ul><li><p>比如，在字符串包含验证时</p><pre class="lang:java decode:true">//查找以Java开头,任意结尾的字符串Pattern pattern = Pattern.compile("^Java.*");Matcher matcher = pattern.matcher("Java不是人");boolean b= matcher.matches();//当条件满足时，将返回true，否则返回falseSystem.out.println(b);</pre></li><li><p>以多条件分割字符串时</p><pre class="lang:java decode:true">Pattern pattern = Pattern.compile("[, |]+");String[] strs = pattern.split("Java Hello World  Java,Hello,,World|Sun");for (int i=0;i&lt;strs.length;i++) {System.out.println(strs[i]);}</pre></li><li><p>文字替换（首次出现字符）</p><pre class="lang:java decode:true">Pattern pattern = Pattern.compile("正则表达式");Matcher matcher = pattern.matcher("正则表达式 Hello World,正则表达式 Hello World");//替换第一个符合正则的数据System.out.println(matcher.replaceFirst("Java"));</pre></li><li><p>文字替换（全部）</p><pre class="lang:java decode:true">Pattern pattern = Pattern.compile("正则表达式");Matcher matcher = pattern.matcher("正则表达式 Hello World,正则表达式 Hello World");//替换第一个符合正则的数据System.out.println(matcher.replaceAll("Java"));</pre></li><li><p>文字替换（置换字符）</p><pre class="lang:java decode:true">Pattern pattern = Pattern.compile("正则表达式");Matcher matcher = pattern.matcher("正则表达式 Hello World,正则表达式 Hello World ");StringBuffer sbr = new StringBuffer();while (matcher.find()) {matcher.appendReplacement(sbr, "Java");}matcher.appendTail(sbr);System.out.println(sbr.toString());</pre></li><li><p>验证是否为邮箱地址</p><pre class="lang:java decode:true">String str="ceponline@yahoo.com.cn";Pattern pattern = Pattern.compile("[//w//.//-]+@([//w//-]+//.)+[//w//-]+",Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(str);System.out.println(matcher.matches());</pre></li><li><p>去除html标记</p><pre class="lang:java decode:true">Pattern pattern = Pattern.compile("&lt;.+?&gt;", Pattern.DOTALL);Matcher matcher = pattern.matcher("&lt;a href=/"index.html/"&gt;主页&lt;/a&gt;");String string = matcher.replaceAll("");System.out.println(string);</pre></li><li><p>查找html中对应条件字符串</p><pre class="lang:java decode:true">Pattern pattern = Pattern.compile("href=/"(.+?)/"");Matcher matcher = pattern.matcher("&lt;a href=/"index.html/"&gt;主页&lt;/a&gt;");if(matcher.find())System.out.println(matcher.group(1));}</pre></li><li><p>截取http://地址</p><pre class="lang:java decode:true">//截取urlPattern pattern = Pattern.compile("(http://|https://){1}[//w//.//-/:]+");Matcher matcher = pattern.matcher("dsdsds&lt;http://dsds//gfgffdfd&gt;fdf");StringBuffer buffer = new StringBuffer();while(matcher.find()){              buffer.append(matcher.group());        buffer.append("/r/n");              System.out.println(buffer.toString());}</pre></li><li><p>替换指定{}中文字</p><pre class="lang:java decode:true">String str = "Java目前的发展史是由{0}年-{1}年";String[][] object={new String[]{"//{0//}","1995"},new String[]{"//{1//}","2007"}};System.out.println(replace(str,object));</pre></li></ul><p>public static String replace(final String sourceString,Object[] object) {<br>            String temp=sourceString;<br>            for(int i=0;i&lt;object.length;i++){<br>                      String[] result=(String[])object[i];<br>               Pattern    pattern = Pattern.compile(result[0]);<br>               Matcher matcher = pattern.matcher(temp);<br>               temp=matcher.replaceAll(result[1]);<br>            }<br>            return temp;<br>}</p><ul><li><p>以正则条件查询指定目录下文件</p><pre class="lang:java decode:true">//用于缓存文件列表    private ArrayList files = new ArrayList();    //用于承载文件路径    private String _path;    //用于承载未合并的正则公式    private String _regexp;    class MyFileFilter implements FileFilter {          /**           * 匹配文件名称           */          public boolean accept(File file) {            try {              Pattern pattern = Pattern.compile(_regexp);              Matcher match = pattern.matcher(file.getName());                              return match.matches();            } catch (Exception e) {              return true;            }          }        }    /**     * 解析输入流     */    FilesAnalyze (String path,String regexp){        getFileName(path,regexp);    }    /**     * 分析文件名并加入files     */    private void getFileName(String path,String regexp) {        //目录          _path=path;          _regexp=regexp;          File directory = new File(_path);          File[] filesFile = directory.listFiles(new MyFileFilter());          if (filesFile == null) return;          for (int j = 0; j &lt; filesFile.length; j++) {            files.add(filesFile[j]);          }          return;        }    /**     * 显示输出信息     */    public void print (PrintStream out) {        Iterator elements = files.iterator();        while (elements.hasNext()) {            File file=(File) elements.next();                out.println(file.getPath());            }    }    public static void output(String path,String regexp) {        FilesAnalyze fileGroup1 = new FilesAnalyze(path,regexp);        fileGroup1.print(System.out);    }    public static void main (String[] args) {        output("C://","[A-z|.]*");    }</pre><blockquote><p>原文部分转载自<a href="http://blog.csdn.net/kdnuggets/article/details/2526588" target="_blank" rel="noopener">Java正则表达式入门</a>。推荐一个比较好用的资料网站<a href="http://www.runoob.com/" target="_blank" rel="noopener">菜鸟教程</a>，其中有很多的基本资料方便查询，以及<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">JavaApI文档</a>。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> RegEx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate--从Session的save()方法看持久态、缓存</title>
      <link href="/2016/10/30/PersistantState-Cache-Hibernate/"/>
      <url>/2016/10/30/PersistantState-Cache-Hibernate/</url>
      
        <content type="html"><![CDATA[<p>前不久学习Hibernate时候在资料书上看到这样一句话<strong>“持久态对象在数据库中都有相对应的记录”</strong>，而后在有关于Session的save()方法的代码注释出又看到了另一句话<strong>“因为未提交事务，所以没有对数据库进行访问”</strong>。于是产生了疑惑。</p><a id="more"></a><ol><li><p>接下来编写个测试程序：</p><pre class="lang:java decode:true">public class Test implements Runnable{public static Thread t1=new Thread(new Test());public static Thread t2=new Thread(new Test());public static Transaction tx=null;public static Session session=null;public static void main(String args[]){    try{        session=HibernateSessionFactory.getSession();        PrintInfofromDatabase();        tx=session.beginTransaction();        System.out.println("---开始事务成功---");        Dlb dlb=new Dlb("138438","sb1@sb1");        session.save(dlb);        System.out.println("---save操作成功---");        PrintInfofromDatabase();        t1.start();    }catch(Exception e){        e.printStackTrace();    }}@Overridepublic void run() {    try {        System.out.println("---线程开始休眠10S---");        Thread.sleep(10000);        System.out.println("---线程结束休眠---");        System.out.println("开始commit操作");        tx.commit();        System.out.println("事务提交成功---");        PrintInfofromDatabase();    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();        if(tx!=null) tx.rollback();    }}public static void PrintInfofromDatabase(){}//通过JDBC查询数据库并打印}</pre></li><li><p>查看输出结果如下：<img src="/images/2017/09/Hibernate4.jpg" alt></p></li><li><p>上图左边第二次select命令是在线程休眠期间执行的，可知save()命令在提交事务前并没有进行数据库操作。上面那句话<strong>“持久态对象在数据库中都有相对应的记录”</strong>让我们进入到这个误区的。</p></li><li><p>接着说一说其中究竟怎么操作的：Hibernate中提供Session级别的缓存，属于事务范围，且只存在于Session的生命周期中。当调用Session接口的save()、update()、saveorupdate()、get()等方法时，如果在Session的缓存中还不存在相应的对象，Hibernate就会把该对象加入到缓存中。Session接口提供两个管理缓存的方法。</p></li></ol><ul><li>ecivt(object obj)：用于将某个对象从Session的缓存中清除。</li><li>clear()：用于将一级缓存（Session级缓存）中的所有对象全部清除,但不包括操作中的对象。<br>值得一提的是flush()方法：强制更新缓存，并提交事务。（<em>Flushing</em> is the process of synchronizing the underlying persistent store with persistable state held in memory.）</li></ul><p>编写测试程序，和查看API文档是解决问题的有效途径。<a href="http://docs.jboss.org/hibernate/orm/5.2/javadocs/" target="_blank" rel="noopener">HibernateAPI文档链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
