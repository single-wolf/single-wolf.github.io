<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>污力大熊的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhongm.in/"/>
  <updated>2019-09-25T12:37:10.818Z</updated>
  <id>http://zhongm.in/</id>
  
  <author>
    <name>污力大熊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ByteToMessageDecoder问题的解决</title>
    <link href="http://zhongm.in/2019/09/25/To-Solve-Two-Problem-In-Using-ByteToMessageDecoder/"/>
    <id>http://zhongm.in/2019/09/25/To-Solve-Two-Problem-In-Using-ByteToMessageDecoder/</id>
    <published>2019-09-25T06:40:37.000Z</published>
    <updated>2019-09-25T12:37:10.818Z</updated>
    
    <content type="html"><![CDATA[<p>在使用某RPC框架过程中，遇到两个因使用 <code>ByteToMessageDecoder</code> 不当而导致的两个小问题，如下列示例代码所示：</p><pre>    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List\<object\> list) throws Exception {        byteBuf.markReaderIndex();        int dataLength = byteBuf.readInt();        if (byteBuf.readableBytes() < dataLength) {            // 未校验最大长度，存在安全隐患            byteBuf.resetReaderIndex();            return;        }        int rpcMagicVal = byteBuf.readShort();        if (rpcMagicVal != Rpc.MAGIC_VALUE) {            // 此处直接close或抛异常后close将导致decode()被重复调用            ctx.close();        }        // DO ACTUAL CODEC    }</object\></pre><a id="more"></a><h3 id="问题一-未对报文做长度校验，存在OOM隐患"><a href="#问题一-未对报文做长度校验，存在OOM隐患" class="headerlink" title="问题一 未对报文做长度校验，存在OOM隐患"></a>问题一 未对报文做长度校验，存在OOM隐患</h3><p>如上面代码片段中：</p><pre>        byteBuf.markReaderIndex();        int dataLength = byteBuf.readInt();        // byteBuf中可读信息不足，等待后续报文        if (byteBuf.readableBytes() < dataLength) {            // 未校验最大长度，存在安全隐患            byteBuf.resetReaderIndex();            return;        }</pre><p>当收到的报文长度标识位过长，则 <code>ByteToMessageDecoder</code> 继续将把后续报文存入 <code>ByteBuf</code> 中，当遇到恶意报文时将导致应用<strong>OOM</strong>。顺便提一下 <code>ByteToMessageDecoder</code> 中提供两种 <code>ByteBuf</code> 的叠加机制。</p><ol><li><strong>MERGE_CUMULATOR</strong> 通过拷贝来实现叠加，不足则申请新 <code>ByteBuf</code> 再拷贝进去</li><li><strong>COMPOSITE_CUMULATOR</strong> 通过组合来实现叠加，直接使用 <code>CompositeByteBuf</code>不需要拷贝</li></ol><p>默认的是使用<strong>MERGE_CUMULATOR</strong>，在累计报文大小到达 <code>DIRECT_MEMORY_LIMIT</code>的一半或是堆内存的一半时，应用就将<strong>OOM</strong>报错</p><h3 id="问题二-关闭Channel前未释放ByteBuf，导致decode-被多次调用"><a href="#问题二-关闭Channel前未释放ByteBuf，导致decode-被多次调用" class="headerlink" title="问题二 关闭Channel前未释放ByteBuf，导致decode()被多次调用"></a>问题二 关闭Channel前未释放ByteBuf，导致decode()被多次调用</h3><p>如上面代码片段中：</p><pre>        int rpcMagicVal = byteBuf.readShort();        if (rpcMagicVal != Rpc.MAGIC\_VALUE) {            // 此处直接close将导致decode()被重复调用            ctx.close();        }</pre><p>或是如</p><pre>        int rpcMagicVal = byteBuf.readShort();        if (rpcMagicVal != Rpc.MAGIC\_VALUE) {            // 此处直接抛异常并在别的Handler做channel.close()将导致decode()被重复调用            throw new RuntimeException("INVALID MSG");        }</pre><p>当解析报文遇到不合法的报文时，上面代码选择关闭此 <code>channel</code>，并为对 <code>byteBuf</code> 进行释放，这将导致此 <code>ByteToMessageDecoder</code> 的实现类的 decode() 方法被多次调用。造成此问题的原因有两</p><h4 id="多次调用原因一（直接在decode调用close）"><a href="#多次调用原因一（直接在decode调用close）" class="headerlink" title="多次调用原因一（直接在decode调用close）"></a>多次调用原因一（直接在decode调用close）</h4><p><code>Netty4</code> 默认每个 <code>Channel</code> 上所有操作都归一个线程排队操作，所以在调用了 <code>ctx.close()</code> 并不会立即触发 <code>channelInactive</code> 等。线程将继续走完本次 <code>decode()</code> ，而我们看父类调用此  <code>decode()</code> 的地方 <code>ByteToMessageDecoder.callDecode()</code> </p><pre>    protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List\<object\> out) {        try {            // 只要是可读就循环            while (in.isReadable()) {                int outSize = out.size();                if (outSize > 0) {                    fireChannelRead(ctx, out, outSize);                    out.clear();                    if (ctx.isRemoved()) {                        //被Remove才跳出                        break;                    }                    outSize = 0;                }                int oldInputLength = in.readableBytes();                // 实际调用子类decode()方法处                decodeRemovalReentryProtection(ctx, in, out);                if (ctx.isRemoved()) {                    //被Remove才跳出                    break;                }                if (outSize == out.size()) {                    if (oldInputLength == in.readableBytes()) {                        // 未解码出东西且未移动读索引则跳出                        break;                    } else {                        //否则继续                        continue;                    }                }                // ignore some code            }        } catch (DecoderException e) {            throw e;        } catch (Exception cause) {            throw new DecoderException(cause);        }    }</object\></pre><p>如上所示在我们未解码出东西放入 <code>out</code> 且移动了读索引 <code>byteBuf.readShort()</code> 情况下是满足循环条件的，因此不可避免地就<strong>对一条错误的报文多次调用<code>decode()</code></strong></p><h4 id="多次调用原因二（在decode中throw-Exception）"><a href="#多次调用原因二（在decode中throw-Exception）" class="headerlink" title="多次调用原因二（在decode中throw Exception）"></a>多次调用原因二（在decode中throw Exception）</h4><p>如上面代码所示，直接在其中抛出异常貌似能跳出 <code>while (in.isReadable())</code> 的循环，为什么还是会调用 <code>decode()</code> 呢？</p><p>这是因为设计者为了防止 <code>channel.close()</code> 后而丢失暂存在 <code>ByteToMessageDecoder</code> 的信息，在  <code>ByteToMessageDecoder.channelInactive()</code> 中还进行了如下操作：</p><pre>    void channelInputClosed(ChannelHandlerContext ctx, List\<object\> out) throws Exception {        // 若累计暂存的ByteBuf不为空，则继续调用上段代码循环解码        if (cumulation != null) {            callDecode(ctx, cumulation, out);            decodeLast(ctx, cumulation, out);        } else {            // 方法内容如下，其实不进行任何操作            decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);        }    }        protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List\<object\> out) throws Exception {        if (in.isReadable()) {            decodeRemovalReentryProtection(ctx, in, out);        }    }</object\></object\></pre><h4 id="两种原因通用的解决方案"><a href="#两种原因通用的解决方案" class="headerlink" title="两种原因通用的解决方案"></a>两种原因通用的解决方案</h4><p>在调用  <code>ctx.close()</code> 或 抛出异常前将所给参数 <code>byteBuf</code> 变成不可读，如下：</p><pre>        int rpcMagicVal = byteBuf.readShort();        if (rpcMagicVal != Rpc.MAGIC_VALUE) {            // 或byteBuf.readerIndex(byteBuf.writerIndex())均可            byteBuf.skipBytes(byteBuf.readableBytes());            ctx.close();        }</pre><p>此方案能解决第二种起因的道理是 父类的调用解码的入口方法 <code>ByteToMessageDecoder.channelRead()</code> finally    代码块中会对不为空但不可读的叠加 <code>ByteBuf</code> 做释放并置空。</p><pre>    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        if (msg instanceof ByteBuf) {            CodecOutputList out = CodecOutputList.newInstance();            try {                // ignore some code                callDecode(ctx, cumulation, out);            } catch (DecoderException e) {                throw e;            } catch (Exception e) {                throw new DecoderException(e);            } finally {                // 对不为空但不可读的叠加ByteBuf做释放并置空                if (cumulation != null && !cumulation.isReadable()) {                    numReads = 0;                    cumulation.release();                    cumulation = null;                }                // ignore some code            }        } else {            ctx.fireChannelRead(msg);        }    }</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用某RPC框架过程中，遇到两个因使用 &lt;code&gt;ByteToMessageDecoder&lt;/code&gt; 不当而导致的两个小问题，如下列示例代码所示：&lt;/p&gt;
&lt;pre&gt;
    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List\&lt;object\&gt; list) throws Exception {
        byteBuf.markReaderIndex();
        int dataLength = byteBuf.readInt();
        if (byteBuf.readableBytes() &lt; dataLength) {
            // 未校验最大长度，存在安全隐患
            byteBuf.resetReaderIndex();
            return;
        }
        int rpcMagicVal = byteBuf.readShort();
        if (rpcMagicVal != Rpc.MAGIC_VALUE) {
            // 此处直接close或抛异常后close将导致decode()被重复调用
            ctx.close();
        }
        // DO ACTUAL CODEC
    }
&lt;/object\&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
      <category term="随笔" scheme="http://zhongm.in/categories/Java/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Spring" scheme="http://zhongm.in/tags/Spring/"/>
    
      <category term="Netty" scheme="http://zhongm.in/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>由RestartClassLoader探索Springboot热部署</title>
    <link href="http://zhongm.in/2019/08/07/Spring-Hot-Reload-Problem/"/>
    <id>http://zhongm.in/2019/08/07/Spring-Hot-Reload-Problem/</id>
    <published>2019-08-07T07:20:40.000Z</published>
    <updated>2019-08-18T15:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在SpringBoot项目引入的依赖的代码中发现下面这样问题，最终确定是由RestartClassLoader导致的，由此展开一步一步探索<br><code><br>// 类名一致，但加载出的类却不相等<br>Class.forName(paramClassNames) == paramClass // false<br></code></p><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Debug 发现 <code>paramClass .getClassLoader()</code> 居然是个<code>RestartClassLoader </code>，然而 <code>Class.forName()</code> 方法则用的是当前调用者的ClassLoader，发现是普通的应用类加载器<code>AppClassLoader</code></p><pre>// JDK Class.forName()方法@CallerSensitivepublic static Class<?> forName(String className) throws ClassNotFoundException {    Class<?> caller = Reflection.getCallerClass();     return forName0(className, true, ClassLoader.getClassLoader(caller), caller);}</pre><h4 id="那么疑问来了"><a href="#那么疑问来了" class="headerlink" title="那么疑问来了"></a>那么疑问来了</h4><ol><li>为什么引用依赖的代码的类加载器是<code>AppClassLoader</code>而项目代码<code>paramClass</code>的类加载器是<code>RestartClassLoader </code>？</li><li>自定义<code>RestartClassLoader </code>的目的、或者说功能是什么？</li></ol><h4 id="为什么ClassLoader不一致"><a href="#为什么ClassLoader不一致" class="headerlink" title="为什么ClassLoader不一致"></a>为什么ClassLoader不一致</h4><p>全局搜索<code>RestartClassLoader </code> 发现其属于依赖 Spring-boot-devtools 引入的包，继承自<code>URLClassLoader</code>，是Spring热部署功能代码，继续反查源码寻找到此类加载器唯一生效的地方。</p><pre>// RestartClassLoader 类构造函数public RestartClassLoader(ClassLoader parent, URL[] urls,        ClassLoaderFileRepository updatedFiles, Log logger) {    super(urls, parent); 。// 父类 URLClassLoader 构造函数}</pre><pre>// Restarter 类中，忽略部分行private Throwable doStart() throws Exception {    ClassLoader parent = this.applicationClassLoader;    URL[] urls = this.urls.toArray(new URL[this.urls.size()]);    ClassLoaderFiles updatedFiles = new ClassLoaderFiles(this.classLoaderFiles);    ClassLoader classLoader = new RestartClassLoader(parent, urls, updatedFiles,            this.logger);    return relaunch(classLoader);}</pre><p>可以看到唯一实例化此类加载器的参数中传入的<code>urls</code>将作为父类<code>URLClassLoader</code>的参数即此类加载器负责加载URL，继续反查确认此<code>urls</code>是<code>Restarter</code>构造函数从传入参数<code>DefaultRestartInitializer.getInitialUrls(Thread)</code>中获取的，获取方式是复制类加载器<code>thread.getContextClassLoader()</code> 中以<code>file:</code>开头以 / 结尾的URLs并通过<code>DevToolsSettings</code>读取<code>META-INF/spring-devtools.properties</code>配置文件进行纳入、排查</p><pre>// Restarter 类构造函数protected Restarter(Thread thread, String[] args, boolean forceReferenceCleanup,        RestartInitializer initializer) {    this.initialUrls = initializer.getInitialUrls(thread); //     this.mainClassName = getMainClassName(thread);    this.applicationClassLoader = thread.getContextClassLoader();}</pre><pre>// DefaultRestartInitializer.getInitialUrls() -> ChangeableUrls()private ChangeableUrls(URL... urls) {    DevToolsSettings settings = DevToolsSettings.get();    List<url> reloadableUrls = new ArrayList<url>(urls.length);    for (URL url : urls) { // 过滤URL        if ((settings.isRestartInclude(url) || isFolderUrl(url.toString()))                && !settings.isRestartExclude(url)) {            reloadableUrls.add(url);        }    }    this.urls = Collections.unmodifiableList(reloadableUrls);}</url></url></pre><p>既然问题请求清晰了，那么我们在<code>Restarter</code>构造函数打个断点看看传入的Thread是哪个线程，又是怎么调用的，过滤后还有哪些URL.</p><blockquote><p>main() -&gt; SpringApplication.run() -&gt; SpringApplicationRunListeners.starting() -&gt;<br>SimpleApplicationEventMulticaster.multicastEvent() RestartApplicationListener.onApplicationEvent() -&gt;<br>RestartApplicationListener.onApplicationStartingEvent() -&gt; Restarter.initialize()</p></blockquote><p>由此我们看到是由实现<code>ApplicationListener</code>的<code>RestartApplicationListener</code>完成对<code>Restarter</code>的初始化的，而此是传入的Thread正是main线程，此线程的ContextClassLoader便是<code>AppClassLoader</code>，所以经过过滤后就将只有类似于 <code>file:/projectPath/projectName/module/target/classes</code>这样的属于此项目代码的URL，所以此类加载器不负责加载第三方jar包的类文件。</p><h4 id="那这个类加载器在哪开始加载类的呢？"><a href="#那这个类加载器在哪开始加载类的呢？" class="headerlink" title="那这个类加载器在哪开始加载类的呢？"></a>那这个类加载器在哪开始加载类的呢？</h4><p>在上文的<code>Restarter.initialize()</code>中初始完<code>Restarter</code>后，将调用此<code>Restarter</code>实例的initialize() 方法，如果是刚实例化的继续调用immediateRestart()并启动另一<code>LeakSafeThread</code>线程执行doStart() 并join()等待，此线程将执行doStart()中<code>RestartClassLoader</code>的实例化，并再启动一<code>RestartLauncher</code>线程，并将实例化的<code>RestartClassLoader</code>设为此线程的ContextClassLoader，在此线程中反射调用Main 方法，从而实现热部署重启，并将应用环境的所有项目中的类交给此自定义的类加载器进行加载。</p><pre>RestartLauncher(ClassLoader classLoader, String mainClassName, String[] args,        UncaughtExceptionHandler exceptionHandler) {    this.mainClassName = mainClassName;    //省略    setContextClassLoader(classLoader); // 设置此线程上下文类加载器}@Overridepublic void run() {    try {// 此线程反射调用main方法        Class<?> mainClass = getContextClassLoader().loadClass(this.mainClassName);        Method mainMethod = mainClass.getDeclaredMethod("main", String[].class);        mainMethod.invoke(null, new Object[] { this.args });    }    catch (Throwable ex) {        //省略    }}</pre><h4 id="ClassLoader不一致的解决方法"><a href="#ClassLoader不一致的解决方法" class="headerlink" title="ClassLoader不一致的解决方法"></a>ClassLoader不一致的解决方法</h4><ol><li>最粗暴的方式就是直接去除依赖 Spring-boot-devtools </li><li>如果确实想要热部署功能，Springboot也提供了配置，没错就是上文提到的过滤URLs时使用<code>DevToolsSettings</code>读取<code>META-INF/spring-devtools.properties</code>配置文件进行纳入、排查，你可以自己新建 spring-devtools.properties 文件，配置上需要此自定义类加载器负责来加载的正则表达式，形式如（exclude表示排查、include表示纳入）：<pre>restart.exclude.spring-boot=/spring-boot/target/classes/restart.exclude.spring-boot-devtools=/spring-boot-devtools/target/classes/restart.exclude.spring-boot-starters=/spring-boot-starter-[\\w-]+/</pre></li></ol><p>restart.include.commons-pool2=/org/apache/commons/commons-pool2/2.4.3/commons-pool2-2.4.3.jar<br></p><h4 id="Spring热部署过程触发机制"><a href="#Spring热部署过程触发机制" class="headerlink" title="Spring热部署过程触发机制"></a>Spring热部署过程触发机制</h4><p>既然我们已经探寻了<code>RestartClassLoader </code>，那么肯定也会好奇，这Spring是怎么实现类文件变更后自动触发重启的呢？<br>细看其实分成两部分，一部分是对文件变更的监视，一部分是将变更通知到容器实现应用重启。关键配置类为<code>LocalDevToolsAutoConfiguration</code>（实现本地热部署）和<code>RemoteClientConfiguration</code>（通过HTTP发送变更文件信息通知远程热部署），我们就以<code>LocalDevToolsAutoConfiguration</code>为例。</p><pre>// 本地热部署配置类public class LocalDevToolsAutoConfiguration {    // 实现静态资源文件变更自动刷新页面而非重启应用    static class LiveReloadConfiguration {        // 与WS或JS脚本实现页面刷新        public LiveReloadServer liveReloadServer() {            return new LiveReloadServer(this.properties.getLivereload().getPort(),                    Restarter.getInstance().getThreadFactory());        }        // 省略配置    }    // 实现文件变更自动重启应用    static class RestartConfiguration {        // 监听文件变更事件        @EventListener        public void onClassPathChanged(ClassPathChangedEvent event) {            if (event.isRestartRequired()) {                Restarter.getInstance().restart(                        new FileWatchingFailureHandler(fileSystemWatcherFactory()));            }        }        // 文件变更监视        @Bean        @ConditionalOnMissingBean        public ClassPathFileSystemWatcher classPathFileSystemWatcher() {            URL[] urls = Restarter.getInstance().getInitialUrls();            ClassPathFileSystemWatcher watcher = new ClassPathFileSystemWatcher(                    fileSystemWatcherFactory(), classPathRestartStrategy(), urls);            watcher.setStopWatcherOnRestart(true);            return watcher;        }        // 省略部分配置    }}</pre><p>可见，是由<code>ClassPathFileSystemWatcher</code>实现对文件变更的监视并通过<code>ClassPathChangedEvent</code>事件通知来触发 <code>Restarter.restart()</code>也就是上文描述的步骤 <strong>实例化<code>RestarterClassLoader</code></strong> –&gt; <strong>将其设为线程上下文类加载器</strong> –&gt; <strong>再反射调用Main方法</strong>。</p><p>细看<code>ClassPathFileSystemWatcher</code>传入的参数<code>urls</code>会发现正是等于上文提到的<code>RestarterClassLoader</code>的传入参数。再深入此类可知其是通过<code>DevToolsProperties</code>来配置诸如，等</p><ul><li>restart.exclude 实现指定文件变更不重启，如静态资源文件</li><li>restart.pollInterval 控制监视轮询间隔</li><li>restart.additionalExclude 指定额外的监视路径</li></ul><p>而真正实现文件变更监视的<code>FileSystemWatcher</code>，其实现只是扫描目录下所有文件，与初始的文件信息快照做对比。不过有一点倒挺细节的，就是不仅控制监视轮询间隔，还能通过<code>restart.pollInterval</code> 设置文件变更后多长时间不再继续变更，才触发重启，以防止项目批量编译类文件。</p><pre>private void scan() throws InterruptedException {    Thread.sleep(this.pollInterval - this.quietPeriod); //    Map<file, foldersnapshot> previous;    Map<file, foldersnapshot> current = this.folders;    do {        previous = current;        current = getCurrentSnapshots();        Thread.sleep(this.quietPeriod);  // 等待    }    while (isDifferent(previous, current)); //有变更就循环    if (isDifferent(this.folders, current)) {        updateSnapshots(current.values());    }}</file,></file,></pre><p>本地热部署重启就到这了，有兴趣的童鞋也可以看看热部署页面自动刷新<code>LiveReload</code>、远程热部署重启 等，机制都是相同的，以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SpringBoot项目引入的依赖的代码中发现下面这样问题，最终确定是由RestartClassLoader导致的，由此展开一步一步探索&lt;br&gt;&lt;code&gt;&lt;br&gt;// 类名一致，但加载出的类却不相等&lt;br&gt;Class.forName(paramClassNames) == paramClass // false&lt;br&gt;&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
      <category term="随笔" scheme="http://zhongm.in/categories/Java/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Java" scheme="http://zhongm.in/tags/Java/"/>
    
      <category term="Spring" scheme="http://zhongm.in/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>微积分&amp;概率论基础总结</title>
    <link href="http://zhongm.in/2017/11/13/Basis-Of-ProbabilityStatistics-And-Calculus/"/>
    <id>http://zhongm.in/2017/11/13/Basis-Of-ProbabilityStatistics-And-Calculus/</id>
    <published>2017-11-13T13:33:08.000Z</published>
    <updated>2017-11-13T17:05:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近自己也跟着了解学习机器学习方面知识，打算先从统计数理基础知识开始着手。已下为对微积分和概率论基础知识总结，后续将补充更深入更全面的知识总结。</p><a id="more"></a><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><h3 id="函数与极限"><a href="#函数与极限" class="headerlink" title="函数与极限"></a>函数与极限</h3><h4 id="两遍夹定理"><a href="#两遍夹定理" class="headerlink" title="两遍夹定理"></a>两遍夹定理</h4><p>$$\forall x \in \cup (x0,r) ,g(x)\leqslant f(x)\leqslant h(x)$$<br>$$\mbox{且 }\lim _{x\to x _0}g(x)=A,\lim _{x\to x _0}h(x)=A,\mbox{则 } \lim _{x\to x _0}f(x)=A$$</p><h4 id="极限存在定理"><a href="#极限存在定理" class="headerlink" title="极限存在定理"></a>极限存在定理</h4><p>数列单调递增（减）且有上（下）界，则该数列必有极限<br>$$\lim_{x\to \infty}(1+\frac{1} {x})^x=e$$<br>上面极限使用两遍夹定理求得</p><h3 id="导数与积分部分"><a href="#导数与积分部分" class="headerlink" title="导数与积分部分"></a>导数与积分部分</h3><h4 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h4><p>一阶导数就是曲线的斜率，是曲线变化快慢的反应。而二阶导数是斜率变化的快慢的反应，表示曲线的凹凸性</p><p>求导常用的关系式<br>$${(u+v)}’={u}’+{v}’$$<br>$${uv}’={u}’{v}+{v}’{u}$$</p><h4 id="幂指函数的一般处理策略"><a href="#幂指函数的一般处理策略" class="headerlink" title="幂指函数的一般处理策略"></a>幂指函数的一般处理策略</h4><p>$$\mbox{已知幂指 }f(x) = x^x,x\gt 0,\mbox{求 }f(x) \mbox{最大值}$$<br>$$\mbox{设 }t = x^x,\mbox{则 } \ln t = x\ln x$$<br>$$\frac{1} {t} t’ = \ln x+1 \mbox{两边求导},\mbox{令 }t’ = 0,\ln x+1=0，\mbox{得 }x=e^-1,t=e^{- \frac{1} {e}}$$</p><h4 id="泰勒Taylor公式"><a href="#泰勒Taylor公式" class="headerlink" title="泰勒Taylor公式"></a>泰勒Taylor公式</h4><p>$$f(x)=f(x_0)+f’(x_0)(x-x_0)+\frac{f’’(x_0)} {2!} (x-x_0)^2+…+\frac{f^{n}(x_0)} {n!}(x-x_0)^n+R_n(x)$$<br>$R_n(x)$为函数$X$在$x_0$处的n阶段无穷小</p><h4 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h4><p>方法导数讨论的是二元函数 $z=f(x,y)$在一定$P$上沿着某个方向的变化率问题。<br>$$\frac{\partial f}{\partial x}=\lim_{\rho\to0} \frac{f(x+\Delta x,y+\Delta y)-f(x,y)} {\rho}$$<br>若此极限存在，称该极限为函数$z=f(x,y)$在点$p$沿方向$l$上的方向导数<br>关于方向导数的定理如下：</p><blockquote><p>如果函数$z=f(x,y)$在点$P$上可微分，那么函数在该点的任意方向$l$的方向导数都存在，而且有：<br>$$\frac{\partial f} {\partial l}=\frac{\partial f} {\partial x} cos\varphi+\frac{\partial f} {\partial y}sin\varphi$$<br>其中$\varphi$为$x$轴正方向到射线$l$的转角</p></blockquote><h4 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h4><p>凸函数的<strong>定义</strong>：</p><blockquote><p>函数$f(x)$在区间$I$，如果对区间$I$上的任意两点$x,y$，恒有以下不等式成立：<br>$$f(\theta x+(1-\theta)y)\leqslant\theta f(x)+(1-\theta)f(y),\mbox{其中 }\theta\in[0,1]$$<br>则称$f(x)$在区间$I$上是凸的</p></blockquote><p>凸函数的判定：如果$f(x)$在区间[a,b]上连续，在(a,b)内二阶可导，那么：</p><ul><li>如果$f’’(x)&gt;0$，则$f(x)$是凸的；</li><li>如果$f’’(x)&lt;0$，则$f(x)$是凹的；</li></ul><p>假如$f(x)$为凸函数，还可对上面的不等式进行拓展：$$f(\theta_1x_1+…+\theta_nx_n)\leqslant\theta_1f(x_1)+…+\theta_nf(x_n)$$<br>其中$\theta_i\in[0,1],\theta_1+…+\theta_n=1$</p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><h4 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h4><p><strong>定义</strong>：设$A,B$是两个事件，且P(A)&gt;0，称$$P(B|A)=\frac{P(AB)} {P(A)}$$<br>为在事件$A$发生的条件下事件$B$发生的条件概率</p><h4 id="乘法定理"><a href="#乘法定理" class="headerlink" title="乘法定理"></a>乘法定理</h4><p>设$P(A)&gt;0$，则有$$P(AB)=P(B|A)P(A)$$<br>推广到多个事件的积事件的情况，例如，假设$A,B,C$为事件，且$P(AB)&gt;0$，这有$$P(ABC)=P(C|AB)P(B|A)P(A)$$</p><h4 id="全概率公式和贝叶斯公式"><a href="#全概率公式和贝叶斯公式" class="headerlink" title="全概率公式和贝叶斯公式"></a>全概率公式和贝叶斯公式</h4><p><strong>定义</strong>：设$S$为试验$E$的样本空间，$B_1,B_2,\cdots,B_n$为$E$的一组事件。若</p><ol><li>$B_i B_j=\varnothing  ,i\neq  j,i,j=1,2,\cdots,n$</li><li>$B_1\cup B_2\cup\cdots\cup B_n=S$</li></ol><p>则称$B_1,B_2,\cdots,B_n$为样本空间$S$的一个<strong>划分</strong></p><p>若$B_1,B_2,\cdots,B_n$是样本空间$S$的一个<strong>划分</strong>，则对每次试验，事件$B_1,B_2,\cdots,B_n$中必有且仅有一个发生<br><strong>定理</strong> 设试验$E$的样本空间为$S$，$A$为$E$的事件，$B_1,B_2,\cdots,B_n$为$S$的一个划分，且$P(B_i)&gt;0(i=1,2,\cdots,n)$，则$$P(A)=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+\cdots+P(A|B_n)P(B_n)$$<br>称为<strong>全概率公式</strong></p><p><strong>定理</strong> 设试验$E$的样本空间为$S$，$A$为$S$的事件，$B_1,B_2,\cdots,B_n$为$S$的一个划分，且$P(A)&gt;0,P(B_i)&gt;0 (i=1,2,\cdots,n)$,则$$P(B_i|A)=\frac{P(B_i A)} {P(A)}=\frac{P(A|B_i)P(B _i)} {\sum _{i=1}^{n} P(A|B _i)P(B _i)}$$<br>称为<strong>贝叶斯公式</strong></p><h3 id="常见分布"><a href="#常见分布" class="headerlink" title="常见分布"></a>常见分布</h3><p>常见分布包括：<br>离散型概率分布：两点分布、二项分布、泊松分布；<br>连续型概率分布：均匀分布、指数分布、高斯分布；</p><h4 id="两点分布（伯努利实验）"><a href="#两点分布（伯努利实验）" class="headerlink" title="两点分布（伯努利实验）"></a>两点分布（伯努利实验）</h4><p>离散分布的期望：$E(X)=1\cdot p+0\cdot (1-p)=p$<br>方差：$D(X)=E(X^2)-[E(X)]^2=pq$</p><h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p>将伯努利试验单独重复地进行$n$次，称这一串重复的独立实验为$n$重伯努利实验。<em>重复</em>是指每次试验$p$保持不变；<em>独立</em>指的是每次试验结果互不影响。在抛$n$次硬币的试验中，令随机变量$X$表示字面朝上的次数，那么令$f(x)=P(X=x)$为概率质量函数，则：$$f(x)=\begin{cases}<br> &amp; \binom{n}{x}p^x(1-p)^{n-x}  ,x=0,\cdots n \<br> &amp;  0,els<br>\end{cases}$$<br>如果某一随机变量的概率质量函数如上式所述，那么我们称这类随机变量为二项分布随机变量，可以表示为$X\sim Binomial(n,p)$，即随机变量$X$服从参数为(n,p)二项分布。</p><blockquote><p>二项分布的期望：<br>$$E(X)=\sum _{k=0}^{n}k\cdot p(X=x)=\sum _{k=0}^{n}k\cdot \binom{n}{x}p^x(1-p)^{n-x} \\ =\sum _{k=0}^{n}k\cdot \frac{n!} {k!(n-k)!}p^k (1-p)^{n-k}=np\sum _{k=1}^{n}\cdot \frac{(n-1)!} {(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k}$$<br>设$a=k-1,b=n-1$，那么$$=np\sum _{a=0}^{b}\frac{b!} {a!(b-a)!}p^a(1-p)^{b-a}=np\sum _{a=0}^{b}\binom{b}{a}p^a(1-p)^{b-a}=np$$</p></blockquote><h4 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h4><p>如果试验次数n很大，二项分布的概率p很小，且乘积λ= np比较适中，则事件出现的次数的概率可以用泊松分布来逼近。事实上，二项分布可以看作泊松分布在离散时间上的对应物。<br>回顾$e$的定义：$$\lim_{n\to\infty}(1-\frac{\lambda} {n})^n=e^{-\lambda}$$<br>此定义由上文推导得来。</p><p>二项分布定义：$$P(X=k)= \binom{n}{x}p^x(1-p)^{n-x}$$<br>如果令$p=\frac{\lambda} {n}$，$n$趋于无穷时$P$的极限：<br>$$\lim _{n\to\infty}P(X=k)=\lim _{n\to\infty}\binom{n}{k}p^x(1-p)^{n-x}=\lim _{n\to\infty}\frac{n!}{(n-k)!k!}\left(\frac{\lambda}{n}\right)^k\left(1-\frac{\lambda}{n}\right)^{n-k}\\ =\lim _{n\to\infty}\left[\frac{n!}{n^k(n-k)!}\right]\left(\frac{\lambda^k}{k!}\right)\left(1-\frac{\lambda}{n}\right)^n\left(1-\frac{\lambda}{n}\right)^{-k}\\ =\lim _{n\to\infty}\left[\left(1-\frac{1}{n}\right)\left(1-\frac{2}{n}\right)\cdots\left(1-\frac{k-1}{n}\right)\right]\left(\frac{\lambda^k}{k!}\right)\cdot e^{-\lambda}\cdot 1\ =\left(\frac{\lambda ^k}{k!}\right)\cdot e^{-\lambda}$$</p><p>泊松分布期望推导：</p><blockquote><p>回顾泰勒公式，将函数$e^x$在$x$处的泰勒公式展开：$$e^x=1+x+\frac{x^2}{2!}+\cdots+\frac{x^k}{k!}+R _k$$<br>式子两侧同事乘以$e^{-x}$，可以得到：$$1=1\cdot e^{-x}+x\cdot e^{-x}+\frac{x^2}{2!}\cdot e^{-x}+\cdots+\frac{x^k}{k!}\cdot e^{-x}+R _k\cdot e^{-x}$$<br>如此可以看出，上面展开式右侧每一项的$\frac{x^k}{k!}\cdot e^{-x}$就是上文泊松分布的概率质量函数，只不过此处$x=\lambda$，接下来使用上述结论推导期望：<br>设$X \sim \pi (x)$，则概率质量函数为：$$P(X=k)=\frac{\lambda ^k}{k!}\cdot e^{-\lambda}$$<br>则有期望：$$E(X)=\sum _{k=0}^{\infty}k\cdot \frac{\lambda ^k}{k!}\cdot e^{-\lambda}=\lambda\sum _{k=1}^{\infty}(\frac{\lambda ^{k-1}}{(k-1)!}e^{-\lambda})=\lambda\cdot 1=\lambda$$<br>推导方差：$$E(X^2)=E[X(X-1)+X]=\sum _{k=0}^{+\infty}k(k-1)\cdot \frac{\lambda ^k}{k!}e^{-\lambda}+\lambda\\ =\lambda^2e^{-\lambda}\sum _{k=2}^{+\infty}\cdot\frac{\lambda^{k-2}}{(k-2)!}+\lambda=\lambda^2e^{-\lambda}e^\lambda+\lambda=\lambda^2+\lambda$$$$D(X)=E(X^2)-[E(X)]^2=\lambda$$</p></blockquote><h4 id="泊松定理"><a href="#泊松定理" class="headerlink" title="泊松定理"></a>泊松定理</h4><p>设$\lambda &gt;0$是一个常数，$n$是任意一个正整数，设$np _n=\lambda$（在二项分布(n,p)中p即为$p _n$），则对于任一固定的非负整数$k$，有：$$\lim _{n\to\infty}\binom{n}{k}p _n^k(1-p _n)^{n-k}=\frac{\lambda^k}{k!}\cdot e^{-\lambda}$$<br>定理的条件 $np _n=\lambda$（常数）意味当n很大时 $p _n$ 必然很小，因此，上述定理表明当n很大且p很小时有以下近似值：<br>$$ \binom{n}{k}p^k(1-p)^{n-k}\approx \frac{\lambda^k}{k!}\cdot e^{-\lambda} $$<br>也就是说已n,p为参数的二项分布的概率值可以由参数为 $ \lambda=np $ 的泊松分布的概率值来近似。当然这必须满足一定的条件：n很大且p很小。</p><h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>设$X\sim U(a,b)$，其概率密度为：$$f(x)=\begin{cases}<br> &amp; \frac{1}{b-a}  ,a&lt;x&lt;b, \\<br> &amp;  0, els<br>\end{cases}$$那么可以得到$$E(X)=\int _{-\infty}^{+\infty}xf(x)dx=\int _{a}^{b}x\cdot \frac{1}{b-a}dx=\frac{1}{2}(a+b)$$<br>方差$$D(X)=E(X^2)-[E(X)]^2=\int _{a}^{b}x^2\cdot \frac{1}{b-a}dx-[\frac{1}{2}(a+b)]^2=\frac{(b-a)^2}{12}$$</p><h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><p>假设随机变量$X$服从指数分布，它的概率密度函数可以写成两种形式：<br>$$f(x)=\begin{cases}&amp; \frac{1}{\theta}e^{-\frac{x}{\theta}}  ,x&gt;0, \\ &amp;  0, x\leqslant 0 .\end{cases} \mbox{其中 }\theta&gt;0 and f(x)=\begin{cases}&amp;\lambda e^{-\lambda x}  ,x&gt;0, \\ &amp;  0, x\leqslant 0 .\end{cases} \mbox{其中 }\lambda&gt;0 $$<br>其中$\lambda &gt;0 $被称为率参数，即每个单位时间内发生某事件的次数。简单记为：$X\sim Exponential(\lambda) \mbox{或 }X\sim E(\lambda)$</p><p>无后效性是指数分布的特征。</p><h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><p>正态分布又称为高斯分布，在机器学习领域正态分布使用得非常广泛。<br>设$\mu$是常数，$\sigma$是正常数，如果$X$的密度是<br>$$f(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e\left(-\frac{(x-\mu)^2}{2\sigma^2}\right),x\in R$$<br>就称$X$服从参数为$(\mu,\sigma)$的正态分布，记作$X\sim N(\mu,\sigma)$。这里N为Normal的缩写</p><p>特别的，当$X\sim N(0,1)$时，称$X$服从<strong>标准正态分布</strong>，标准正态分布的密度函数有特殊的地位，所以用一个特定的符号$\varphi$表示：<br>$$\varphi(x)=\frac{1}{\sqrt{2\pi}}e\left(-\frac{x^2}{2}\right),x\in R$$<br>正态分布的密度特点：</p><ul><li>参数$\mu$是密度的中心和最大值点，密度在$\mu$两侧对称；</li><li>参数$\sigma$代表密度的宽度，$\varphi$越大密度越宽。</li></ul><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ol><li>《高等数学》同济大学</li><li>《概率统计讲义》 何书元</li><li><a href="https://www.zybuluo.com/frank-shaw/note/139175" target="_blank" rel="noopener">三月机器学习在线班第一课</a> @frank-shaw</li></ol><p>以上公式在Markdown中采用<strong>LaTeX</strong>排版，可以在以下获取帮助</p><ol><li><a href="https://www.latex-project.org/" target="_blank" rel="noopener">The LATEX Project </a> 官网</li><li><a href="https://cn.sharelatex.com/" target="_blank" rel="noopener">ShareLaTeX</a> 在线编辑器</li><li><a href="https://www.codecogs.com/latex/eqneditor.php?lang=zh-cn" target="_blank" rel="noopener">简易编辑器</a></li></ol><p>Hexo对LaTeX的支持参考</p><ol><li><a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/" target="_blank" rel="noopener">Hexo 书写 LaTeX 公式时的一些问题及解决方法</a></li></ol><p>温馨提示 ：<strong>多行公式中 \\ 换成 \\\\ 才有效</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近自己也跟着了解学习机器学习方面知识，打算先从统计数理基础知识开始着手。已下为对微积分和概率论基础知识总结，后续将补充更深入更全面的知识总结。&lt;/p&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="http://zhongm.in/categories/MachineLearning/"/>
    
    
      <category term="Probability Statistics" scheme="http://zhongm.in/tags/Probability-Statistics/"/>
    
      <category term="Calculus" scheme="http://zhongm.in/tags/Calculus/"/>
    
  </entry>
  
  <entry>
    <title>Linux架设GitServer、GitWeb</title>
    <link href="http://zhongm.in/2017/11/02/Setup-GitServer-GitWeb-With-Linux/"/>
    <id>http://zhongm.in/2017/11/02/Setup-GitServer-GitWeb-With-Linux/</id>
    <published>2017-11-02T08:06:08.000Z</published>
    <updated>2017-11-08T16:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>起因是公司 SVN 服务器老歇机，有些代码放GitHub 又不怎么合适，且近来 GitHub被墙的贼厉害。只需要简单几步即可搭建自己私有的 Git Server，并通过 Git Web 进行浏览查看。</p><p>环境： Debian 9 ，Nginx/1.10.3</p><a id="more"></a><h3 id="搭建-Git-Server"><a href="#搭建-Git-Server" class="headerlink" title="搭建 Git Server"></a>搭建 Git Server</h3><p>Git 可以通过 git://、http[s]://、ssh://、file:// 等方式实现跨仓库传输数据。相比较使用 http 需要设置 cgi ，而使用自带 git-daemon 没有安全验证，所有此处我们选择使用 ssh 传输的Git Server。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>因使用 ssh，那么在开始前你需要有产生好的 ssh key ，并在 Server/Client 放置好，不熟悉的话可参考：（当然你也可选择每次使用时输入密码。）</p><ul><li><a href="http://plog.longwin.com.tw/my_note/2005/12/28/ssh_keygen_no_passwd" target="_blank" rel="noopener">产生 ssh keygen 免输入密码</a></li><li><a href="http://josephjiang.com/article/understand-ssh-key/" target="_blank" rel="noopener">SSH 免密码登录</a></li></ul><p>先声明一下内容：</p><ul><li>Server : 服务器需公网IP或域名（IP 、example.com）</li><li>Linux：可登录用户及用户群组（VPS:VPS）</li><li>Project name :  项目名（Project_name）</li><li>Git-Repo-Dir：仓库目录（/home/VPS/git-repo）<h4 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h4></li></ul><p><strong>Server 端</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. mkdir /home/VPS/git-repo/project_name.git</span><br><span class="line">2. cd /home/VPS/git-repo/project_name.git</span><br><span class="line">3. git init --bare</span><br><span class="line">4. chown VPS:VPS -R /home/VPS/git-repo/project_name.git</span><br></pre></td></tr></table></figure><p>轻松几步即完成 Server 端搭建</p><p><strong>Client 端</strong>使用</p><ol><li>正常使用如 <code>git clone VPS@（IP或example.com）:/home/VPS/git-repo/project_name.git</code></li><li>若<strong>Client 端</strong>已存在 project_name 的仓库，可通过 <code>git remote add  private VPS@（IP或example.com）:/home/VPS/git-repo/project_name.git</code> ，然后调用<code>git push private</code> 将本地仓库推送到远端空的同名库中。（需是同名且<strong>Server</strong>端库需为空库）</li></ol><h3 id="搭建GitWeb"><a href="#搭建GitWeb" class="headerlink" title="搭建GitWeb"></a>搭建GitWeb</h3><p>其实单纯 Git Server就能满足对远端仓库的需求，搭建 GitWeb 只是提供 HTTP 界面服务方便浏览查看。步骤也很简单</p><p>本文是通过 Nginx 搭建，若想换成 Apache 可参考 <a href="https://blog.longwin.com.tw/2009/05/build-git-env-over-ssh-2009/" target="_blank" rel="noopener">Debian Linux 架設 Gitweb</a></p><h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装需要的软件：</p><pre><code>apt-get install -t wheezy-backports nginx nginx-common git gitweb fcgiwrap</code></pre><p>你需清楚的配置文件</p><ol><li><code>/etc/gitweb.conf</code>  GitWeb配置文件。其中Git仓库目录 默认是<code>/var/lib/git/</code>可修改。</li><li><code>/usr/share/gitweb</code> GitWeb运行目录，包含 <code>index.cgi</code> 脚本</li><li><code>/etc/nginx/sites-available/default</code> Nginx Web服务器默认站配置</li><li><code>/var/run/fcgiwrap.socket</code> Nginx与FastCGI通信Socket</li></ol><p>在运行时如果遇到错误都可以参看 Nginx log 文件：<code>/var/log/nginx/error.log</code> and <code>/var/log/nginx/access.log</code>。</p><h4 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h4><p>创建新文件 <code>/etc/nginx/sites-available/gitweb</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  <span class="comment"># Git 仓库将展示在 http://example.com:4321/</span></span><br><span class="line">  listen 4321 default;   <span class="comment"># 如果80已占用，去除 default。也可为其他端口</span></span><br><span class="line">  server_name example.com; <span class="comment"># Server 域名</span></span><br><span class="line"></span><br><span class="line">  location /index.cgi &#123;</span><br><span class="line">    root /usr/share/gitweb/;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    gzip off;</span><br><span class="line">    fastcgi_param SCRIPT_NAME <span class="variable">$uri</span>;</span><br><span class="line">    fastcgi_param GITWEB_CONFIG /etc/gitweb.conf;</span><br><span class="line">    fastcgi_pass  unix:/var/run/fcgiwrap.socket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    root /usr/share/gitweb/;</span><br><span class="line">    index index.cgi;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将在 site-enable 中创建配置文件软链接</p><pre><code>ln -s /etc/nginx/sites-available/gitweb /etc/nginx/sites-enabled/gitweb</code></pre><p>然后你可以先测试 Nginx 配置</p><pre><code>sudo nginx -t #若显示成功，重启以加载设置，失败则回去检测;分号是否正确sudo nginx -s reload#或sudo systemctl restart nginx</code></pre><p>搭建好啦！在 <a href="http://example.com:4321/" target="_blank" rel="noopener">http://example.com:4321/</a>  你将看到你的仓库，没有则为”No projects found”</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>如果不希望谁都能在公网上看到自己的仓库，也可以通过简单几步加上一个验证。</p><p>安装apache2-utils</p><pre><code>sudo apt-get install apache2-utils</code></pre><p>在 <code>/usr/share/gitweb/</code>下创建用户密码文件</p><pre><code>sudo htpasswd -c htpasswd Username#Username 为用户名，之后按提示输入密码</code></pre><p>完成后修改上面 Nginx 配置文件中第二个 location 部分为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> location / &#123;</span><br><span class="line">auth_basic <span class="string">"Git Login"</span>; <span class="comment"># 加上这两行</span></span><br><span class="line">auth_basic_user_file <span class="string">"/usr/share/gitweb/htpasswd"</span>;<span class="comment"># 文件</span></span><br><span class="line">   root /usr/share/gitweb/;</span><br><span class="line">   index index.cgi;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再如上文重启或 reload Nginx。可以看到你私有带验证的GitWeb就搭建好了 XD</p><p>参考 [<a href="https://blog.longwin.com.tw/2009/05/build-git-env-over-ssh-2009/" target="_blank" rel="noopener">Debian Linux 架設使用 SSH 存取 的 Git Server</a>][<a href="https://gist.github.com/mcxiaoke/055af99e86f8e8d3176e" target="_blank" rel="noopener">Set up Gitweb + Nginx </a>]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因是公司 SVN 服务器老歇机，有些代码放GitHub 又不怎么合适，且近来 GitHub被墙的贼厉害。只需要简单几步即可搭建自己私有的 Git Server，并通过 Git Web 进行浏览查看。&lt;/p&gt;
&lt;p&gt;环境： Debian 9 ，Nginx/1.10.3&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://zhongm.in/categories/Linux/"/>
    
    
      <category term="Debian" scheme="http://zhongm.in/tags/Debian/"/>
    
      <category term="Git" scheme="http://zhongm.in/tags/Git/"/>
    
      <category term="nginx" scheme="http://zhongm.in/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>JShell - Java交互工具（REPL） - 笔记</title>
    <link href="http://zhongm.in/2017/10/20/Java-REPL-Tool-JShell-Notes/"/>
    <id>http://zhongm.in/2017/10/20/Java-REPL-Tool-JShell-Notes/</id>
    <published>2017-10-20T10:44:24.000Z</published>
    <updated>2017-10-20T10:44:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在今年九月正式发布的 Java9 版本中，其 /bin 目录中多个一个交互工具 JShell（据说 Java8 已有测试版）。众所周知，许多编程语言都提供称作 Read-Evaluate-Print Loop （REPL）的命令行工具，它们能够在输入声明、语句及表达式时计算，并立即给出结果。</p><p>以 Python 为例，运行整个工程、项目可能需要很长时间，但是你可以使用此工具执行一些需要确定的表达式，就能立即得到他们返回的值。这对于哪些开始学习语言或者接触语言新功能的程序员来说是个便捷好用的工具。</p><p>然而没 JShell 之前的 Java 来说，你需要编写一个测试类新建 main 方法来打印结果，并且每次修改后需要重写编译、运行。</p><a id="more"></a><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>下载并安装 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Java9</a> ，配置环境变量，或者不配置的话直接在 /bin 目录下就能找到 jshell 可执行文件。建议一开始运行加入 -v 参数，JShell 给出详细反馈。</p><pre><code>root@Mydebian:~$ jdk-9/bin/jshell -v|  欢迎使用 JShell -- 版本 9|  要大致了解该版本, 请键入: /help introjshell&gt; </code></pre><p>此时不需要详情模式，可输入 <em>/set feedback normal</em></p><h2 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h2><p>JShell 默认有一组常用的导入</p><pre><code>jshell&gt; /imports|    import java.util.*、|    import java.io.*|    import java.math.*|    import java.net.*|    import java.util.concurrent.*|    import java.util.prefs.*|    import java.util.regex.*</code></pre><p>你也可以任何时候导入自己想要的通过  <em>import XXX</em> （单击 tab 补全、给出可选）</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>你可以输入任何有效的 Java 表达式，它将得出返回值、类型，并分配给一个变量，如：</p><pre><code>jshell&gt; 3+3$1 ==&gt; 6|  已创建暂存变量 $1 : intjshell&gt; $1$1 ==&gt; 6|  $1 的值: in</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>可以声明变量（默认值），并赋值。一旦声明后，变量即为当前对话中全局变量，再次声明、赋值将覆盖</p><pre><code>jshell&gt; int x=5x ==&gt; 5|  已创建 变量 x : intjshell&gt; xx ==&gt; 5|  x 的值: int</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>也可以定义方法，再次定义将覆盖</p><pre><code>jshell&gt; void hello() { System.out.println(&quot;Hello JShell&quot;); }|  已创建 方法 hello()jshell&gt; hello()Hello JShelljshell&gt; void hello() { System.out.println(&quot;Replace Method&quot;); }|  已修改 方法 hello()|    更新已覆盖 方法 hello()jshell&gt; hello()Replace Method</code></pre><p>不过尝试了下，发现 JShell 定义方法只支持参数重载，不支持返回值重载，后定义将覆盖前面定义的</p><pre><code>jshell&gt; void hello() { System.out.println(&quot;Void No Param&quot;); }|  已创建 方法 hello()jshell&gt; void hello(int x) { System.out.println(&quot;Void INT Param&quot;); }|  已创建 方法 hello(int)jshell&gt; /methods |    void hello()|    void hello(int)jshell&gt; int hello(int x) { System.out.println(&quot;Int INT Param&quot;);return x; }|  已替换 方法 hello(int)|    更新已覆盖 方法 hello(int)jshell&gt; /methods |    void hello()|    int hello(int)jshell&gt; int hello() { System.out.println(&quot;Int No Param&quot;);return 1; }|  已替换 方法 hello()|    更新已覆盖 方法 hello()jshell&gt; /methods |    int hello(int)|    int hello()</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>除了 Java 代码外，你还可以执行一些 JShell 命令。一些常用的如下（键入 <em>help</em> 将列举所有）</p><h3 id="列出变量"><a href="#列出变量" class="headerlink" title="列出变量"></a>列出变量</h3><pre><code>jshell&gt; /vars|    int x = 0|    double j = 0.5</code></pre><h3 id="列出方法"><a href="#列出方法" class="headerlink" title="列出方法"></a>列出方法</h3><pre><code>jshell&gt; /methods|    printf (String,Object...)void|    hello ()void</code></pre><h3 id="列出执行过的代码"><a href="#列出执行过的代码" class="headerlink" title="列出执行过的代码"></a>列出执行过的代码</h3><pre><code>jshell&gt; /list1 : 3+32 : $14 : x5 : int y;6 : y7 : x8 : int x;10 : hello()11 : void hello() { System.out.println(&quot;Replace Method&quot;); }12 : hello()</code></pre><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><pre><code>jshell&gt; /edit hello</code></pre><p>可以后跟方法名（将编辑所有重载方法）、变量名、id。id 就是上面通过 <em>/list</em>  列出的序号。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="验证返回值"><a href="#验证返回值" class="headerlink" title="验证返回值"></a>验证返回值</h3><pre><code>jshell&gt; 1.0/2$6 ==&gt; 0.5|  已创建暂存变量 $6 : doublejshell&gt; 1/2.0$7 ==&gt; 0.5|  已创建暂存变量 $7 : doublejshell&gt; 1/2.0f$8 ==&gt; 0.5|  已创建暂存变量 $8 : floatjshell&gt; 1.0f/2$9 ==&gt; 0.5|  已创建暂存变量 $9 : floatjshell&gt; 1.0f/2.0f$10 ==&gt; 0.5|  已创建暂存变量 $10 : floatjshell&gt; 1.0f/2.0$11 ==&gt; 0.5|  已创建暂存变量 $11 : double</code></pre><h3 id="装箱细节"><a href="#装箱细节" class="headerlink" title="装箱细节"></a>装箱细节</h3><pre><code>jshell&gt; Integer i1=127 i1 ==&gt; 127|  已创建 变量 i1 : Integerjshell&gt; Integer i2=127i2 ==&gt; 127|  已创建 变量 i2 : Integerjshell&gt; i1==i2$14 ==&gt; true|  已创建暂存变量 $14 : booleanjshell&gt; Integer i1=128i1 ==&gt; 128|  已修改 变量 i1 : Integer|    更新已覆盖 变量 i1 : Integerjshell&gt; Integer i2=128i2 ==&gt; 128|  已修改 变量 i2 : Integer|    更新已覆盖 变量 i2 : Integerjshell&gt; i1==i2$17 ==&gt; false|  已创建暂存变量 $17 : boolean</code></pre><p>值在-128-127的自动装箱 Integer 对象在JVM中已经缓存好</p><pre><code>jshell&gt; Integer i1= new Integer(127)i1 ==&gt; 127|  已修改 变量 i1 : Integer|    更新已覆盖 变量 i1 : Integerjshell&gt; Integer i2= 127i2 ==&gt; 127|  已修改 变量 i2 : Integer|    更新已覆盖 变量 i2 : Integerjshell&gt; i1==i2$29 ==&gt; false|  已创建暂存变量 $29 : boolean</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JShell 这一REPL交互工具，将给测试 Java 代码片段带来很大的方便。Java 程序员将像 Python、NodeJS、Scala程序员那样享受这种命令行带来的便捷，看到这里还不行动起来？下载个试试，将让你回想起自己写 main 测试就想流泪 XD</p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener"><strong>Java Download</strong></a></li><li><a href="http://docs.oracle.com/javase/9/tools/jshell.htm" target="_blank" rel="noopener"><strong>JShell Doc</strong></a></li><li>[<strong>JAKUB DZIWORSKI`s BLOG</strong>](<a href="http://jakubdziworski.github.io/java/2016/07/31/jshell-getting-started-examples.html" target="_blank" rel="noopener">http://jakubdziworski.github.io/java/2016/07/31/jshell-getting-started-examples.html</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在今年九月正式发布的 Java9 版本中，其 /bin 目录中多个一个交互工具 JShell（据说 Java8 已有测试版）。众所周知，许多编程语言都提供称作 Read-Evaluate-Print Loop （REPL）的命令行工具，它们能够在输入声明、语句及表达式时计算，并立即给出结果。&lt;/p&gt;
&lt;p&gt;以 Python 为例，运行整个工程、项目可能需要很长时间，但是你可以使用此工具执行一些需要确定的表达式，就能立即得到他们返回的值。这对于哪些开始学习语言或者接触语言新功能的程序员来说是个便捷好用的工具。&lt;/p&gt;
&lt;p&gt;然而没 JShell 之前的 Java 来说，你需要编写一个测试类新建 main 方法来打印结果，并且每次修改后需要重写编译、运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
    
      <category term="Java" scheme="http://zhongm.in/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一键配置脚本（用户添加配置、源修改、ss&amp;BBR安装）</title>
    <link href="http://zhongm.in/2017/10/12/QuickInit-Shell-Script/"/>
    <id>http://zhongm.in/2017/10/12/QuickInit-Shell-Script/</id>
    <published>2017-10-12T13:45:34.000Z</published>
    <updated>2019-07-13T14:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在各个服务器提供商中尝试适合的服务器，然而给多个服务器初始配置确实很是繁琐无聊。<br>索性自己写个脚本，这样一接手新的服务器就能自动配置，省下时间来好好折腾别的。</p><hr><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>目前适用环境：CentOS 5+、Ubuntu、Debian</p><ol><li>显示系统信息 </li><li>修改源为国内阿里云源镜像（也可修改参数配置其他源）</li><li>创建指定用户、创建Home目录、指定Shell、添加到 sudoers （可修改参数）</li><li>下载.bashrc、.vimrc 配置工作环境（来自博主自己）</li><li>安装Shadowsocks 、BBR（可选、来源 <a href="https://teddysun.com/" target="_blank" rel="noopener">https://teddysun.com/</a> 秋水逸冰）</li><li>配置Java、Python等（待续完善）<a id="more"></a></li></ol><h2 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment"># File Name: quickInit.sh</span></span><br><span class="line"><span class="comment"># Author: single-wolf</span></span><br><span class="line"><span class="comment"># mail: root@mail.zhongm.in</span></span><br><span class="line"><span class="comment"># Created Time: 2017年10月12日 10:43:49</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#Auto init ECS or VPS include useradd ,install pakeage ,add sys-config</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#新建用户名</span></span><br><span class="line">defaultUser=<span class="string">'MyVPS'</span></span><br><span class="line"><span class="comment">#新用户默认Shell</span></span><br><span class="line">defaultShell=<span class="string">'bash'</span></span><br><span class="line"><span class="comment">#常用工具安装</span></span><br><span class="line">initPakeage=<span class="string">"sudo wget vim git dstat <span class="variable">$defaultShell</span>"</span></span><br><span class="line"><span class="comment">#自定义源URL，适用于Ubuntu、Debian</span></span><br><span class="line">srcUrl=<span class="string">'http://mirrors.aliyun.com/'</span></span><br><span class="line"></span><br><span class="line">red=<span class="string">'\033[0;31m'</span></span><br><span class="line">green=<span class="string">'\033[0;32m'</span></span><br><span class="line">yellow=<span class="string">'\033[0;33m'</span></span><br><span class="line">plain=<span class="string">'\033[0m'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#待续</span></span><br><span class="line">version_jdk=9 </span><br><span class="line"></span><br><span class="line">[[ <span class="variable">$EUID</span> -ne 0 ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> This script must be run as root!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/redhat-release ]; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"centos"</span></span><br><span class="line"><span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">"debian"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"debian"</span></span><br><span class="line"><span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">"ubuntu"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"ubuntu"</span></span><br><span class="line"><span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">"centos|red hat|redhat"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"centos"</span></span><br><span class="line"><span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">"debian"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"debian"</span></span><br><span class="line"><span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">"ubuntu"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"ubuntu"</span></span><br><span class="line"><span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">"centos|red hat|redhat"</span>; <span class="keyword">then</span></span><br><span class="line">    release=<span class="string">"centos"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_opsy</span></span>() &#123;<span class="comment">##获取系统信息</span></span><br><span class="line">    [ -f /etc/redhat-release ] &amp;&amp; awk <span class="string">'&#123;print ($1,$3~/^[0-9]/?$3:$4)&#125;'</span> /etc/redhat-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    [ -f /etc/os-release ] &amp;&amp; awk -F<span class="string">'[= "]'</span> <span class="string">'/PRETTY_NAME/&#123;print $3,$4,$5&#125;'</span> /etc/os-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    [ -f /etc/lsb-release ] &amp;&amp; awk -F<span class="string">'[="]+'</span> <span class="string">'/DESCRIPTION/&#123;print $2&#125;'</span> /etc/lsb-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_version</span></span>()&#123;<span class="comment">##获取版本</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"centos"</span> ]];<span class="keyword">then</span></span><br><span class="line">        [ -f /etc/os-release ] &amp;&amp; awk -F<span class="string">'[="]+'</span> <span class="string">'/VERSION_ID/&#123;print $2&#125;'</span> /etc/os-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"debian"</span> ]];<span class="keyword">then</span></span><br><span class="line">        [ -f /etc/os-release ] &amp;&amp; awk -F<span class="string">'[()]'</span> <span class="string">'/VERSION=/&#123;print $2&#125;'</span> /etc/os-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"ubuntu"</span> ]];<span class="keyword">then</span></span><br><span class="line">        [ -f /etc/lsb-release ] &amp;&amp; awk -F<span class="string">'[="]+'</span> <span class="string">'/DISTRIB_CODENAME/&#123;print $2&#125;'</span> /etc/lsb-release &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> OS is not be supported, please change to CentOS/Debian/Ubuntu and try again."</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opsy=$( get_opsy )</span><br><span class="line">arch=$( uname -m )</span><br><span class="line">lbit=$( getconf LONG_BIT )</span><br><span class="line">kern=$( uname -r )</span><br><span class="line">version=$( get_version )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_char</span></span>() &#123;</span><br><span class="line">    SAVEDSTTY=`stty -g`</span><br><span class="line">    stty -<span class="built_in">echo</span></span><br><span class="line">    stty cbreak</span><br><span class="line">    dd <span class="keyword">if</span>=/dev/tty bs=1 count=1 2&gt; /dev/null</span><br><span class="line">    stty -raw</span><br><span class="line">    stty <span class="built_in">echo</span></span><br><span class="line">    stty <span class="variable">$SAVEDSTTY</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init_install</span></span>()&#123;<span class="comment">##修改源、安装常用软件</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"debian"</span> ]];<span class="keyword">then</span></span><br><span class="line">        file=<span class="string">"/etc/apt/sources.list"</span></span><br><span class="line">        [[ ! -e <span class="variable">$file</span> ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>src file <span class="variable">$file</span> not exist,please check it!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">        cp <span class="variable">$file</span> <span class="string">"<span class="variable">$file</span>.`date +%F`"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"#Created By quickInit.sh `date +%F`"</span>&gt;<span class="variable">$file</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> <span class="string">"deb"</span> <span class="string">"deb-src"</span>;<span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> sort <span class="keyword">in</span> <span class="string">""</span> <span class="string">"-updates"</span> ;<span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$kind</span> <span class="variable">$srcUrl</span><span class="variable">$release</span> <span class="variable">$version</span><span class="variable">$sort</span> main contrib non-free"</span> &gt;&gt; <span class="variable">$file</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"<span class="variable">$kind</span> <span class="variable">$srcUrl</span><span class="variable">$release</span>-security <span class="variable">$version</span>/updates main contrib non-free"</span> &gt;&gt; <span class="variable">$file</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        apt-get update</span><br><span class="line">        apt-get -y install <span class="variable">$initPakeage</span></span><br><span class="line">        <span class="keyword">if</span> [[ $? -ne 0 ]];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Install InitPakeages failed, please check it."</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"ubuntu"</span> ]];<span class="keyword">then</span></span><br><span class="line">        file=<span class="string">"/etc/apt/sources.list"</span></span><br><span class="line">        [[ ! -e <span class="variable">$file</span> ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>src file <span class="variable">$file</span> not exist,please check it!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">        cp <span class="variable">$file</span> <span class="string">"<span class="variable">$file</span>.`date +%F`"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"#Created By quickInit.sh `date +%F`"</span>&gt;<span class="variable">$file</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> <span class="string">"deb"</span> <span class="string">"deb-src"</span>;<span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> sort <span class="keyword">in</span> <span class="string">""</span> <span class="string">"-updates"</span> <span class="string">"-security"</span>;<span class="keyword">do</span></span><br><span class="line">                <span class="keyword">for</span> free <span class="keyword">in</span> <span class="string">"main"</span> <span class="string">"universe"</span>;<span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">"<span class="variable">$kind</span> <span class="variable">$srcUrl</span><span class="variable">$release</span> <span class="variable">$version</span><span class="variable">$sort</span> <span class="variable">$free</span>"</span> &gt;&gt; <span class="variable">$file</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        apt-get update</span><br><span class="line">        apt-get -y install <span class="variable">$initPakeage</span></span><br><span class="line">        <span class="keyword">if</span> [[ $? -ne 0 ]];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Install InitPakeages failed, please check it."</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$release</span>"</span> == <span class="string">"centos"</span> ]];<span class="keyword">then</span></span><br><span class="line">        file=<span class="string">"/etc/yum.repos.d/CentOS-Base.repo"</span></span><br><span class="line">        [[ ! -e <span class="variable">$file</span> ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>src file <span class="variable">$file</span> not exist,please check it!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">        cp <span class="variable">$file</span> <span class="string">"<span class="variable">$file</span>.`date +%F`"</span></span><br><span class="line">        <span class="keyword">if</span> [[ ! -e <span class="string">"/usr/bin/wget"</span> ]];<span class="keyword">then</span></span><br><span class="line">            wget -O <span class="variable">$file</span> <span class="string">"http://mirrors.aliyun.com/repo/Centos-<span class="variable">$version</span>.repo"</span></span><br><span class="line">        <span class="keyword">elif</span> [[ -e <span class="string">"/usr/bin/curl"</span> ]];<span class="keyword">then</span></span><br><span class="line">            curl -o <span class="variable">$file</span> <span class="string">"http://mirrors.aliyun.com/repo/Centos-<span class="variable">$version</span>.repo"</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            yum -y install wget &amp;&amp; wget -O <span class="variable">$file</span> <span class="string">"http://mirrors.aliyun.com/repo/Centos-<span class="variable">$version</span>.repo"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        yum clean all &amp;&amp; yum makecache</span><br><span class="line">        yum -y install <span class="variable">$initPakeage</span></span><br><span class="line">        <span class="keyword">if</span> [[ $? -ne 0 ]];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Install InitPakeages failed, please check it."</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> OS is not be supported, please change to CentOS/Debian/Ubuntu and try again."</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:Init and install <span class="variable">$initPakeage</span> successfully."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">adduser</span></span>()&#123;<span class="comment">##添加用户、修改sudoers</span></span><br><span class="line">    shell=<span class="string">"/bin/<span class="variable">$defaultShell</span>"</span></span><br><span class="line">    useradd <span class="variable">$defaultUser</span> -m -s <span class="variable">$shell</span></span><br><span class="line">    [ $? -ne 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Add user <span class="variable">$defaultUser</span> failed,please check it"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Input password for your newUser"</span></span><br><span class="line">    passwd <span class="variable">$defaultUser</span></span><br><span class="line">    <span class="keyword">while</span> [ $? -ne 0 ]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        passwd <span class="variable">$defaultUser</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Add user <span class="variable">$defaultUser</span> successfully"</span></span><br><span class="line">    chmod +w /etc/sudoers</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$defaultUser</span>  ALL=(ALL)   ALL"</span> &gt;&gt; /etc/sudoers</span><br><span class="line">    [ $? -ne 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Give user <span class="variable">$defaultUser</span> failed"</span> &amp;&amp; chmod -w /etc/sudoers &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">    chmod -w /etc/sudoers</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Give user <span class="variable">$defaultUser</span> Rootright successfully"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">userconfig</span></span>()&#123;<span class="comment">##配置.bash .vimrc环境</span></span><br><span class="line">    home=<span class="string">"/home/<span class="variable">$defaultUser</span>/"</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$home</span></span><br><span class="line">    wget -O .profile <span class="string">"http://cloud.zhongm.in/f/c92022b083/?raw=1"</span> &amp;&amp; wget -O .bashrc <span class="string">"http://cloud.zhongm.in/f/e933c3dcf0/?raw=1"</span> &amp;&amp; wget -O .vimrc <span class="string">"http://cloud.zhongm.in/f/1cecaee058/?raw=1"</span> &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Download userconfig successfully,relogin in to use it."</span></span><br><span class="line">    chown <span class="variable">$defaultUser</span>:<span class="variable">$defaultUser</span> .*</span><br><span class="line">    [ $? -ne 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>User config failed!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">disableRootLogin</span></span>()&#123;<span class="comment">##禁用Root登录</span></span><br><span class="line">    config=<span class="string">"/etc/ssh/sshd_config"</span></span><br><span class="line">    <span class="keyword">if</span> [[ -e  <span class="variable">$config</span> ]];<span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [[ -w <span class="variable">$config</span> ]];<span class="keyword">then</span></span><br><span class="line">            chmod +w <span class="variable">$config</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        sed -i <span class="string">'/^PermitRootLogin/'</span>d <span class="variable">$config</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"PermitRootLogin no"</span>&gt;&gt;<span class="variable">$config</span></span><br><span class="line">        [ $? -ne 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span> Disable RootLogin failed"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;red&#125;</span>ERROR:<span class="variable">$&#123;plain&#125;</span>config file <span class="variable">$config</span> not exist,please check it!"</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;green&#125;</span>INFO:<span class="variable">$&#123;plain&#125;</span>Disable RootLogin successfully"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#install_java()&#123;##安装Java，待续</span></span><br><span class="line"><span class="comment">#  if [ -n `which java` ];then</span></span><br><span class="line"><span class="comment">#      version_local=`java -version&gt;version.tmp 2&gt;&amp;1 &amp;&amp; awk -F'["]' '/java version/&#123;print $2&#125;' version.tmp &amp;&amp; rm version.tmp`</span></span><br><span class="line"><span class="comment">#      if [ $version_local -eq $version_jdk ];then</span></span><br><span class="line"><span class="comment">#          echo -e "$&#123;green&#125;INFO:$&#123;plain&#125;JDK$version_jdk alreadly exists!"</span></span><br><span class="line"><span class="comment">#          return</span></span><br><span class="line"><span class="comment">#      else </span></span><br><span class="line"><span class="comment">#          echo -e "$&#123;yellow&#125;INFO:$&#123;plain&#125;Prepare to remove local JDK$version_local,and install JDK$version_jdk"</span></span><br><span class="line"><span class="comment">#      fi</span></span><br><span class="line"><span class="comment">#  else</span></span><br><span class="line"><span class="comment">#  fi</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_ss</span></span>()&#123;<span class="comment">##安装Shadowsocks</span></span><br><span class="line">    wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">    chmod +x shadowsocks-all.sh</span><br><span class="line">    ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install_bbr</span></span>()&#123;<span class="comment">##安装BBR</span></span><br><span class="line">    wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line">    chmod +x bbr.sh</span><br><span class="line">    ./bbr.sh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"---------- System Information ----------"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" OS      : <span class="variable">$opsy</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" Arch    : <span class="variable">$arch</span> (<span class="variable">$lbit</span> Bit)"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" Kernel  : <span class="variable">$kern</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" Version : <span class="variable">$version</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"----------------------------------------"</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Press any key to start...or Press Ctrl+C to cancel"</span></span><br><span class="line">char=`get_char`</span><br><span class="line">init_install</span><br><span class="line">adduser</span><br><span class="line">userconfig</span><br><span class="line">disableRootLogin</span><br><span class="line">install_ss</span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>GitHub位置 <a href="https://github.com/single-wolf/ShellScript/blob/master/quickInit.sh" target="_blank" rel="noopener">一键快速配置</a></p><p>功能有待完善。欢迎拍砖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在各个服务器提供商中尝试适合的服务器，然而给多个服务器初始配置确实很是繁琐无聊。&lt;br&gt;索性自己写个脚本，这样一接手新的服务器就能自动配置，省下时间来好好折腾别的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h2&gt;&lt;p&gt;目前适用环境：CentOS 5+、Ubuntu、Debian&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;显示系统信息 &lt;/li&gt;
&lt;li&gt;修改源为国内阿里云源镜像（也可修改参数配置其他源）&lt;/li&gt;
&lt;li&gt;创建指定用户、创建Home目录、指定Shell、添加到 sudoers （可修改参数）&lt;/li&gt;
&lt;li&gt;下载.bashrc、.vimrc 配置工作环境（来自博主自己）&lt;/li&gt;
&lt;li&gt;安装Shadowsocks 、BBR（可选、来源 &lt;a href=&quot;https://teddysun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://teddysun.com/&lt;/a&gt; 秋水逸冰）&lt;/li&gt;
&lt;li&gt;配置Java、Python等（待续完善）
    
    </summary>
    
      <category term="Linux" scheme="http://zhongm.in/categories/Linux/"/>
    
    
      <category term="Shell" scheme="http://zhongm.in/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>深度解析Java线程池的异常处理</title>
    <link href="http://zhongm.in/2017/09/20/Analyze-Java-Theadpool-Exception/"/>
    <id>http://zhongm.in/2017/09/20/Analyze-Java-Theadpool-Exception/</id>
    <published>2017-09-20T13:10:07.000Z</published>
    <updated>2019-07-13T13:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在逛同性交友网站GitHub的时候看到一个解析线程池异常处理的Issue，正好是曾经自己遇到过的问题。在此记录下来，并将其拓展到其他类型的线程池。</p><p>本文因篇幅省略了诸多AQS相关知识，可以查看博客中另一篇博文 <a href="/2017/08/25/Analyze-JDK-AQS/">一行一行源码分析清楚AQS</a> 以保证清楚理解本文。</p><a id="more"></a><h3 id="1、ThreadPoolExecutor"><a href="#1、ThreadPoolExecutor" class="headerlink" title="1、ThreadPoolExecutor"></a>1、ThreadPoolExecutor</h3><blockquote><p>此部分来源于 <a href="https://github.com/aCoder2013/blog/issues/3" target="_blank" rel="noopener">GitHub aCoder2013</a></p></blockquote><p>这一线程池由来已久，是抽象类 AbstractExecutorService 继承类，通过调用不同构造函数实现诸如 newFixedThreadPool 、newCachedThreadPool 线程池功能。</p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>考虑下面这段代码，有什么区别呢？你可以猜猜会不会有异常打出呢？如果打出来的话是在哪里？：</p><pre class="lang:java decode:true" title="Question">        ExecutorService threadPool = Executors.newFixedThreadPool(1);        threadPool.submit(() -&gt; {            Object obj = null;            System.out.println(obj.toString());        });        threadPool.execute(() -&gt; {            Object obj = null;            System.out.println(obj.toString());        });</pre><p>你会发现单就执行这两句的话，结果只会打印一处异常信息，来源于 execute() 中的 obj.toString() 。</p><h4 id="源码解析："><a href="#源码解析：" class="headerlink" title="源码解析："></a>源码解析：</h4><p>分析下面源码，发现其实重载的 submit() 方法将 Runnable、Callable 都封装成继承 Future 的 RunnableFuture 的实现类 FutureTask 对象（有点忽悠  XD）</p><pre class="lang:java decode:true" title="SrcAnalyse">    public Future&lt;?&gt; submit(Runnable task) {        if (task == null) throw new NullPointerException();        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);        execute(ftask);        return ftask;    }    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {        if (task == null) throw new NullPointerException();        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);        execute(ftask);        return ftask;    }    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {        return new FutureTask&lt;T&gt;(runnable, value);    }    public FutureTask(Runnable runnable, V result) {        this.callable = Executors.callable(runnable, result);        this.state = NEW;       // volatile修饰，保证多线程下的可见性,可以看看Java内存模型    }    public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {        if (task == null)            throw new NullPointerException();        return new RunnableAdapter&lt;T&gt;(task, result);    }    static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {        final Runnable task;        final T result;        RunnableAdapter(Runnable task, T result) {            this.task = task;            this.result = result;        }        public T call() {            task.run();            return result;        }    }</pre><p>接下来就会实际提交到队列中交给线程池调度处理：</p><pre class="lang:java decode:true " title="SrcAnalyse2"> /**    * 这里经过多次检查验证    * 意图都是将通过addWorker()或是workQueue.offer()    * 将Runnable传给继承AQS的Worker内部类进行封装    * 了解AQS的同学一看便能融会贯通    */    public void execute(Runnable command) {        if (command == null)            throw new NullPointerException();        int c = ctl.get();        if (workerCountOf(c) &lt; corePoolSize) {            if (addWorker(command, true))                return;            c = ctl.get();        }        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {            int recheck = ctl.get();            if (! isRunning(recheck) &amp;&amp; remove(command))                reject(command);            else if (workerCountOf(recheck) == 0)                addWorker(null, false);        }        else if (!addWorker(command, false))            reject(command);    }</pre><p>那么接下来看看线程池核心的流程：</p><pre class="lang:java decode:true" title="SrcAnalyse3">private final class Worker        extends AbstractQueuedSynchronizer        implements Runnable{          /** Delegates main run loop to outer runWorker  */        public void run() {            runWorker(this);        }}final void runWorker(Worker w) {        Thread wt = Thread.currentThread();        Runnable task = w.firstTask;        w.firstTask = null;        w.unlock(); // allow interrupts        boolean completedAbruptly = true;        try {            //getTask()方法会尝试从队列中抓取数据            while (task != null || (task = getTask()) != null) {                w.lock();                if ((runStateAtLeast(ctl.get(), STOP) ||                     (Thread.interrupted() &amp;&amp;                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                    !wt.isInterrupted())                    wt.interrupt();                try {                    //可覆写此方法打日志埋点之类的                    beforeExecute(wt, task);                    Throwable thrown = null;                    try {                        //简单明了，直接调用run方法                        task.run();                    } catch (RuntimeException x) {                        thrown = x; throw x;                    } catch (Error x) {                        thrown = x; throw x;                    } catch (Throwable x) {                        thrown = x; throw new Error(x);                    } finally {                        afterExecute(task, thrown);//下文将介绍可以重写此方法捕获异常                    }                } finally {                    task = null;                    w.completedTasks++;                    w.unlock();                }            }            completedAbruptly = false;        } finally {            processWorkerExit(w, completedAbruptly);        }    }</pre><h4 id="submit-的方式"><a href="#submit-的方式" class="headerlink" title="submit() 的方式"></a>submit() 的方式</h4><p>之前我们知道最终传递过去的是FutureTask，也就是说会调用这里的 Future 的 run方法，我们看看实现：</p><pre class="lang:java decode:true" title="SrcAnalyse4">    public void run() {        if (state != NEW ||            !UNSAFE.compareAndSwapObject(this, runnerOffset,                                         null, Thread.currentThread()))            return;        try {            Callable&lt;V&gt; c = callable;            if (c != null &amp;&amp; state == NEW) {                V result;                boolean ran;                try {                    result = c.call();                    ran = true;                } catch (Throwable ex) {//捕获异常不抛出                    result = null;                    ran = false;                    //。。。                    setException(ex);//调用此方法设置异常状态                }                if (ran)                    set(result);            }        } finally {          //省略    }      protected void setException(Throwable t) {        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {            outcome = t; //异常赋给了这个变量            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // 将状态CAS为EXCEPTIONAL            finishCompletion();        }    }    public V get() throws InterruptedException, ExecutionException {//Future.get()获取返回值        int s = state;        if (s &lt;= COMPLETING)            s = awaitDone(false, 0L);        return report(s);//最终调用report返回outcome变量    }    private V report(int s) throws ExecutionException {        Object x = outcome;        if (s == NORMAL)            return (V)x;        if (s &gt;= CANCELLED)            throw new CancellationException();        throw new ExecutionException((Throwable)x);//若状态异常则抛出outcome异常    }</pre><p>如上面分析到的，这样的话调用 FutureTask.run() 并不会直接抛出异常，所以在 ThreadPool.execute() 中捕获不到异常。但我们可以通过调用 get() 方法来捕捉异常。</p><h4 id="submit-解决方式"><a href="#submit-解决方式" class="headerlink" title="submit() 解决方式"></a>submit() 解决方式</h4><p>1、基本方式 try/catch，直接调用get()</p><p>2、重写  protected afterExecute(Runnable r,Throwable t ) { } 方法</p><p>想想如果我明明一开始调用的是 submit(Runnable r) ，为了捕捉异常还需刻意调用 get() 未免有点麻烦。Doug Lea 大佬已经在 JDK 文档中教我们可以重写 ThreadPoolExecutor 中的 afterExecute() 方法来实现异常捕获：</p><pre class="lang:java decode:true" title="SrcAnalyse5">    protected void afterExecute(Runnable r, Throwable t) {          super.afterExecute(r, t);          if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) {            try {              //如上文所说，主动调用get() 将异常抛出              Object result = ((Future&lt;?&gt;) r).get();            } catch (CancellationException ce) {                t = ce;            } catch (ExecutionException ee) {//异常捕获                t = ee.getCause();            } catch (InterruptedException ie) {                Thread.currentThread().interrupt(); // ignore/reset            }          }          if (t != null){            //异常处理            t.printStackTrace();          }        }</pre><h4 id="execute-方式："><a href="#execute-方式：" class="headerlink" title="execute() 方式："></a>execute() 方式：</h4><p>如代码SrcAnalyse2，此方法不同于submit() 会进行封装成Future ，其传递过去的就直接是Runnable,因此就会直接抛出：</p><pre class="lang:java decode:true" title="SrcAnalyse2-sample">    try {        task.run();//在此情况直接为Runnable.run()    } catch (RuntimeException x) {//异常被直接捕获        thrown = x; throw x;    } catch (Error x) {        thrown = x; throw x;    } catch (Throwable x) {        thrown = x; throw new Error(x);    } finally {        afterExecute(task, thrown);    }</pre><p>那么这里的异常到底会抛出到哪里呢, 我们看看JVM具体是怎么处理的：</p><pre class="lang:java decode:true " title="JVM-Analyse">if (!destroy_vm || JDK_Version::is_jdk12x_version()) {    // JSR-166: change call from from ThreadGroup.uncaughtException to    // java.lang.Thread.dispatchUncaughtException    if (uncaught_exception.not_null()) {      //如果有未捕获的异常      Handle group(this, java_lang_Thread::threadGroup(threadObj()));      {        KlassHandle recvrKlass(THREAD, threadObj-&gt;klass());        CallInfo callinfo;        KlassHandle thread_klass(THREAD, SystemDictionary::Thread_klass());        /*              这里类似一个方法表，实际就会去调用Thread#dispatchUncaughtException方法            template(dispatchUncaughtException_name,            "dispatchUncaughtException")                        */        LinkResolver::resolve_virtual_call(callinfo, threadObj, recvrKlass, thread_klass,                                           vmSymbols::dispatchUncaughtException_name(),                                           vmSymbols::throwable_void_signature(),                                           KlassHandle(), false, false, THREAD);        CLEAR_PENDING_EXCEPTION;        methodHandle method = callinfo.selected_method();        if (method.not_null()) {          JavaValue result(T_VOID);          JavaCalls::call_virtual(&amp;result,                                  threadObj, thread_klass,                                  vmSymbols::dispatchUncaughtException_name(),                                  vmSymbols::throwable_void_signature(),                                  uncaught_exception,                                  THREAD);        } else {          KlassHandle thread_group(THREAD, SystemDictionary::ThreadGroup_klass());          JavaValue result(T_VOID);          JavaCalls::call_virtual(&amp;result,                                  group, thread_group,                                  vmSymbols::uncaughtException_name(),                                  vmSymbols::thread_throwable_void_signature(),                                  threadObj,           // Arg 1                                  uncaught_exception,  // Arg 2                                  THREAD);        }        if (HAS_PENDING_EXCEPTION) {          ResourceMark rm(this);          jio_fprintf(defaultStream::error_stream(),                "\nException: %s thrown from the UncaughtExceptionHandler"                " in thread \"%s\"\n",                pending_exception()-&gt;klass()-&gt;external_name(),                get_thread_name());          CLEAR_PENDING_EXCEPTION;        }      }    }</pre><p>可以看到这里最终会去调用Thread#dispatchUncaughtException方法：</p><pre class="lang:java decode:true" title="SrcAnalyse6">    private void dispatchUncaughtException(Throwable e) {        //默认会调用ThreadGroup的实现        getUncaughtExceptionHandler().uncaughtException(this, e);    }​    public void uncaughtException(Thread t, Throwable e) {        if (parent != null) {            parent.uncaughtException(t, e);        } else {            Thread.UncaughtExceptionHandler ueh =                Thread.getDefaultUncaughtExceptionHandler();            if (ueh != null) {                ueh.uncaughtException(t, e);            } else if (!(e instanceof ThreadDeath)) {                //可以看到会打到System.err里面                System.err.print("Exception in thread \""                                 + t.getName() + "\" ");                e.printStackTrace(System.err);            }        }    }</pre><h4 id="execute-解决方式"><a href="#execute-解决方式" class="headerlink" title="execute() 解决方式"></a>execute() 解决方式</h4><p>1、基本方式，直接try/catch</p><p>2、线程重写 setUncaughtExceptionHandler() 方法</p><pre class="lang:java decode:true" title="Solution">       Thread t = new Thread();       t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {           public void uncaughtException(Thread t, Throwable e) {              LOGGER.error(t + " throws exception: " + e);           }        });        //如果是线程池的模式:        ExecutorService threadPool = Executors.newFixedThreadPool(1, r -&gt; {            Thread t = new Thread(r);            t.setUncaughtExceptionHandler(                (t1, e) -&gt; LOGGER.error(t1 + " throws exception: " + e));            return t;        });</pre><h3 id="2、ForkJoinPool"><a href="#2、ForkJoinPool" class="headerlink" title="2、ForkJoinPool"></a>2、ForkJoinPool</h3><p><code>ForkJoinPool</code>也是继承<code>AbstractExecutorService</code>的线程池，实现了 Fork/Join 及 work-stealing 以提升多核计算效率（详细的 ForkJoin 设计原理可参考<a href="http://www.molotang.com/articles/694.html" target="_blank" rel="noopener">三石 道</a> 、<a href="http://ifeve.com/a-java-fork-join-framework/" target="_blank" rel="noopener">并发编程网</a> ）。<br>因各版本 JDK 源码略有差异，此处仅为 JDK8 源码分析，且不具体分析线程池运行机制。</p><p>JDK源码中给了我们这样一个<strong>任务提交总结表</strong></p><table><thead><tr><th align="center">任务执行需求</th><th align="center">在非Fork/Join调用</th><th align="center">在Fork/Join计算中调用</th></tr></thead><tbody><tr><td align="center">异步执行无返回值</td><td align="center">execute(ForkJoinTask)</td><td align="center">ForkJoinTask.fork()</td></tr><tr><td align="center">等待获取返回值</td><td align="center">invoke(ForkJoinTask)</td><td align="center">ForkJoinTask.invoke()</td></tr><tr><td align="center">异步执行并获取Future</td><td align="center">submit(ForkJoinTask)</td><td align="center">ForkJoinTask.fork()</td></tr></tbody></table><blockquote><ol><li>非Fork/Join 和在 Fork/Join 中是指调用提交时所在的位置，前者为外部（main）通过 ForkJoinPool 本身提交 ForkJoinTask ，后者为 ForkJoinTask 执行中再将子任务提交到 ForkJoinPool 中。</li><li>ForkJoinTask fork 方法返回<code>this</code>，而 ForkJoinTask 本身实现 Future ，则第三种中可使用 <code>submit(ForkJoinTask).get()</code> 和 <code>ForkJoinTask.fork().get()</code>获取返回值，将 get 方法换成 join 也同样可行，区别只在于异常处理方式。</li><li>调用 <code>execute(Runnable)</code>、<code>submit(Runnable)</code>、<code>submit(Callable)</code>将通过 ForkJoinTask 的子类进行适配。</li><li>此外还有 <code>invokeAll(Collection  &lt;Callable&gt;)</code> 等方法，类似此处就不讨论。</li></ol></blockquote><pre><code>//ForkJoinPoolpublic &lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task) {} //提交并等待返回值public void execute(ForkJoinTask&lt;?&gt; task) {} //提交，异步执行public void execute(Runnable task) {}//提交并异步执行，返回ForkJoinTaskpublic &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) {}public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Callable&lt;T&gt; task) {}public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Runnable task, T result) {}public ForkJoinTask&lt;?&gt; submit(Runnable task) {}//ForkJoinTaskpublic final ForkJoinTask&lt;V&gt; fork() {} // 提交并异步执行public final V invoke() {} //提交并等待返回值</code></pre><h4 id="跟踪捕获"><a href="#跟踪捕获" class="headerlink" title="跟踪捕获"></a>跟踪捕获</h4><p>ForkJoinPool 中三种类型的提交方法都将调用 <code>externalPush(ForkJoinTask)</code> 或<code>externalSubmit(ForkJoinTask)</code>将参数封装成 ForkJoinTask 并 Push 到 已存在或初始化的 WorkQueue 中</p><p>我们绕过具体的任务调度、状态转换直接从执行 ForkJoinTask 的 ForkJoinWokerThread 来跟踪执行异常的处理 （每个这样的线程对象都在 ForkJoinPool 中有一对应的 WorkQueue）</p><p>线程run方法： ForkJoinWorkerThread.run()</p><pre><code>    public void run() {    if (workQueue.array == null) { // only run once        Throwable exception = null;        try {            onStart(); // 空方法            // 调用 ForkJoinPool 中方法开始执行            pool.runWorker(workQueue);              } catch (Throwable ex) {  // 此处捕获抛出的异常，最后将介绍             exception = ex;        } finally {             try {                    onTermination(exception); // 自定义收尾函数                } catch (Throwable ex) {                    if (exception == null)                        exception = ex;                } finally {                    pool.deregisterWorker(this, exception); // 自定义异常处理，最后介绍                }        }    }}</code></pre><p>线程执行循环： ForkJoinPool.runWorker(WorkQueue)</p><pre><code>final void runWorker(WorkQueue w) {    w.growArray();                   // 给 WorkQueue 分配任务数组    int seed = w.hint;               // 初始化随机数    int r = (seed == 0) ? 1 : seed;      for (ForkJoinTask&lt;?&gt; t;;) {        if ((t = scan(w, r)) != null) // 实现 work-stealing             w.runTask(t); // 调用 WorkQueue 方法执行任务 t            // 等待任务进入下一循环，若返回false，则退出循环线程进入结束        else if (!awaitWork(w, r))             break;        r ^= r &lt;&lt; 13; r ^= r &gt;&gt;&gt; 17; r ^= r &lt;&lt; 5; // 可先忽略    }}</code></pre><p>调用 WorkQueue 执行： WorkQueue.runTask(ForkJoinTask)</p><pre><code>final void runTask(ForkJoinTask&lt;?&gt; task) {        if (task != null) {            scanState &amp;= ~SCANNING;            // 调用 ForkJoinTask.doExec() 直接执行任务，此处未捕获或抛出            (currentSteal = task).doExec();              U.putOrderedObject(this, QCURRENTSTEAL, null); //             execLocalTasks(); // 继续执行 WorkQueue 中任务数组中任务            ForkJoinWorkerThread thread = owner;            if (++nsteals &lt; 0)                   transferStealCount(pool);            scanState |= SCANNING;            if (thread != null)                thread.afterTopLevelExec();        }    }</code></pre><p>最终调用任务执行方法： ForkJoinTask.doExec()</p><pre><code>final int doExec() {    int s; boolean completed;    if ((s = status) &gt;= 0) { // 任务状态判断，volatile保证可见性        try {            completed = exec(); // exec() 为抽象方法以自定义任务执行体        } catch (Throwable rex) { // 在此捕获所有任务内容抛出的异常            // 修改状态，并记录异常            return setExceptionalCompletion(rex);         }        if (completed)            s = setCompletion(NORMAL);    }    return s;}</code></pre><p>修改任务状态并记录异常： setExceptionalCompletion(Throwable)</p><pre><code>private int setExceptionalCompletion(Throwable ex) {    // 使用 Static+弱引用类型+类HashTable结构 变量记录全局异常    // 并设置状态为 EXCEPTIONAL ，下文详解    int s = recordExceptionalCompletion(ex);    if ((s &amp; DONE_MASK) == EXCEPTIONAL)    // 自定义异常传播（权限只在此并发包内）        internalPropagateException(ex);    return s;}</code></pre><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>ExceptionNode[ ] 实现类似 HashTable 以记录异常及异常的 ForkJoinTask。为什么使用弱引用呢？可以想象当分出的诸多子任务中一个子任务异常，势必造成之上的父任务异常，以此循环向上将造成大量异常对象，全部存储将有损效率。所以采用弱应用，当子任务的异常在父任务执行体中因执行 get、join、invoke 而抛出并被我们上面分析到的过程捕获，异常将被记录为父任务的异常并存储，此时子任务异常已没有意义子任务也无引用，使用弱引用可借用GC帮助清除</p><pre><code>static final class ExceptionNode extends WeakReference&lt;ForkJoinTask&lt;?&gt;&gt; {    final Throwable ex;    ExceptionNode next;  // 虽然设计成数组链表结构，可源码中并没以此存储    final long thrower;  // 用id代替引用，避免引用    final int hashCode;  // 在弱引用消失前记录ForkJoinTask 的 HashCode    ExceptionNode(ForkJoinTask&lt;?&gt; task, Throwable ex, ExceptionNode next) {        super(task, exceptionTableRefQueue);        this.ex = ex;        this.next = next;        this.thrower = Thread.currentThread().getId();        this.hashCode = System.identityHashCode(task);    }}</code></pre><p>既然已经记录下异常，那么怎样会抛出这些异常呢？在 ForkJoinTask 中提供方法获取</p><pre><code>private Throwable getThrowableException() {    if ((status &amp; DONE_MASK) != EXCEPTIONAL)        return null;    int h = System.identityHashCode(this);//获取HashCode    ExceptionNode e;    final ReentrantLock lock = exceptionTableLock;    lock.lock();    try {        // 通过ReferenceQueue清除已无意义ExceptionNode        expungeStaleExceptions();        //exptionTable是static ExceptionNode[]存储全局异常        ExceptionNode[] t = exceptionTable;        e = t[h &amp; (t.length - 1)];//以HashCode求数组下标        while (e != null &amp;&amp; e.get() != this)            e = e.next;//得到对于ExceptionNode    } finally {        lock.unlock();    }    Throwable ex;    if (e == null || (ex = e.ex) == null)//从ExceptionNode中取异常        return null;    // 如果出错线程不是当前线程，则在构造此异常以便在提供准确的异常堆栈轨迹    if (e.thrower != Thread.currentThread().getId()) {        Class&lt;? extends Throwable&gt; ec = ex.getClass();        try {        // ...........        } catch (Exception ignore) {        }    }    return ex;}</code></pre><p>上面已提到 ForkJoinTask 中调用到此方法获取异常的有 get、join、invoke、invokeAll<br>其中的 join、invoke、invokeAll 采用如下抛出 Unchecked 异常，而JDK源码示例中也<strong>推荐在任务体中使用这几种</strong>。</p><pre><code>static void rethrow(Throwable ex) {    if (ex != null)        ForkJoinTask.&lt;RuntimeException&gt;uncheckedThrow(ex);}@SuppressWarnings(&quot;unchecked&quot;) static &lt;T extends Throwable&gt;    void uncheckedThrow(Throwable t) throws T {    throw (T)t; }</code></pre><p>而 get 因实现自 Future 而将异常封装成统一的 ExecutionException </p><pre><code>public final V get() throws InterruptedException, ExecutionException {    int s = (Thread.currentThread() instanceof ForkJoinWorkerThread) ?        doJoin() : externalInterruptibleAwaitDone();    Throwable ex;    if ((s &amp;= DONE_MASK) == CANCELLED)        throw new CancellationException();    if (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != null)        throw new ExecutionException(ex);//封装成统一的Checked异常    return getRawResult();}</code></pre><blockquote><p> <strong>因此只要在执行体中进行合适 Fork/Join 任务分解，并在非 Fork/Join 中给 ForkJoinPool 提交后调用提交或返回的 ForkJoinTask 中 get、join、invoke 方法（即使无返回值也可以调用来抛出），再加以 try/catch 就能捕获到任务体执行过程中的异常。</strong></p></blockquote><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p> 要是我通过<code> ForkJoinPool.execute(Runnable) </code> 提交的任务，本身就没有 <code>ForkJoinTask </code>且此方法也没有返回 <code>ForkJoinTask</code> ，这种情况将如何捕获异常呢？</p><p>其实此方法将 Runnable 封装为 ForkJoinTask 的子类，此子类拓展了上面提到的 <code>internalPropagateException(Throwable) </code>异常传播方法，并在其中抛出异常被在上文介绍的 <code>ForkJoinWorkerThread.run()</code>这个方法捕获，并调用 ForkJoinWorkerThread 中<code> onTermination(Throwable exception) </code> 收尾函数，最终都将调用 <code>ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) </code>并在其中抛出。</p><pre><code>try {     onTermination(exception); // 可添加自定义处理，但不做捕获     } catch (Throwable ex) {         if (exception == null)             exception = ex;     } finally {         pool.deregisterWorker(this, exception);// 最终都将抛出异常     }</code></pre><p>没人管了？肯定不会的。</p><p>第一部分讲到的<code> Thread.UncaughtExceptionHandler </code>在这里也同样起作用，给 ForkJoinPool 构造函数传入UncaughtExceptionHandler，则所有 <code> ForkJoinWorkerThread </code>都将被设置成此以处理异常（设计得就是这么周到 XD）。当然你要不嫌麻烦选择自定义<code> ForkJoinWorkerThreadFactory </code>也是没问题的</p><pre><code>public ForkJoinPool(int parallelism,                    ForkJoinWorkerThreadFactory factory,                    UncaughtExceptionHandler handler,                    boolean asyncMode) {    this(checkParallelism(parallelism),         checkFactory(factory),         handler,         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,         &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);    checkPermission();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在逛同性交友网站GitHub的时候看到一个解析线程池异常处理的Issue，正好是曾经自己遇到过的问题。在此记录下来，并将其拓展到其他类型的线程池。&lt;/p&gt;
&lt;p&gt;本文因篇幅省略了诸多AQS相关知识，可以查看博客中另一篇博文 &lt;a href=&quot;/2017/08/25/Analyze-JDK-AQS/&quot;&gt;一行一行源码分析清楚AQS&lt;/a&gt; 以保证清楚理解本文。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
    
      <category term="Java" scheme="http://zhongm.in/tags/Java/"/>
    
      <category term="JVM" scheme="http://zhongm.in/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LockSupport.park 与wait用法示例</title>
    <link href="http://zhongm.in/2017/08/26/Use-Example-locksupport-And-Wait/"/>
    <id>http://zhongm.in/2017/08/26/Use-Example-locksupport-And-Wait/</id>
    <published>2017-08-26T09:49:35.000Z</published>
    <updated>2017-09-29T11:27:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>自Java1.6引入的LockSupport为开发者提供新的阻塞、唤醒线程的原语方法，只是平时都是使用已经封装好的各种Lock、Latch、Synchronizer并不常见到。在学习过程中看到这篇对比LockSupport.park() 方法和wait() 方法的示例<a href="http://www.cnblogs.com/skywang12345/p/3505784.html" target="_blank" rel="noopener">Java多线程系列–“JUC锁”07之 LockSupport</a><a href="http://www.cnblogs.com/skywang12345/p/3505784.html" target="_blank" rel="noopener"> </a>来自<a href="http://www.cnblogs.com/skywang12345/" target="_blank" rel="noopener">skywang12345</a>是的引起自己诸多疑惑，便打算按照编码实践一番。<a id="more"></a></p><p>在这就直接绕过基本介绍 ，详细实现可参考 <a href="https://my.oschina.net/readjava/blog/282882" target="_blank" rel="noopener">https://my.oschina.net/readjava/blog/282882</a></p><h3 id="LockSupport-函数列表"><a href="#LockSupport-函数列表" class="headerlink" title="LockSupport 函数列表"></a>LockSupport 函数列表</h3><pre class="lang:java decode:true" title="LockSupport-method">// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。static Object getBlocker(Thread t)// 为了线程调度，禁用当前线程，除非许可可用。static void park()// 为了线程调度，在许可可用之前禁用当前线程。static void park(Object blocker)// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。static void parkNanos(long nanos)// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。static void parkNanos(Object blocker, long nanos)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(long deadline)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(Object blocker, long deadline)// 如果给定线程的许可尚不可用，则使其可用。static void unpark(Thread thread)</pre><h3 id="Object-wait-阻塞示例"><a href="#Object-wait-阻塞示例" class="headerlink" title="Object.wait() 阻塞示例"></a>Object.wait() 阻塞示例</h3><pre class="lang:java decode:true" title="Object.wait()">public class WaitTest {    public static void main(String[] args) {        ThreadA ta = new ThreadA("ta");        synchronized(ta) { // 通过synchronized(ta)获取“对象ta的同步锁”            try {                System.out.println(Thread.currentThread().getName()+" start ta");                ta.start();//断点一                System.out.println("Do something before "+Thread.currentThread().getName()+"block");                for (int i=0;i&lt;Integer.MAX_VALUE;i++) ;                System.out.println(Thread.currentThread().getName()+" block");                // 主线程等待                ta.wait();//断点二                System.out.println(Thread.currentThread().getName()+" continue");            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    static class ThreadA extends Thread{        public ThreadA(String name) {            super(name);        }        public void run() {            synchronized (this) { // 通过synchronized(this)获取“当前对象的同步锁”                System.out.println(Thread.currentThread().getName()+" wakup others");//断点三                notify();    // 唤醒“当前对象上的等待线程”                System.out.println("After wakup");//断点四            }        }    }}</pre><p>输出：</p><pre class="lang:java decode:true" title="result1">main start taDo something before mainblockmain blockta wakup othersAfter wakupmain continue</pre><p>断点经历过程顺序：</p><table style="height: 33px;" width="705"><tbody><tr><th>线程名</th><td>断点一</td><td>断点二</td><td>断点三</td><td>断点四</td></tr><tr><th>main</th><td>RUNNING</td><td>RUNNING</td><td>WAIT</td><td>MONITOR</td></tr><tr><th>ta</th><td>未创建</td><td>MONITOR</td><td>RUNNING</td><td>RUNNING</td></tr></tbody></table><p>断点二开始：</p><blockquote><p>ta 线程 MONITOR 状态表示线程处于 synchronized (this)，正在等待main 线程释放 ta 对象的锁（monitor）</p><p>main 线程中调用 ta.wait() 释放对象 ta 的锁，并进入WAIT 状态，ta 线程获取到锁后进入 RUNNING状态</p><p>ta 线程中调用 notify() 唤醒一个调用自身对象 ta.wait() 方法的线程，于是 main 线程状态从WAIT到MONITOR</p></blockquote><p>&nbsp;</p><h3 id="LockSupport-park-阻塞示例"><a href="#LockSupport-park-阻塞示例" class="headerlink" title="LockSupport.park() 阻塞示例"></a>LockSupport.park() 阻塞示例</h3><pre class="lang:java decode:true" title="LockSupport.park()">import java.util.concurrent.locks.LockSupport;public class LockSupportTest1 {    private static Thread mainThread;    public static void main(String[] args) {        ThreadA ta = new ThreadA("ta");        // 获取主线程        mainThread = Thread.currentThread();        System.out.println(Thread.currentThread().getName()+" start ta");        ta.start();//断点一        System.out.println(Thread.currentThread().getName()+" block");        // 主线程阻塞        LockSupport.park(Thread.currentThread());//断点二        System.out.println(Thread.currentThread().getName()+" continue");    }    static class ThreadA extends Thread{        public ThreadA(String name) {            super(name);        }        public void run() {            System.out.println(Thread.currentThread().getName()+" wakup others");//断点三            // 唤醒“主线程”            LockSupport.unpark(mainThread);            System.out.println("After wakup others");//断点四        }    }}</pre><p>断点顺序很可能是 一 -&gt; 三 -&gt; 四 -&gt; 二 或者 一 -&gt; 三 -&gt;二 等等，单是线程都不会出现 MONITOR 状态</p><p>所有输出的情况也有多种情况，甚至会出现先执行unpark 后执行 park 当时依然可以输出 main continue</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、wait 是通过线程对对象的锁的占用、释放来间接实现阻塞、和唤醒的，并且调用对象的wait 方法 必须要拥有此对象的锁。而 park 则实现线程阻塞机制却不同，不需要对对象的锁进行操作。</p><p>2、若通过wait 方法调用来实现线程间阻塞、唤醒的配合的话，需要考虑好wait 和 notify、notifyAll 的配合顺序，不然可能出现先执行notify 后执行notify 导致线程一直处于WAIT 状态。而通过park 和 unpark 实现线程间的配合则不需要考虑这些，即使 unpark 先执行不会阻塞线程 ，后执行 park 也不会阻塞线程。这是因为实现上 park 和 unpark 是通过对被称为许可证的数值进行增减操作，通过对此许可证值的判断来进行阻塞、唤醒操作的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>详细介绍实现 <a href="https://my.oschina.net/readjava/blog/282882" target="_blank" rel="noopener">https://my.oschina.net/readjava/blog/282882</a></p><p>Oracle官方文档 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html</a></p><p>简书 <a href="http://www.jianshu.com/u/42116042245c" target="_blank" rel="noopener">miaoLoveCode</a> <a href="http://www.jianshu.com/p/ceb8870ef2c5" target="_blank" rel="noopener">http://www.jianshu.com/p/ceb8870ef2c5</a></p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自Java1.6引入的LockSupport为开发者提供新的阻塞、唤醒线程的原语方法，只是平时都是使用已经封装好的各种Lock、Latch、Synchronizer并不常见到。在学习过程中看到这篇对比LockSupport.park() 方法和wait() 方法的示例&lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3505784.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java多线程系列–“JUC锁”07之 LockSupport&lt;/a&gt;&lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3505784.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; &lt;/a&gt;来自&lt;a href=&quot;http://www.cnblogs.com/skywang12345/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;skywang12345&lt;/a&gt;是的引起自己诸多疑惑，便打算按照编码实践一番。
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一行一行源码分析清楚AQS[转]</title>
    <link href="http://zhongm.in/2017/08/25/Analyze-JDK-AQS/"/>
    <id>http://zhongm.in/2017/08/25/Analyze-JDK-AQS/</id>
    <published>2017-08-25T12:41:07.000Z</published>
    <updated>2019-07-13T14:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分析java并发包java.util.concurrent源码的时候，少不了需要了解AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是java并发包的基础工具类，是实现ReentrantLock、CountDownLatch、Semaphore、FutureTask等类的基础。</p><p>Google一下AbstractQueuedSynchronizer，我们可以找到很多关于AQS的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从ReentrantLock的公平锁源码出发，分析下AbstractQueuedSynchronizer这个类是怎么工作的，希望能给大家提供一些简单的帮助。<a id="more"></a></p><p>原文链接 <a href="https://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener">https://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/</a></p><p>申明以下几点：</p><ol><li>本文有点长，但是很简单很简单很简单，主要面向读者对象为并发编程的初学者，或者想要阅读java并发包源码的开发者。</li><li>建议在电脑上阅读，如果你想好好地理解所有的细节，而且你从来没看过相关的分析，你可能至少需要20分钟仔细看所有的描述，本文后面的1/3以上很简单，前面的1/4更简单，中间的部分要好好看。</li><li>如果你不知道为什么要看这个，我想告诉你，即使你看懂了所有的细节，你可能也不能把你的业务代码写得更好</li><li>源码环境JDK1.7，看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea大神的代码写得真心不错。</li><li>有很多英文注释我没有删除，这样读者可以参考着英文说的来，万一被我忽悠了呢</li><li>本文不分析共享模式，这样可以给读者减少很多负担，只要把独占模式看懂，共享模式读者应该就可以顺着代码看懂了。而且也不分析condition部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的ReentrantLock的概念，本质上来说是不正确的，读者应该清楚，AQS不仅仅用来实现锁，只是希望读者可以用锁来联想AQS的使用场景，降低读者的阅读压力</li><li>ReentrantLock的公平锁和非公平锁只有一点点区别，没有任何阅读压力</li><li>你需要提前知道什么是CAS(CompareAndSet)<br>废话结束，开始。</li></ol><h2 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h2><p>先来看看AQS有哪些属性，搞清楚这些基本就知道AQS是什么套路了，毕竟可以猜嘛！</p><pre class="lang:java decode:true" title="AQS-Structure">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的private transient volatile Node head;// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个隐视的链表private transient volatile Node tail;// 这个是最重要的，不过也是最简单的，代表当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁// 之所以说大于0，而不是等于1，是因为锁可以重入嘛，每次重入都加上1private volatile int state;// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁// if (currentThread == getExclusiveOwnerThread()) {state++}private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</pre><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer的等待队列示意如下所示，注意了，之后分析过程中所说的queue，也就是阻塞队列不包含head，不包含head，不包含head。</p><p><img src="/images/2017/08/aqs-0.png" alt></p><p>等待队列中每个线程被包装成一个node，数据结构是链表，一起看看源码吧：</p><pre class="lang:java decode:true " title="AQS-src1">static final class Node {    /** Marker to indicate a node is waiting in shared mode */    // 标识节点当前在共享模式下    static final Node SHARED = new Node();    /** Marker to indicate a node is waiting in exclusive mode */    // 标识节点当前在独占模式下    static final Node EXCLUSIVE = null;    // ======== 下面的几个int常量是给waitStatus用的 ===========    /** waitStatus value to indicate thread has cancelled */    // 代码此线程取消了争抢这个锁    static final int CANCELLED =  1;    /** waitStatus value to indicate successor's thread needs unparking */    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒    static final int SIGNAL    = -1;    /** waitStatus value to indicate thread is waiting on condition */    // 本文不分析condition，所以略过吧    static final int CONDITION = -2;    /**     * waitStatus value to indicate the next acquireShared should     * unconditionally propagate     */    // 同样的不分析，略过吧    static final int PROPAGATE = -3;    // =====================================================    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，    // 也许就是说半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。    volatile int waitStatus;    // 前驱节点的引用    volatile Node prev;    // 后继节点的引用    volatile Node next;    // 这个就是线程本尊    volatile Thread thread;}</pre><p>Node的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说ReentrantLock的公平锁。多嘴一下，我说的阻塞队列不包含head节点。</p><p><img src="/images/2017/08/aqs-0.png" alt></p><p>首先，我们先看下ReentrantLock的使用方式。</p><pre class="lang:java decode:true " title="AQS-sample1">// 我用个web开发中的service概念吧public class OrderService {    // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个    private static ReentrantLock reentrantLock = new ReentrantLock(true);    public void createOrder() {        // 比如我们同一时间，只允许一个线程创建订单        reentrantLock.lock();        // 通常，lock 之后紧跟着 try 语句        try {            // 这块代码同一时间只能有一个线程进来(获取到锁的线程)，            // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来            // 执行代码...            // 执行代码...            // 执行代码...        } finally {            // 释放锁            reentrantLock.unlock();        }    }}</pre><p>ReentrantLock在内部用了内部类Sync来管理锁，所以真正的获取锁和释放锁是由Sync的实现类来控制的。</p><pre class="lang:java decode:true" title="AQS-src2">abstract static class Sync extends AbstractQueuedSynchronizer {}</pre><p>Sync有两个实现，分别为NonfairSync（非公平锁）和FairSync（公平锁），我们看FairSync部分。</p><pre class="lang:java decode:true " title="ReentrantLock1">public ReentrantLock(boolean fair) {    sync = fair ? new FairSync() : new NonfairSync();}</pre><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><pre class="lang:java decode:true " title="AQS-src2">static final class FairSync extends Sync {    private static final long serialVersionUID = -3000897897090466540L;      // 争锁    final void lock() {        acquire(1);    }      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。    // 否则，acquireQueued方法会将线程压到队列中    public final void acquire(int arg) { // 此时 arg == 1        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试        // 因为有可能直接就成功了呢，也就不需要进队列排队了，        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)        if (!tryAcquire(arg) &amp;&amp;            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {              selfInterrupt();        }    }    /**     * Fair version of tryAcquire.  Don't grant access unless     * recursive call or no waiters or is first.     */    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取    protected final boolean tryAcquire(int acquires) {        final Thread current = Thread.currentThread();        int c = getState();        // state == 0 此时此刻没有线程持有锁        if (c == 0) {            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，            // 看看有没有别人在队列中等了半天了            if (!hasQueuedPredecessors() &amp;&amp;                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=                // 因为刚刚还没人的，我判断过了😂😂😂                compareAndSetState(0, acquires)) {                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁                setExclusiveOwnerThread(current);                return true;            }        }          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1        else if (current == getExclusiveOwnerThread()) {            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error("Maximum lock count exceeded");            setState(nextc);            return true;        }        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁        // 回到上面一个外层调用方法继续看:        // if (!tryAcquire(arg)         //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))         //     selfInterrupt();        return false;    }    // 假设tryAcquire(arg) 返回false，那么代码将执行：      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)    /**     * Creates and enqueues node for current thread and given mode.     *     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared     * @return the new node     */    // 此方法的作用是把线程包装成node，同时进入到队列中    // 参数mode此时是Node.EXCLUSIVE，代表独占模式    private Node addWaiter(Node mode) {        Node node = new Node(Thread.currentThread(), mode);        // Try the fast path of enq; backup to full enq on failure        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后        Node pred = tail;        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)        if (pred != null) {             // 设置自己的前驱 为当前的队尾节点            node.prev = pred;             // 用CAS把自己设置为队尾, 如果成功后，tail == node了            if (compareAndSetTail(pred, node)) {                 // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，                // 上面已经有 node.prev = pred                // 加上下面这句，也就实现了和之前的尾节点双向连接了                pred.next = node;                // 线程入队了，可以返回了                return node;            }        }        // 仔细看看上面的代码，如果会到这里，        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的        enq(node);        return node;    }    /**     * Inserts node into queue, initializing if necessary. See picture above.     * @param node the node to insert     * @return node's predecessor     */    // 采用自旋的方式入队    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的    private Node enq(final Node node) {        for (;;) {            Node t = tail;            // 之前说过，队列为空也会进来这里            if (t == null) { // Must initialize                // 初始化head节点                // 细心的读者会知道原来head和tail初始化的时候都是null，反正我不细心                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢                if (compareAndSetHead(new Node()))                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了                    // 这个时候有了head，但是tail还是null，设置一下，                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了                    tail = head;            } else {                // 下面几行，和上一个方法 addWaiter 是一样的，                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排                node.prev = t;                if (compareAndSetTail(t, node)) {                    t.next = node;                    return t;                }            }        }    }    // 现在，又回到这段代码了    // if (!tryAcquire(arg)     //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))     //     selfInterrupt();    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了    final boolean acquireQueued(final Node node, int arg) {        boolean failed = true;        try {            boolean interrupted = false;            for (;;) {                final Node p = node.predecessor();                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列                // 所以当前节点可以去试抢一下锁                // 这里我们说一下，为什么可以去试试：                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state                if (p == head &amp;&amp; tryAcquire(arg)) {                    setHead(node);                    p.next = null; // help GC                    failed = false;                    return interrupted;                }                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    interrupted = true;            }        } finally {            if (failed)                cancelAcquire(node);        }    }    /**     * Checks and updates status for a node that failed to acquire.     * Returns true if thread should block. This is the main signal     * control in all acquire loops.  Requires that pred == node.prev     *     * @param pred node's predecessor holding status     * @param node the node     * @return {@code true} if thread should block     */    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {        int ws = pred.waitStatus;        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true        if (ws == Node.SIGNAL)            /*             * This node has already set status asking a release             * to signal it, so it can safely park.             */            return true;        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。这里需要知道这点：        // 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，        // 找前驱节点的前驱节点做爹，往前循环总能找到一个好爹的        if (ws &gt; 0) {            /*             * Predecessor was cancelled. Skip over predecessors and             * indicate retry.             */            do {                node.prev = pred = pred.prev;            } while (pred.waitStatus &gt; 0);            pred.next = node;        } else {            /*             * waitStatus must be 0 or PROPAGATE.  Indicate that we             * need a signal, but don't park yet.  Caller will need to             * retry to make sure it cannot acquire before parking.             */            // 仔细想想，如果进入到这个分支意味着什么            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        }        return false;    }    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)    // 这个方法结束根据返回值我们简单分析下：    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看    // 跳回到前面是这个方法    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;    //                parkAndCheckInterrupt())    //                interrupted = true;    // 1\. 如果shouldParkAfterFailedAcquire(p, node)返回true，    // 那么需要执行parkAndCheckInterrupt():    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======    private final boolean parkAndCheckInterrupt() {        LockSupport.park(this);        return Thread.interrupted();    }    // 2\. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。}</pre><p>说到这里，也就明白了，多看几遍final boolean acquireQueued(final Node node, int arg)这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被LockSupport.park(this);挂起停止，等待被唤醒。</p><pre class="lang:java decode:true " title="AQS-src3">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了public void unlock() {    sync.release(1);}public final boolean release(int arg) {    // 往后看吧    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}// 回到ReentrantLock看tryRelease方法protected final boolean tryRelease(int releases) {    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    // 是否完全释放锁    boolean free = false;    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉    if (c == 0) {        free = true;        setExclusiveOwnerThread(null);    }    setState(c);    return free;}/** * Wakes up node's successor, if one exists. * * @param node the node */// 唤醒后继节点// 从上面调用处知道，参数node是head头结点private void unparkSuccessor(Node node) {    /*     * If status is negative (i.e., possibly needing signal) try     * to clear in anticipation of signalling.  It is OK if this     * fails or if status is changed by waiting thread.     */    int ws = node.waitStatus;    // 如果head节点当前waitStatus&lt;0, 将其修改为0    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    /*     * Thread to unpark is held in successor, which is normally     * just the next node.  But if cancelled or apparently null,     * traverse backwards from tail to find the actual     * non-cancelled successor.     */    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的    Node s = node.next;    if (s == null || s.waitStatus &gt; 0) {        s = null;        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    }    if (s != null)        // 唤醒线程        LockSupport.unpark(s.thread);}</pre><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><pre class="lang:java decode:true " title="AQS-src4">private final boolean parkAndCheckInterrupt() {    LockSupport.park(this); // 刚刚线程被挂起在这里了    return Thread.interrupted();}// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</pre><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是state的作用，它为0的时候代表没有线程占有锁，可以去争抢这个锁，用CAS将state设为1，如果CAS成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行+1就可以，解锁就是减1，直到state又变为0，代表释放锁，所以lock()和unlock()必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS中采用了LockSupport.park(thread) 来挂起线程，用unpark来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个queue来管理这些线程，AQS用的是一个FIFO的队列，就是一个链表，每个node都持有后继节点的引用。AQS采用了CLH锁的变体来实现，感兴趣的读者可以参考这篇文章关于CLH的介绍，写得简单明了: <a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">http://coderbee.net/index.php/concurrent/20131115/577</a></li></ol><h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回true了，结束。只是设置了state=1，连head都没有初始化，更谈不上什么阻塞队列了。要是线程1调用unlock()了，才有线程2来，那世界就太太太平了，完全没有交集嘛，那我还要AQS干嘛。</p><p>如果线程1没有调用unlock()之前，线程2调用了lock(), 想想会发生什么？</p><p>线程2会初始化head【new Node()】，同时线程2也会插入到阻塞队列并挂起 (注意看这里是一个for循环，而且设置head和tail的部分是不return的，只有入队成功才会跳出循环)</p><pre class="lang:java decode:true" title="AQS-src5">private Node enq(final Node node) {    for (;;) {        Node t = tail;        if (t == null) { // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        } else {            node.prev = t;            if (compareAndSetTail(t, node)) {                t.next = node;                return t;            }        }    }}</pre><p>首先，是线程2初始化head节点，此时head==tail, waitStatus==0</p><p><img src="/images/2017/08/aqs-1.png" alt></p><p>然后线程2入队：</p><p><img src="/images/2017/08/aqs-2.png" alt></p><p>同时我们也要看此时节点的waitStatus，我们知道head节点是线程2初始化的，此时的waitStatus没有设置，java默认会设置为0，但是到shouldParkAfterFailedAcquire这个方法的时候，线程2会把前驱节点，也就是head的waitStatus设置为-1。</p><p>那线程2节点此时的waitStatus是多少呢，由于没有设置，所以是0；</p><p>如果线程3此时再进来，直接插到线程2的后面就可以了，此时线程3的waitStatus是0，到shouldParkAfterFailedAcquire方法的时候把前驱节点线程2的waitStatus设置为-1。</p><p><img src="/images/2017/08/aqs-3.png" alt></p><p>这里可以简单说下waitStatus中SIGNAL(-1)状态的意思，Doug Lea注释的是：代表后继节点需要被唤醒。也就是说这个waitStatus其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个node在入队的时候，都会把前驱节点的状态改为SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着“waitStatus代表后继节点的状态”这种思路去看一遍源码。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分析java并发包java.util.concurrent源码的时候，少不了需要了解AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是java并发包的基础工具类，是实现ReentrantLock、CountDownLatch、Semaphore、FutureTask等类的基础。&lt;/p&gt;
&lt;p&gt;Google一下AbstractQueuedSynchronizer，我们可以找到很多关于AQS的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。&lt;/p&gt;
&lt;p&gt;本文将从ReentrantLock的公平锁源码出发，分析下AbstractQueuedSynchronizer这个类是怎么工作的，希望能给大家提供一些简单的帮助。
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
      <category term="转载" scheme="http://zhongm.in/categories/Java/%E8%BD%AC%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Chrome 插件推荐</title>
    <link href="http://zhongm.in/2017/08/18/Chrome-Plugins/"/>
    <id>http://zhongm.in/2017/08/18/Chrome-Plugins/</id>
    <published>2017-08-18T12:36:02.000Z</published>
    <updated>2019-07-13T13:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在经历本人金融危机后，终于重新搭建起自己的”帆樯”服务器。不得不说呼吸外面新鲜空气的感觉真是太爽了，赶紧把公司电脑里饥渴的Chrome折腾起来。在这里推荐几个在个人工作中感觉很实用的插件。</p><p><img src="/images/2017/08/google_chrome.png" alt></p><a id="more"></a><h3 id="1、Infinity新标签页"><a href="#1、Infinity新标签页" class="headerlink" title="1、Infinity新标签页"></a>1、Infinity新标签页</h3><p>是我折腾过的标签页中最满意的。界面美观简洁、功能丰富。并提供天气预报、笔记、待办事项及诸多自定义功能。</p><p><img src="/images/2017/08/infinity.png" alt></p><h3 id="2、马克飞象"><a href="#2、马克飞象" class="headerlink" title="2、马克飞象"></a>2、马克飞象</h3><p>来自印象笔记的Chrome插件。如果你不满足于简单的笔记，那么这个支持Markdown语法的笔记插件可以尝试下。即开即用、功能齐全，如需云笔记功能可以绑定自己印象笔记账号。</p><p><img src="/images/2017/08/Markfeixiang.png" alt></p><h3 id="3、Vimium"><a href="#3、Vimium" class="headerlink" title="3、Vimium"></a>3、Vimium</h3><p>号称黑客的浏览器插件。通过提供键盘快捷键来操作Chrome，实现类似Vim 一般的0鼠标操作。下图帮助界面包含基本的操作快捷键，你可以使用高级或自定义（其中的很多操作快捷键与真正的Vim快捷键不一致，有Vim强迫症的慎入）。</p><p><img src="/images/2017/08/Vimium.jpg" alt>)更清晰的中文说明可以看看简书的<a href="http://www.jianshu.com/p/5b627a24f7aa" target="_blank" rel="noopener">这篇</a></p><h3 id="4、Postman-amp-amp-Firebug"><a href="#4、Postman-amp-amp-Firebug" class="headerlink" title="4、Postman &amp;&amp; Firebug"></a>4、Postman &amp;&amp; Firebug</h3><p>这两个算是经典的IT插件。前者提供简单、齐全的API测试功能，后者更是前端开发者必备，懂的应该都懂就不多介绍了。</p><h3 id="5、Awesome-Screenshot"><a href="#5、Awesome-Screenshot" class="headerlink" title="5、Awesome Screenshot"></a>5、Awesome Screenshot</h3><p>正如名字及下图的说明一样，这个功能强大的截屏插件算是最好用的了。</p><p><img src="/images/2017/08/screenshot.png" alt></p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在经历本人金融危机后，终于重新搭建起自己的”帆樯”服务器。不得不说呼吸外面新鲜空气的感觉真是太爽了，赶紧把公司电脑里饥渴的Chrome折腾起来。在这里推荐几个在个人工作中感觉很实用的插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2017/08/google_chrome.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://zhongm.in/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux parted、siege 工具小记</title>
    <link href="http://zhongm.in/2017/08/16/Linux-Tool-pared-And-siege-Notes/"/>
    <id>http://zhongm.in/2017/08/16/Linux-Tool-pared-And-siege-Notes/</id>
    <published>2017-08-16T14:31:55.000Z</published>
    <updated>2019-07-13T14:01:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一会在折腾debian9系统，尝试磁盘操作时发现就只有个df 命令并没有fdisk、cfdisk等工具。于是找到了parted这一工具（其实在我之前一直用的Ubuntu中有，只是fdisk、cfdisk用的多一点）。而siege 则是一个FTP/HTTP压力测试工具，能够很方便测试自己的web系统。</p><p><img src="/images/2017/08/DebianDesktop.png" alt="漂亮简洁的Debian桌面"></p><a id="more"></a><h2 id="1、parted"><a href="#1、parted" class="headerlink" title="1、parted"></a>1、parted</h2><p>强大的磁盘管理工具。安装的话只需要简单的apt-get，并且运行时需要以root身份。</p><p>parted -l 将列出所有系统能识别的磁盘设备，如下图中有一块8590MB的磁盘设备/dev/sdc，这是刚用vmware给debian添加的一块硬盘。</p><p><img src="/images/2017/08/parted1.png" alt></p><p>下图是完整的分区过程：</p><p><img src="/images/2017/08/parted6.png" alt="完整步骤"></p><p>步骤说明：</p><ol><li>执行 sudo parted 进入交互模式，默认选中/dev/sda 设备</li><li>输入 help 打印提示信息</li><li>输入 select /dev/sdc 选中需要操作的磁盘设备</li><li>输入 make gpt 设置分区模式为 gpt</li><li>输入 mkpart extended 64s 4MiB 新建extended 小分区 （此举为了对齐磁盘分区）</li><li>输入 mkpart primary 4MiB 8590MiB 新建 primary 主分区（提示越界）</li><li>输入 mkpart primary 4MiB -1s  新建primary 主分区（-1s 为最后一个Sector ，工具将自动提示我们，输入Yes即可）</li><li>输入 print 打印 /dev/sdc 磁盘设备分区情况（两个分区）</li><li>输入 help align-check 打印对齐检测帮助信息（可略）</li><li>输入 align-check optimal 2 检查 primary 分区对齐情况（align-type 可选minimal、optimal 或缩写），符合对齐则显示 2 aligned</li><li>quit 退出操作<br>之后需要格式化 primary 分区（文件系统ext4）：<pre class="lang:sh decode:true" title="mkfs.ext4">sudo mkfs.ext4 /dev/sdc2</pre><img src="/images/2017/08/parted4.png" alt></li></ol><p>&nbsp;</p><p>最后挂载 /dev/sdc2 到你需要的目录即可使用</p><pre class="lang:sh decode:true " title="mount">mount /dev/sdc2 /mnt</pre><p>修改 /etc/fstab 文件可以开机自动挂载设备，格式如下（各个&lt;&gt;值、作用可以通过 man fstab 查看到详细信息）：</p><p><img src="/images/2017/08/parted7.png" alt></p><blockquote><p>注：其中 &lt;file system&gt; 可以是 /dev/sdc2 ，也可是此分区的UUID。UUID可以在 /dev/disk/by-uuid 中查看到所有的。</p><p><img src="/images/2017/08/parted8.png" alt><br>关于磁盘、分区、文件系统资料：</p></blockquote><p><a href="http://www.cnblogs.com/sammyliu/p/4521315.html" target="_blank" rel="noopener">http://www.cnblogs.com/sammyliu/p/4521315.html</a></p><p>关于磁盘分区对齐：</p><p><a href="https://linux.cn/article-3167-1.html" target="_blank" rel="noopener">https://linux.cn/article-3167-1.html</a></p><p>GNU parted命令手册：</p><p><a href="http://www.gnu.org/software/parted/manual/parted.html" target="_blank" rel="noopener">http://www.gnu.org/software/parted/manual/parted.html</a></p><h2 id="2、siege"><a href="#2、siege" class="headerlink" title="2、siege"></a>2、siege</h2><p>支持HTTP/HTTPS/FTP的压力测试工具。安装同样很简单apt-get（Debian、Ubuntu一致的让人感动），而且使用很简单。</p><h3 id="常见参数："><a href="#常见参数：" class="headerlink" title="常见参数："></a>常见参数：</h3><blockquote><p>-c 200 指定并发数200</p><p>-r 5 指定测试的次数5</p><p>-f urls.txt 制定url的文件</p><p>-i internet系统，随机发送url</p><p>-b 请求无需等待 delay=0</p><p>-t 5 持续测试5分钟</p><p>-d 设置测试的delay</p><p> -r和-t一般不同时使用</p></blockquote><h3 id="常见使用："><a href="#常见使用：" class="headerlink" title="常见使用："></a>常见使用：</h3><p>50个用户（每次并发量）重复100次 共产生 50*100 个请求</p><div><pre class="lang:sh decode:true " title="example1">/usr/local/siege/bin/siege -c 50 -r 100 www.baidu.com</pre>50个用户 重复100次 发送POST参数(从文件中读取)<pre class="lang:sh decode:true" title="example2">/usr/local/siege/bin/siege -c 50 -r 100 \    "https://www.abc.com/a.php POST &lt; /root/ab_test/post.xml"</pre></div><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><div>    Transactions:                     10 hits    ：服务器接收的请求数</div><div>    Availability:                 100.00 %       ：有效情况的比例</div><div>    Elapsed time:                   1.06 secs    :  测试所用的时间</div><div>    Data transferred:               0.04 MB    ：每个模拟用户的数据传输量</div><div>    Response time:                  0.03 secs    ：响应每个模拟用户请求的平均时间</div><div>    Transaction rate:               9.43 trans/sec    ：服务器每秒处理事务的平均数</div><div>    Throughput:                     0.04 MB/sec    ：服务器每秒跟所有模拟用户的数据传量</div><div>    Concurrency:                    0.25    ：每秒的模拟连接</div><div>    Successful transactions:          10    ：处理成功的事务数（code&lt;400）</div><div>    Failed transactions:               0    ： 处理失败的事务数（code&gt;400）</div><div>    Longest transaction:            0.04    ：最长的事务处理时间</div><div>    Shortest transaction:           0.02    ：最短的事务处理时间</div><div></div><div>提醒：并发太高的测试容易让待测试服务器的云平台管理员认为是DDOS攻击，并且也容易把服务器负荷太重影响正常服务。</div><h2 id="3、额外一提"><a href="#3、额外一提" class="headerlink" title="3、额外一提"></a>3、额外一提</h2><div>在使用Debian 时，发现没有预安装Vim，手动apt-get 安装后发现安装的Vim没有系统寄存器，Vim 无法使用系统剪贴板确实很不方便。</div><div></div><div>额外手动安装 vim-gnome 即可解决。</div><div></div><div>附带一张Vim键盘图</div><div>![](/images/2017/08/vim.png)</div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一会在折腾debian9系统，尝试磁盘操作时发现就只有个df 命令并没有fdisk、cfdisk等工具。于是找到了parted这一工具（其实在我之前一直用的Ubuntu中有，只是fdisk、cfdisk用的多一点）。而siege 则是一个FTP/HTTP压力测试工具，能够很方便测试自己的web系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2017/08/DebianDesktop.png&quot; alt=&quot;漂亮简洁的Debian桌面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://zhongm.in/categories/Linux/"/>
    
    
      <category term="Shell" scheme="http://zhongm.in/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>你可能不知道的Shell</title>
    <link href="http://zhongm.in/2017/07/27/The-Shell-You-Dont-Know/"/>
    <id>http://zhongm.in/2017/07/27/The-Shell-You-Dont-Know/</id>
    <published>2017-07-27T12:45:34.000Z</published>
    <updated>2019-07-13T14:07:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。</p><p>这篇文章向大家介绍Shell一些非广为人知、但却实用有趣的知识，权当品尝shell主食后的甜点吧。</p><p><img src="/images/2017/04/bash.jpg" alt></p><a id="more"></a><p>原文转载自：酷壳-CoolShell <a href="http://coolshell.cn/articles/8619.html" target="_blank" rel="noopener">http://coolshell.cn/articles/8619.html</a> （一个值得订阅的IT博客）</p><p>跳过科普</p><blockquote><p><strong>一些强大的命令</strong><br>再分享一些可能你不知道的shell用法和脚本，简单&amp;强大！</p></blockquote><p><em>在阅读以下部分前，强烈建议读者打开一个shell实验，这些都不是shell教科书里的大路货哦：）</em></p><ul><li><p><code>**!$**!$是一个特殊的环境变量，它代表了上一个命令的最后一个字符串。如：你可能会这样：$mkdir mydir$mv mydir yourdir$cd yourdir可以改成：$mkdir mydir$mv !$ yourdir$cd !$</code></p></li><li><p><strong><code>sudo !!</code></strong><br>以root的身份执行上一条命令 。<br>场景举例：比如Ubuntu里用<code>apt-get</code>安装软件包的时候是需要root身份的，我们经常会忘记在<code>apt-get</code>前加<code>sudo</code>。每次不得不加上<code>sudo</code>再重新键入这行命令，这时可以很方便的用<code>sudo !!</code>完事。<br>（陈皓注：在shell下，有时候你会输入很长的命令，你可以使用!xxx来重复最近的一次命令，比如，你以前输入过，vi /where/the/file/is, 下次你可以使用 !vi 重得上次最近一次的vi命令。）</p></li><li><p><strong><code>cd –</code></strong><br>回到上一次的目录 。<br>场景举例：当前目录为<code>/home/a</code>，用<code>cd ../b</code>切换到<code>/home/b</code>。这时可以通过反复执行<code>cd –</code>命令在<code>/home/a</code>和<code>/home/b</code>之间来回方便的切换。<br>（陈皓注：cd ~ 是回到自己的Home目录，cd ~user，是进入某个用户的Home目录）</p></li><li><p><strong>‘ALT+.’ or ‘&lt;ESC&gt; .’</strong><br>热建alt+. 或 esc+. 可以把上次命令行的参数给重复出来。</p></li><li><p><strong><code>^old^new</code></strong><br>替换前一条命令里的部分字符串。<br>场景：<code>echo &quot;wanderful&quot;</code>，其实是想输出<code>echo &quot;wonderful&quot;</code>。只需要<code>^a^o</code>就行了，对很长的命令的错误拼写有很大的帮助。（陈皓注：也可以使用 <strong>!!:gs/old/new</strong>）</p></li><li><p><strong>du -s * | sort -n | tail</strong><br>列出当前目录里最大的10个文件。</p></li><li><p><strong>:w !sudo tee %</strong><br>在vi中保存一个只有root可以写的文件</p></li><li><p><strong>date -d@1234567890</strong><br>时间截转时间</p></li><li><div title="Click to select this command"><div>**&gt; file.txt**创建一个空文件，比touch短。</div></div></li><li><p><strong>mtr coolshell.cn</strong><br>mtr命令比traceroute要好。</p></li><li><p>在命令行前加空格，该命令不会进入history里。</p></li><li><p><strong>echo “ls -l” | at midnight</strong><br>在某个时间运行某个命令。</p></li><li><p><strong>curl -u user:pass -d status=”Tweeting from the shell” <a href="http://twitter.com/statuses/update.xml" target="_blank" rel="noopener">http://twitter.com/statuses/update.xml</a></strong><br>命令行的方式更新twitter。</p></li><li><p><strong>curl -u username –silent “<a href="https://mail.google.com/mail/feed/atom”" target="_blank" rel="noopener">https://mail.google.com/mail/feed/atom”</a> | perl -ne ‘print “\t” if /&lt;name&gt;/; print “$2\n” if /&lt;(title|name)&gt;(.*)&lt;/\1&gt;/;’</strong><br>检查你的gmail未读邮件</p></li><li><p><strong>ps aux | sort -nk +4 | tail</strong><br>列出头十个最耗内存的进程</p></li><li><p><strong><code>man ascii</code></strong><br>显示ascii码表。<br>场景：忘记ascii码表的时候还需要google么?尤其在天朝网络如此“顺畅”的情况下，就更麻烦在GWF多应用一次规则了，直接用本地的<code>man ascii</code>吧。</p></li><li><p><strong><code>ctrl-x e</code></strong><br>快速启动你的默认编辑器（由变量$EDITOR设置）。</p></li><li><p><strong><code>netstat –tlnp</code></strong><br>列出本机进程监听的端口号。（陈皓注：netstat -anop 可以显示侦听在这个端口号的进程）</p></li><li><p><strong><code>tail -f /path/to/file.log | sed &#39;/^Finished: SUCCESS$/ q&#39;</code></strong><br>当file.log里出现Finished: SUCCESS时候就退出tail，这个命令用于实时监控并过滤log是否出现了某条记录。</p></li><li><p><strong><code>ssh user@server bash &amp;lt; /path/to/local/script.sh</code></strong><br>在远程机器上运行一段脚本。这条命令最大的好处就是不用把脚本拷到远程机器上。</p></li><li><p><strong>ssh user@host cat /path/to/remotefile | diff /path/to/localfile –</strong><br>比较一个远程文件和一个本地文件</p></li><li><div title="Click to select this command"><div>**net rpc shutdown -I ipAddressOfWindowsPC -U username%password**远程关闭一台Windows的机器</div></div></li><li><p><strong><code>screen -d -m -S some_name ping my_router</code></strong><br>后台运行一段不终止的程序，并可以随时查看它的状态。<code>-d -m</code>参数启动“分离”模式，<code>-S</code>指定了一个session的标识。可以通过<code>-R</code>命令来重新“挂载”一个标识的session。更多细节请参考screen用法 <code>man screen</code>。</p></li><li><p><strong><code>wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com</code></strong><br>下载整个<a href="http://www.example.com网站。（注：别太过分，大部分网站都有防爬功能了：））" target="_blank" rel="noopener">www.example.com网站。（注：别太过分，大部分网站都有防爬功能了：））</a></p></li><li><p><strong><code>curl ifconfig.me</code></strong><br>当你的机器在内网的时候，可以通过这个命令查看外网的IP。</p></li><li><p><strong>convert input.png -gravity NorthWest -background transparent -extent 720×200  output.png</strong><br>改一下图片的大小尺寸</p></li><li><p><strong><code>lsof –i</code></strong><br>实时查看本机网络服务的活动状态。</p></li><li><p><strong>vim scp://username@host//path/to/somefile</strong><br>vim一个远程文件</p></li><li><p><strong><code>python -m SimpleHTTPServer</code></strong><br>一句话实现一个HTTP服务，把当前目录设为HTTP服务目录，可以通过<code>http://localhost:8000</code>访问 这也许是这个星球上最简单的HTTP服务器的实现了。</p></li><li><p><strong><code>history | awk &#39;{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a] &quot; &quot; CMD[a]/count*100 &quot;% &quot; a }&#39; | grep -v &quot;./&quot; | column -c3 -s &quot; &quot; -t | sort -nr | nl | head -n10</code></strong><br>(陈皓注：有点复杂了，history|awk ‘{print $2}’|awk ‘BEGIN {FS=”|”} {print $1}’|sort|uniq -c|sort -rn|head -10)<br>这行脚本能输出你最常用的十条命令，由此甚至可以洞察你是一个什么类型的程序员。</p></li><li><div title="Click to select this command"><div>**tr -c “[:digit:]” ” ” &lt; /dev/urandom | dd cbs=$COLUMNS conv=unblock | GREP_COLOR=”1;32″ grep –color “[^ ]”**想看看Matrix（装逼神器）的屏幕效果吗？（不是很像，但也很Cool!）</div></div>&nbsp;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。&lt;/p&gt;
&lt;p&gt;这篇文章向大家介绍Shell一些非广为人知、但却实用有趣的知识，权当品尝shell主食后的甜点吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2017/04/bash.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://zhongm.in/categories/Linux/"/>
    
      <category term="转载" scheme="http://zhongm.in/categories/Linux/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="Shell" scheme="http://zhongm.in/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>批量删除文件脚本</title>
    <link href="http://zhongm.in/2017/07/25/Batch-Delete-Shell-Script/"/>
    <id>http://zhongm.in/2017/07/25/Batch-Delete-Shell-Script/</id>
    <published>2017-07-25T14:33:26.000Z</published>
    <updated>2019-07-13T13:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己的ECS上挂了一些备份数据库、日志、配置文件、/var/www目录等备份脚本，时间一长备份目录下的东西就多了。今天闲下来写个脚本自己批量删除下（别跟我说怎么不在备份脚本里加删除操作的，就是任性）</p><p><img src="/images/2017/04/bash.jpg" alt></p><a id="more"></a><p>一言不合上代码</p><pre class="lang:sh decode:true" title="bulkdeletescript">#!/bin/bashDIR="BACKDIR/"#删除文件所在目录，后接/PATTERN="^MySQL-[0-9]{4}(-[0-9]{2}){2}.sql$"#文件正则匹配模式DAYS=10#过期时间PREFIX="-"#日期的前缀SUFFIX=".sql"#后缀for FILE in $DIR*;do    NAME=${FILE#*$DIR}#去除路径得到文件名    if [[ $NAME =~ $PATTERN ]] &amp;&amp; test -f $FILE;then        TMP=${NAME#*$PREFIX}        DATE=${TMP%$SUFFIX*}#根据前后缀截取日期        #计算过期文件        if test $(( `date +%s`-`date +%s -d $DATE` )) -ge $[DAYS*24*60*60];then            echo "Delete expired file:$FILE"            rm $FILE#删除        fi    fidone</pre><p>例如：需要删除目录DIR为/home/root/backup/下，格式为MySQL-2017-07-21.sql的数据库备份文件。则需要正则为^MySQL-[0-9]{4}(-[0-9]{2}){2}.sql$（其实要写严谨的话老长了）。截取日期的前缀–即在日期前的一个或多个字符（），同理后缀也一样，如上代码中的。</p><p>只是练练手，查缺补漏。（菜鸟一枚，shell平时不怎么练手，一到写脚本各种查资料）下面是知识点总结：</p><p>1、${NAME#<em>PREFIX}的作用是截取从左开始PREFIX第一次出现后位置的字符串，如URL=”<a href="http://www.baidu.com&quot;;${URL#" target="_blank" rel="noopener">http://www.baidu.com&quot;;${URL#</a></em>//} 则是”<a href="http://www.baidu.com&quot;。所以若Docker-ghost-2017-07-24.log这样的截取日期的话，采用PREFIX为" target="_blank" rel="noopener">www.baidu.com&quot;。所以若Docker-ghost-2017-07-24.log这样的截取日期的话，采用PREFIX为</a> - 的话则会截取到错误的ghost-，此时可加长PREFIX为ghost-或t-</p><p>2、同上很相似，${NAME%SUFFIX<em>}的作用是截取从右开始SUFFIX第一次出现前位置的字符串，如URL=”<a href="http://www.baidu.com&quot;;${URL%//" target="_blank" rel="noopener">http://www.baidu.com&quot;;${URL%//</a></em>} 则是”http”。然后需要注意的也同上理推。</p><p>3、简单又实用一点 。for FILE in /home/root/* 或 <code>ls /home/root</code> ，这样可以遍历目录下的文件和目录，再通过 if test -f $FILE 判断是否为文件。</p><p>4、if [[   ]]其实也是一种判断方法 ，和if [  ]容易混淆。但是if [[  ]]中[[ 是shell的关键字，在bash、ksh等支持，且能够防止脚本中的许多逻辑错误。在其中可以使用 =~进行正则匹配，也可以使用在if [ ]中不能使用&amp;&amp;、||、&gt;=等。这里搬来一张图做对比：</p><p><img src="/images/2017/07/shell-test.gif" alt></p><p>5、时间差计算：date +%s获取当前时间戳，date +%s -d $DATE 获取给点日期时间戳。相减就是相差的时间，单位为秒。此外date 命令功能很强大，出了给出时间戳和给出格式化时间 date %Y-%m-%d 外，也可以获得上一或多天、上礼拜X、多天前、多个星期前、上个月等等。</p><p>6、另外不得不说的就是在shell中${ }、$[ ] 、$(( ))、 $( ) 的使用区别，[[    ]]、 [ ]、  ( )、((  ))、{ }的使用区别。有时候也是蛮让人容易混淆的。需要额外提的两个是 ${ }：用来应直接变量也包括环境变量等（当然我们上面的截取其实也是引用过程的处理）；$[ ]：可用来做基本的数值运算。</p><p>详尽的资料可以查阅这两篇博文：</p><p><a href="http://blog.chinaunix.net/uid-14351756-id-2820651.html" target="_blank" rel="noopener">shell中$(( )) 与 $( ) 还有${ }的区别</a></p><p>[shell中if条件字符串、数字比对，[[ ]]和[ ]区别](<a href="http://www.cnblogs.com/include/archive/2011/12/09/2307905.html" target="_blank" rel="noopener">http://www.cnblogs.com/include/archive/2011/12/09/2307905.html</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己的ECS上挂了一些备份数据库、日志、配置文件、/var/www目录等备份脚本，时间一长备份目录下的东西就多了。今天闲下来写个脚本自己批量删除下（别跟我说怎么不在备份脚本里加删除操作的，就是任性）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2017/04/bash.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://zhongm.in/categories/Linux/"/>
    
    
      <category term="Shell" scheme="http://zhongm.in/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>理解Java内存模型笔记</title>
    <link href="http://zhongm.in/2017/07/24/Understand-Memory-Model-Of-Java/"/>
    <id>http://zhongm.in/2017/07/24/Understand-Memory-Model-Of-Java/</id>
    <published>2017-07-24T09:31:19.000Z</published>
    <updated>2019-07-13T14:08:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在并发编程网上看到这个<a href="http://ifeve.com/java-memory-model-0/" target="_blank" rel="noopener">深入理解java内存模型系列文章</a>，文章一个系列图文并茂讲得都很不错，让我了解到了很多关于内存可见性、内存屏蔽指令一些知识。在此结合自己对《深入理解Java虚拟机》的一些理解对文章重点基础知识做个笔记。注：文章基于JSR-133内存模型</p><p><img src="/images/2017/07/JavaPic5.png" alt="Java内存模型"></p><a id="more"></a><p>如上图，Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。下面将循序渐进的介绍。</p><h3 id="1、Java内存模型抽象"><a href="#1、Java内存模型抽象" class="headerlink" title="1、Java内存模型抽象"></a>1、Java内存模型抽象</h3><p>内存模型抽象是Java虚拟机规范为实现让Java 程序在各个平台下都能达到一致性的内存访问效果而试图定义的。（<strong>此处的内存模型与Java 内存区域中相关的堆、栈不是一个层次的内存划分</strong>）</p><p>如上图，在Java中，所有实例域、静态域和数组元素存储在主内存（原文堆内存，勉强对应的话也没问题）中，主内存在线程之间共享（本文使用“共享变量”这个术语代指）。局部变量，方法定义参数（Java语言规范称之为formal method parameters）和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><h3 id="2、内存间交互操作、规则"><a href="#2、内存间交互操作、规则" class="headerlink" title="2、内存间交互操作、规则"></a>2、内存间交互操作、规则</h3><p>原文并没有介绍这一十分繁琐的一系列操作、规则，而是针对voliatile 、final 的一些特殊规定做了很详细的介绍，不过我觉得这有助于更好理解那些特殊规则。</p><p>Java内存模型定义了8种操作来完成主内存和工作内存（本地内存）之间 的具体的交互，虽然之后被弃用但内存模型没有改变。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double 、long类型某些操作在某些平台允许例外）</p><p>8种操作包括：lock（锁定M）、unlock（解锁M）、read（读取M-&gt;）、load（载入-&gt;W）、use（使用W）、assign（赋值W）、store（存储-&gt;M）、write（写入M）</p><p>//其中M代表作用于主内存，W代表作用于工作内存</p><p>此外还定义了一些基本规则（不包括volatile的特殊规定），如read必须load一起出现以完成从主内存读取数据到工作内存的操作。（规则不详细介绍，理解便可）</p><h3 id="3、三大特征中可见性"><a href="#3、三大特征中可见性" class="headerlink" title="3、三大特征中可见性"></a>3、三大特征中可见性</h3><p>Java 三个特征：原子性、可见性、有序性。通过上面提的基本操作、基本规则可大致的认为基本数据类型的访问读写具备原子性（更大规模的原子性保证有monitorenter、monitorexit–synchronized），所以直接跳过原子性来讲解可见性。</p><p><strong>可见性</strong>指的是当一个线程修改了共享变量的值，其他线程也能够立即得知修改。</p><p>Java内存模型是通过在变量修改后将新值通过回主内存，在变量读取前从主内存刷新变量值这种依赖主内存的作为传递媒介的方式来实现可见性的。（volatile的特殊规则保证新值能够立即通过到主内存，使每次使用前立即从主内存刷新。普通变量则不能保证）</p><p>原文中还提到了final的可见性问题，并详细地说明了<strong>this引用逃逸</strong>，在此就不多加篇幅论述。</p><p>此外还有一个关键字也能实现可见性，即synchronized 。同步块的可见性是由“对一个变量执行unlock操作前，必须先把此变量同步到主内存中（执行store、write操作）”这条规则获得的。</p><h3 id="4、重排序"><a href="#4、重排序" class="headerlink" title="4、重排序"></a>4、重排序</h3><p>重排序是理解下一种特征前必须要说明的。</p><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p><p><strong>数据依赖性</strong>：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分三种类型：写后读、写后写、读后写。（注：仅针对单线程和单处理器指令序列）</p><p><strong>重排序</strong>分三种类型：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，为了充分利用处理器内部的运算单元，处理器可能会对代码进行乱序执行（Out-Of-Order Execution）优化，再将乱序执行结果重组，保证该结果与顺序执行结果一致，但不保证各语句计算先后顺序与输入顺序一致。<br><img src="/images/2017/07/JavaPic6.png" alt></li></ol><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（注：仅针对单线程和单处理器指令序列）</p><h3 id="5、三大特征中有序性"><a href="#5、三大特征中有序性" class="headerlink" title="5、三大特征中有序性"></a>5、三大特征中有序性</h3><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的。</p><p>这句话的前半段可以根据上面重排序理解：单线程中，若操作间存在数据依赖性则不改变执行顺序，若不存在，则有可能进行重排序，但保证操作结果和顺序执行结果一致。故而看似都是有序的。</p><p>后半句话则指“指令重排序”现象和“工作内存和主内存同步延迟”现象。</p><p>Java语言提供volatile 和synchronized 两个关键字保证线程间操作的有序性。volatile关键字除立刻刷新主内存共享变量以外，本身包含了禁止重排序的语义。（原文中有详细的volatile语义描述）</p><h3 id="6、先行发生原则"><a href="#6、先行发生原则" class="headerlink" title="6、先行发生原则"></a>6、先行发生原则</h3><p>为什么将这一原则放在最后呢！因为此原则容易望文生义，如果在没有之前那些知识的基础上首先介绍的话，容易让人的意识里一直埋下“在前面的就是会先发生的、先执行的”误解。这会让你在接触之后的知识里很痛苦，难以理解的矛盾。（智商如我就是这样过来的 XD）</p><p>先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据。</p><p><strong>先行发生关系</strong>：如果说操作A先行发生于操作B。其实就是说在发生B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了主内存共享变量的值、发送信息、调用方法等。–《深入理解Java虚拟机》（没错，听起来好像很容易理解的样子）</p><p>原文中是通过“执行的结果”来代替上述的“产生的影响”。</p><p>那么可能会问一些问题</p><p><strong>（1）</strong>怎么判断两个操作存在先行发生关系？<strong>（2）</strong>先行发生关系能给这两个操作带来什么？</p><p>（1）Java内存模型通过限制编译器和处理器（内存屏蔽指令）的重排序，实现了无需任何同步器协助就已经存在的一些先行发生关系（只介绍大意）：</p><ul><li>程序次序规则：在一线程内，按控制流（<strong>不是代码</strong>）顺序，前面操作–&gt;后面操作</li><li>管程锁定规则：unlock操作–&gt;时间顺序后<strong>同一个锁</strong>的lock操作。</li><li>volatile规则：同上，略</li><li>线程启动规则：Thread对象start()–&gt;此线程的每一个动作</li><li>线程终止规则：线程中所有操作–&gt;此线程终止检测（Thead.join()、isAlive()）</li><li>线程中断规则：对线程interrupt()方法调用–&gt;中断检测代码</li><li>对象终结规则：一个对象的初始化完成–&gt;对象finalize()方法开始</li><li>传递性：若操作A–&gt;操作B，操作B–&gt;操作C，则操作A–&gt;操作C<br>注： –&gt; 表示先行发生于</li></ul><p>（2）正如我们定义<strong>先行发生关系</strong>，回头再看一遍定义，然后看下面的小例子</p><blockquote><p>i=1;   //这个操作在线程A中执行，代号a</p><p>j=1;   //这个操作在线程B中执行，代号b</p><p>i=2;   //这个操作在线程C中执行，代号c<br>若线程A中操作a先行发生于线程B的操作b，则可以确定在线程B执行后，变量j的值一定等于1。需要的依据：一是根据先行发生原则，a操作结果可以被b操作观察。二是线程A操作后C未执行（假设）</p></blockquote><p>在上面A、B先行发生关系基础上再假设线程C出现在A、B之间且操作c和操作b没有先行发生关系，那么j 的值是多少？答案是不确定。1,2都有可能，因为线程C对变量的影响可能被B观察到也可能不会。</p><p>此时线程B就存在读取过期数据的风险，不具备多线程安全性。</p><p><strong>先行发生关系可以保障操作之间的顺序性，和线程安全性。</strong></p><p>注：时间的先后顺序和先行发生原则之间基本没有关系（存在所谓的工作内存和和主内存的同步延迟），我们衡量并发安全问题的时候不要受到时间顺序的干扰，<strong>一切以原则为准</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在并发编程网上看到这个&lt;a href=&quot;http://ifeve.com/java-memory-model-0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入理解java内存模型系列文章&lt;/a&gt;，文章一个系列图文并茂讲得都很不错，让我了解到了很多关于内存可见性、内存屏蔽指令一些知识。在此结合自己对《深入理解Java虚拟机》的一些理解对文章重点基础知识做个笔记。注：文章基于JSR-133内存模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2017/07/JavaPic5.png&quot; alt=&quot;Java内存模型&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://zhongm.in/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Mybatis：Mapper注入Could not autowire 问题解决</title>
    <link href="http://zhongm.in/2017/07/18/Solve-Could-not-autowried-In-SpringBoot/"/>
    <id>http://zhongm.in/2017/07/18/Solve-Could-not-autowried-In-SpringBoot/</id>
    <published>2017-07-18T13:42:18.000Z</published>
    <updated>2019-07-13T14:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Springboot+Mybatis开发项目时遇到如下的错误（提示Could not autowire）。虽然能够编译运行无误，但看着让人很是郁闷：<img src="/images/2017/07/Error-Show.png" alt></p><a id="more"></a><h3 id="1、确保项目目录无问题"><a href="#1、确保项目目录无问题" class="headerlink" title="1、确保项目目录无问题"></a>1、确保项目目录无问题</h3><p>即 springboot 入口函数所在类应该在这些Mapper、Service、Controller子包上级目录，例如com.demo.Mapper、com.demo.Service ，则入口类需在com.demo包下。</p><p><img src="/images/2017/07/Error-Detail2.png" alt></p><h3 id="2、确保配置文档及入口类没问题"><a href="#2、确保配置文档及入口类没问题" class="headerlink" title="2、确保配置文档及入口类没问题"></a>2、确保配置文档及入口类没问题</h3><p>2.1 springboot 配置文档 application.properties</p><p>其中的mybatis.mapperLocations 指定 Mapper.xml 路径</p><p><img src="/images/2017/07/Error-Detail4.png" alt></p><p>2.2 入口类</p><p>@SpringBootApplication 注释等价于以默认属性使用 @Configuration，@EnableAutoConfiguration 和 @ComponentScan，通常作为主类的注解</p><p>@MapperScan 指定扫描的mapper接口所在的包 （然而我加了还是无卵用）</p><p><img src="/images/2017/07/Error-Detail3.png" alt></p><p>3、如果上述无效，只能放大招了</p><p>3.1 添加 @Repository或@Component(Value=xxxMapper”)注释</p><p>直接手动注册，使其能被发现，这样就不会报错</p><p>3.2 使用@Autowired(required=false)</p><p>此处声明使其可以允许不被注入，这样也不会报错</p><p>————————————End——————————————</p><p>具体为什么找不到 Mapper 这几天学习过程再研究研究</p><hr><p>2017.07.20 注 ：网上搜到资料说“通过在mapper 接口上添加@Mapper 注释使其可被@Autowire 使用”。</p><p>实验发现虽然也不会报错，但是依然会提示 Could not autowire 错误。之后尝试过@Resource @Qualifier 两种注释，也还是会报错。</p><p>另外通过@Mapper 注释后，就不需要在入口类中添加@MapperScan 。</p><hr><p>另外推荐个好东西 <a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok </a>，适合所有Java 开发，很大程度简化Java 代码</p><p>[embed]<a href="https://projectlombok.org/videos/lombok.ogv[/embed]" target="_blank" rel="noopener">https://projectlombok.org/videos/lombok.ogv[/embed]</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Springboot+Mybatis开发项目时遇到如下的错误（提示Could not autowire）。虽然能够编译运行无误，但看着让人很是郁闷：&lt;img src=&quot;/images/2017/07/Error-Show.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://zhongm.in/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>博客维护笔记</title>
    <link href="http://zhongm.in/2017/06/26/Blog-Maintain-Notes/"/>
    <id>http://zhongm.in/2017/06/26/Blog-Maintain-Notes/</id>
    <published>2017-06-26T11:51:54.000Z</published>
    <updated>2017-09-29T11:27:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>自端午放假后，因为发生的一些事情已有两周没管管博客了，今天上来一看发现各种问题。先是WordPress不知怎么抽风，导致登录循环跳转（以前改好过现在又犯了）；然后看Apache 日中发现一对报错，MySQL莫名的进入只读模式；登上博客又看到一堆的垃圾评论，删除都费了一会功夫。哎，杂草丛生喽！<a id="more"></a></p><h3 id="一、关于WordPress登录循环跳转"><a href="#一、关于WordPress登录循环跳转" class="headerlink" title="一、关于WordPress登录循环跳转"></a>一、关于WordPress登录循环跳转</h3><p>从资料来看，这是WordPress的老毛病了。查其原因，却没有一篇详细的说明文章，不过看到大多数文章均是归咎于WordPress中一些插件的更新，不过我觉得也有可能是下文中提到的数据库问题。（原谅我不懂PHP）</p><p>症状就是在登录界面输入正确的帐号密码后，依然是跳转至登录界面，如此循环使得用户进不了博客的后台界面。需要说明的是笔者WordPress版本是4.7，而之前还是4.6版本的时候这种症状也出现过。</p><p>解决方法：网上随便百度能发现一大堆，然而方法都是大同小异。要么就是修改wp-include目录下的pluggable.php中关于cookie设置的代码；要么是修改根目录下的wp-config.php；也有说是修改.htaccess文件的。但是笔者上一次出这个问题确实借助于第一个方法，通过修改pluggable.php文件解决了这一问题。然而这次不知怎么却没作用，试过各种方法没效果。无奈之下用上个月备份的整个博客的Web目录替换了现有的目录，结果自然是没问题了。</p><p>经过这么一出倒是庆幸自己有时常备份的好习惯。不过网上也有建议说用Windows Live Writer的，看起来不错之后尝试尝试。</p><h3 id="二、MySQL进入只读模式"><a href="#二、MySQL进入只读模式" class="headerlink" title="二、MySQL进入只读模式"></a>二、MySQL进入只读模式</h3><p>这个问题还是在Apache的错误日志中查到的。这个问题也可能是造成WordPress登录循环的原因。</p><p>由于未开启general_log所以没办法追踪开启read_only的原因。genenral log用来记录数据库运行期间所有成功和未成功的操作。可以修改配置文档，而在我使用MySQL 5.7版本就可以通过修改general_log 和general_log_file这两个变量值，在运行状态下开启日志。不过官方文档里提醒到，说这类日志是一个性能杀手。</p><p>2017.07.18 更新</p><p>目前已确定WordPress 登录页面循环跳转问题所在：</p><p>原因-&gt;mysql 处于 read_only 状态导致 登录时操作无法更新数据，造成循环跳转问题。（具体是自己在实验主从复制的时候，设置了从库自启动 read_only ）</p><hr><h3 id="三、Apache-为正确配置参数导致进程过多"><a href="#三、Apache-为正确配置参数导致进程过多" class="headerlink" title="三、Apache 为正确配置参数导致进程过多"></a>三、Apache 为正确配置参数导致进程过多</h3><p>Apache2.4版本下默认开启的多处理模块mpm 是prefork，而其中的一些配置参数的默认值可能不适合像我这样配置低的服务器。（顺便吐槽下Apache官方文档那让人无语的某些滞后）</p><p>prefork官方文档 <a href="http://httpd.apache.org/docs/2.4/mod/prefork.html" target="_blank" rel="noopener">http://httpd.apache.org/docs/2.4/mod/prefork.html</a></p><p>prefock 中文翻译文档 <a href="http://www.t086.com/code/apache2.2/mod/prefork.html" target="_blank" rel="noopener">http://www.t086.com/code/apache2.2/mod/prefork.html</a></p><p>其中的如下两个参数需要调整以适用于低配置服务器，当然你若有兴趣也可以按照文档修改成适合的配置。本人Apache 2.4 直接在apache.conf 修改（没什么httpd.conf）</p><blockquote><p>&lt;IfModule mpm_prefork_module&gt;</p><p>StartService   5          初始化子进程数</p><p>MaxClients      20       最大连接数</p><p>MaxSpareServers   6 空闲子进程最大数 默认值10</p><p>MinSpareServers    3 空闲子进程最小数 默认值5</p><p>MaxRequestsPerChild 500 子进程存在期间总共处理的最大请求数默认0为子进程不自动注销</p><p>&lt;/IfModule&gt;</p><p>&nbsp;<br>最后对于垃圾评论，正考虑尝试一些评论插件，也正在找好看的分享插件。欢迎分享 XD</p></blockquote><p>最近在 Leetcode上刷一些题目，接下来也会写一些关于编程算法的博文。推荐喜欢编程或者即将面对招聘的童鞋们也试试。</p><p>颓废了两周，得振作起来了 ^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自端午放假后，因为发生的一些事情已有两周没管管博客了，今天上来一看发现各种问题。先是WordPress不知怎么抽风，导致登录循环跳转（以前改好过现在又犯了）；然后看Apache 日中发现一对报错，MySQL莫名的进入只读模式；登上博客又看到一堆的垃圾评论，删除都费了一会功夫。哎，杂草丛生喽！
    
    </summary>
    
      <category term="随笔" scheme="http://zhongm.in/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Apache" scheme="http://zhongm.in/tags/Apache/"/>
    
      <category term="MySQL" scheme="http://zhongm.in/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis接触过程的两个小坑</title>
    <link href="http://zhongm.in/2017/05/18/redis-notes/"/>
    <id>http://zhongm.in/2017/05/18/redis-notes/</id>
    <published>2017-05-18T15:40:14.000Z</published>
    <updated>2019-07-13T14:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最为高效的键值对存储数据库，redis应用广泛，各大主流的编程语言对其的支持都很好。今天来说说，接触过程的小坑。</p><p><img src="/images/2017/05/redis.jpg" alt></p><p>&nbsp;</p><a id="more"></a><h2 id="1、响应格式均为byte"><a href="#1、响应格式均为byte" class="headerlink" title="1、响应格式均为byte"></a>1、响应格式均为byte</h2><p>在使用Python3进行redis数据库操作时，发现存进redis的数据，取出时不管是key 、各种value 格式均是byte 。这很让人难受，不过查看官方文档后，发现其中的redis 模块中的Redis()（包括StrictRedis()）方法，其中的<code>decode_responses</code> 参数默认为False 。只须在生成类的方法参数中将其设置为True即可。</p><pre class="lang:python decode:true " title="redis_setting">redis.StrictRedis(host=db_host, port=db_port, password=db_password, decode_responses=True)</pre><h2 id="2、关于Redis、StrictRedis两个类"><a href="#2、关于Redis、StrictRedis两个类" class="headerlink" title="2、关于Redis、StrictRedis两个类"></a>2、关于Redis、StrictRedis两个类</h2><p>两者都是用于实现Redis命令的，只不过官方文档中说明Redis类是向后兼容旧版本的。听起来没什么大不了的差别好像。。</p><p>不过其实两者的差别还是有的，使用时官方推荐StrictRedis。</p><p>差别有如下：</p><ul><li>LREM：参数 ‘num’ 和 ‘value’ 的顺序交换了一下，cli是 lrem queueName 0 ‘string’ 。  这里的0时所有的意思。 但是Redis这个类，把控制和string调换了。</li><li>ZADD：实现时 score 和 value 的顺序不小心弄反了，后来有人用了，就这样了</li><li>SETEX: time 和 value 的顺序反了</li></ul><h2 id="3、这个也不算坑，一个小记"><a href="#3、这个也不算坑，一个小记" class="headerlink" title="3、这个也不算坑，一个小记"></a>3、这个也不算坑，一个小记</h2><p><img src="/images/2017/05/Lua_Error.png" alt></p><p>编译安装Lua环境时，碰到一个报错。面向搜索引擎解决问题后找到出错点</p><pre class="lang:sh decode:true" title="readline">sudo apt-get install libreadline-dev</pre><p>———————————-Fighting———————————</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最为高效的键值对存储数据库，redis应用广泛，各大主流的编程语言对其的支持都很好。今天来说说，接触过程的小坑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2017/05/redis.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
    
    </summary>
    
      <category term="DataBase" scheme="http://zhongm.in/categories/DataBase/"/>
    
      <category term="Python" scheme="http://zhongm.in/categories/DataBase/Python/"/>
    
    
      <category term="Ubuntu" scheme="http://zhongm.in/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>C词法分析器的Python简单实现</title>
    <link href="http://zhongm.in/2017/05/18/C-Lexical-Analyzer-ImplementBy-Python/"/>
    <id>http://zhongm.in/2017/05/18/C-Lexical-Analyzer-ImplementBy-Python/</id>
    <published>2017-05-18T15:13:04.000Z</published>
    <updated>2019-07-13T13:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习编译原理的课程设计中，需要设计一个词法分许程序。于是尝试用Python来简单实现C语言词法分析器。其中其实并没有什么具体需要克服的难处，只要将部分的词法分析DFA设计好，实现起来思路便更清晰。</p><p><img src="/images/2017/05/DFA.jpg" alt></p><p>&nbsp;</p><a id="more"></a><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>C语言中我们需要提取出关键字，标识符，分隔符，运算符，不同数据类型的常量。其中标识符、标识符及分隔符的提取更简单，而运算符因为各运算符组合具有不同意义需详细分解，例如：&gt;&gt;、&gt;=、&gt;&gt;=，常量更是最让人头疼的，例如：整型 八进制 00123u 十六进制 0x23fflu 、浮点型 123.434f 指数型 0123e-002。</p><p>词法分析器还需要能显示出行数、检测出出错位置，并跳过错误继续分析。另外我们还需要对单行注释、多行注释进行跳过，以及跳过暂时不能处理的宏定义、预编译。</p><h2 id="2、部分有穷状态自动机实现"><a href="#2、部分有穷状态自动机实现" class="headerlink" title="2、部分有穷状态自动机实现"></a>2、部分有穷状态自动机实现</h2><h3 id="2-1、关键字及标识符"><a href="#2-1、关键字及标识符" class="headerlink" title="2.1、关键字及标识符"></a>2.1、关键字及标识符</h3><pre class="lang:python decode:true" title="Analyzer_keyword">if prog[flag].isalpha() or prog[flag]==r'_':#_字母开头 标识符和关键字            tmp=flag            while prog[flag].isalnum() or prog[flag]==r'_':flag+=1            #走到符合条件的最右边            fragment=str(reduce(lambda x,y:x+y,prog[tmp:flag]))            if fragment in keyword:#判断为关键字，keyword为关键字list                print("&lt; "+fragment+",- &gt;",end=' ')            else:#判断为标识符                print("&lt; IDENTIFY,"+fragment+" &gt;",end=' ')</pre><h3 id="2-2、数字（最复杂的一个）"><a href="#2-2、数字（最复杂的一个）" class="headerlink" title="2.2、数字（最复杂的一个）"></a>2.2、数字（最复杂的一个）</h3><pre class="lang:python decode:true" title="Analyzer_Num">#prog 待分析串 flag标记当前位置 line当前行 befspace上一个换行位置#skip(prog,flag) 出错后跳过无效字符elif prog[flag].isdigit():#判断数字常量    if prog[flag] == '0':#当开始字符为0        if prog[flag+1].lower()=='x':#0x开头为十六进制            flag+=2            tmp=flag            while prog[flag].isdigit() or \                    (prog[flag].lower()&gt;='a' and prog[flag].lower()&lt;='f'): #判断十六进制                flag+=1            numch=str(reduce(lambda x,y:x+y,prog[tmp:flag]))#拼接十六进制数字            num = str(int(numch, 16))#拼接为十进制数字            if prog[flag].lower()=='u' :#判断是否有符号、长整，当前flag指向十六进制后一位                if prog[flag+1].lower()=='l':#0x23ul                    if prog[flag + 2].isalnum():#0x23uls报错，并跳过                        print("&lt;ERROR,INT_UN_LONG_DEFINE,LINE "+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                        flag += 3                        flag = skip(prog, flag)                    else:                        print("&lt; INT_UN_LONG,"+num+" &gt;",end=' ')                        flag+=2                elif prog[flag+1].isalnum():#0x23u2出错                    print("&lt;ERROR,INT_UN_DEFINE,LINE "+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                    flag += 1                    flag=skip(prog,flag)                else:                    print("&lt; INT_UN,"+num+" &gt;",end=' ')#                    flag+=1            elif prog[flag].lower()=='l':#同上                if prog[flag+1].lower()=='u':                    if prog[flag + 2].isalnum():                        print("&lt; ERROR,INT_UN_LONG_DEFINE ,LINE "+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                        flag += 3                        flag = skip(prog, flag)                    else:                        print("&lt; INT_UN_LONG,"+num+" &gt;",end=' ')                        flag+=2                elif prog[flag+1].isalnum():                    print("&lt; ERROR,INT_LONG_DEFINE,LINE "+str(line)+str(flag-befspace)+" &gt;", end=' ')                    flag += 1                    flag = skip(prog, flag)                else:                    print("&lt; INT_LONG,"+num+" &gt;",end=' ')                    flag+=1            elif prog[flag].isalpha():#十六进制后接字符则报错                print("&lt; ERROR,INT_DEFINE,LINE "+str(line)+" "+str(flag-befspace)+" &gt;",end=' ')                flag+=1                flag = skip(prog, flag)            else:                print("&lt; INT," + num + " &gt;", end=' ')            pass        elif prog[flag+1]=='.':#0.开头为浮点数            tmp=flag            flag+=2            haspro=False#是否有+、-、e            hasneg=False            haseE=False            while prog[flag].isdigit() or prog[flag].lower()=='e' or prog[flag]=='-' or prog[flag]=='+':                if (prog[flag]=='+' or prog[flag]=='-') and not haseE:break#需满足一些条件                elif (prog[flag] == '+' or prog[flag] == '-') and (haspro or hasneg):break                elif (prog[flag]=='+' or prog[flag]=='-') and haseE:                    if prog[flag-1].lower()!='e':break                    else:                        if prog[flag]=='+':haspro=True                        else:hasneg=True                elif prog[flag].lower()=='e' and haseE:break                elif prog[flag]=='+':haspro=True                elif prog[flag] =='-':hasneg = True                elif prog[flag].lower()=='e':haseE=True                flag+=1            befpron=str(reduce(lambda x,y:x+y,prog[tmp:flag]))#拼接            findpro=befpron.find('+')            findneg=befpron.find('-')            findeE=befpron.lower().find('e')            IsFLOAT=False            IsERROR=False            theskip=flag            if prog[flag].lower()=='f':#0.23e+002f浮点数声明判断                if prog[flag+1].isalnum():#0.23e+002f3报错                    print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag+1- befspace) + " &gt;",                          end=' ')                    IsERROR=True                    flag = skip(prog, flag+2)                else:                    IsFLOAT=True                    theskip=flag+1            elif prog[flag].isalnum():#同上                print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag-befspace) + " &gt;",                      end=' ')                IsERROR = True                flag = skip(prog, flag+1)            if not IsERROR:                if (hasneg or haspro) and haseE:#有符号指数型                    pos=(findpro if haspro&gt;hasneg else findneg)                    if pos!=flag-tmp-1:#处理e+23                        suffix=int(reduce(lambda x,y:str(int(x)*10+int(y)),befpron[pos+1:]))                        suffix=suffix if haspro else -suffix                        num=str(float(str(reduce(lambda x,y:x+y,befpron[0:findeE])))*10**suffix)                        if IsFLOAT:                            print("&lt; FLOAT," + num + " &gt;", end=' ')                            flag=theskip                        else:print("&lt; DOUBLE," + num + " &gt;", end=' ')                    else:#0.12e+报错                        print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                              end=' ')                        flag = skip(prog, flag)                elif haseE and not (haspro or hasneg):#无符号指数e                    if findeE!=flag-tmp-1:                        suffix = int(str(reduce(lambda x, y: x + y, befpron[findeE+1:])))                        num = str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE])))                                  * 10 ** suffix)                        if IsFLOAT:                            print("&lt; FLOAT," + num + " &gt;", end=' ')                            flag=theskip                        else:print("&lt; DOUBLE," + num + " &gt;", end=' ')                    else:                        print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                              end=' ')                        flag = skip(prog, flag)                    pass                else:#单纯的浮点数0.23                    num=str(float(befpron))                    if IsFLOAT:                        print("&lt; FLOAT," + num + " &gt;", end=' ')                        flag = theskip                    else:                        print("&lt; DOUBLE," + num + " &gt;", end=' ')        elif prog[flag+1].isdigit():#浮点数和八进制均有可能            tmp=flag            flag+=2            haspoint=False#是否有小数点、符号、指数            haseE=False            haspro=False            hasneg=False            while prog[flag].isdigit() or prog[flag].lower()=='e' or prog[flag]=='-' or prog[flag]=='+' or prog[flag]=='.':                if (prog[flag]=='+' or prog[flag]=='-') and not haseE:break#需满足的一些条件                elif (prog[flag] == '+' or prog[flag] == '-') and (haspro or hasneg):                    break                elif (prog[flag]=='+' or prog[flag]=='-') and haseE:                    if prog[flag-1].lower()!='e':break                    else:                        if prog[flag]=='+':haspro=True                        else:hasneg=True                elif (haseE or haspoint) and prog[flag]=='.':break                elif prog[flag].lower() == 'e' and haseE:break                elif prog[flag]=='.' and haspoint:break                elif prog[flag] == '+' :haspro = True                elif prog[flag] == '-':hasneg = True                elif prog[flag].lower() == 'e' :haseE = True                elif prog[flag]=='.' :haspoint=True                flag+=1            befpron = str(reduce(lambda x, y: x + y, prog[tmp:flag]))#拼接            findpro = befpron.find('+')            findneg = befpron.find('-')            findeE = befpron.lower().find('e')            findpoint = befpron.find('.')            IsFLOAT = False            IsERROR = False            theskip = flag            if (haspoint or haseE) and prog[flag].lower() == 'f':#同上                if prog[flag + 1].isalnum():                    print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag + 1 - befspace) + " &gt;",                          end=' ')                    IsERROR = True                    flag = skip(prog, flag + 2)                else:                    IsFLOAT = True                    theskip = flag + 1            elif prog[flag].isalnum():                print("&lt; ERROR,NUM_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                      end=' ')                IsERROR = True                flag = skip(prog, flag + 1)            if not IsERROR:                if haseE and (haspro or hasneg):                    pos = (findpro if haspro &gt; hasneg else findneg)                    if pos != flag - tmp - 1:  # 处理e+23                        suffix = int(reduce(lambda x, y: str(int(x) * 10 + int(y)), befpron[pos + 1:]))                        suffix = suffix if haspro else -suffix                        num = str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE]))) * 10 ** suffix)                        if IsFLOAT:                            print("&lt; FLOAT," + num + " &gt;", end=' ')                            flag=theskip                        else:print("&lt; DOUBLE," + num + " &gt;", end=' ')                    else:  # 0.12e+报错                        print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                              end=' ')                        flag = skip(prog, flag)                elif haseE :                    if haseE!=flag-tmp-1:                        suffix = int(str(reduce(lambda x, y: x + y, befpron[findeE + 1:])))                        num=str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE])))*10**suffix)                        if IsFLOAT:                            print("&lt; FLOAT," + num + " &gt;", end=' ')                            flag=theskip                        else:print("&lt; DOUBLE," + num + " &gt;", end=' ')                    else:                        print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                              end=' ')                        flag = skip(prog, flag)                elif haspoint:                    if IsFLOAT:                        print("&lt; FLOAT," + str(float(befpron)) + " &gt;", end=' ')                        flag = theskip                    else:                        print("&lt; DOUBLE," + str(float(befpron)) + " &gt;", end=' ')                else:                    isoctal=True                    for char in befpron:                        if int(char)&gt;=8:isoctal=False                    if not isoctal:                        print("&lt; ERROR,OCTAL_OUTOFRANG,LINE"+str(line)+" "+str(flag-befspace)+" &gt;",end=' ')                    else:                        print("&lt; INT,"+str(int(befpron,8))+"&gt;" ,end=' ')        elif prog[flag+1] in operetor or prog[flag+1] in delimiter:#简单的0            print("&lt; INT,0 &gt;",end=' ')            flag+=1        else:#其他字母或符号抛异常            flag+=2            print("&lt; ERROR,NUM_DEFINE,LINE"+str(line)+" "+str(flag-befspace)+" &gt;",end=' ')    else:#非0开头可为浮点数或整数        haspoint=False#同上        haseE=False        haspro = False        hasneg = False        tmp=flag        while prog[flag].isdigit() or prog[flag].lower() == 'e' or prog[flag] == '-' or prog[flag] == '+' or \                        prog[flag] == '.':            if (prog[flag] == '+' or prog[flag] == '-') and not haseE:break            elif (prog[flag] == '+' or prog[flag] == '-') and (haspro or hasneg):break            elif (prog[flag] == '+' or prog[flag] == '-') and haseE:                if prog[flag - 1].lower() != 'e':                    break                else:                    if prog[flag] == '+':                        haspro = True                    else:                        hasneg = True            elif (haseE or haspoint) and prog[flag] == '.':break            elif prog[flag].lower() == 'e' and haseE:break            elif prog[flag] == '.' and haspoint:break            elif prog[flag] == '+':                haspro = True            elif prog[flag] == '-':                hasneg = True            elif prog[flag].lower() == 'e':                haseE = True            elif prog[flag] == '.':                haspoint = True            flag += 1        befpron = str(reduce(lambda x, y: x + y, prog[tmp:flag]))        findpro = befpron.find('+')        findneg = befpron.find('-')        findeE = befpron.lower().find('e')        findpoint = befpron.find('.')        IsFLOAT = False        IsERROR = False        theskip = flag        if (haspoint or haseE) and prog[flag].lower() == 'f':            if prog[flag + 1].isalnum():                print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag + 1 - befspace) + " &gt;",                      end=' ')                IsERROR = True                flag = skip(prog, flag + 2)            else:                IsFLOAT = True                theskip = flag + 1        elif prog[flag].isalnum():            print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                  end=' ')            IsERROR = True            flag = skip(prog, flag + 1)        if not IsERROR:            if haseE and (haspro or hasneg):#有符号指数型                pos = (findpro if haspro &gt; hasneg else findneg)                if pos != flag - tmp - 1:  # 处理e+23                    suffix = int(reduce(lambda x, y: str(int(x) * 10 + int(y)), befpron[pos + 1:]))                    suffix = suffix if haspro else -suffix                    num = str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE]))) * 10 ** suffix)                    if IsFLOAT:                        print("&lt; FLOAT," + num + " &gt;", end=' ')                        flag = theskip                    else:                        print("&lt; DOUBLE," + num + " &gt;", end=' ')                else:  # 0.12e+报错                    print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                          end=' ')                    flag = skip(prog, flag)            elif haseE :#指数型浮点数                if haseE != flag - tmp - 1:                    suffix = int(str(reduce(lambda x, y: x + y, befpron[findeE + 1:])))                    num = str(float(str(reduce(lambda x, y: x + y, befpron[0:findeE]))) * 10 ** suffix)                    if IsFLOAT:                        print("&lt; FLOAT," + num + " &gt;", end=' ')                        flag = theskip                    else:                        print("&lt; DOUBLE," + num + " &gt;", end=' ')                else:                    print("&lt; ERROR,FLOAT_DEFINE,LINE " + str(line) + " " + str(flag - befspace) + " &gt;",                          end=' ')                    flag = skip(prog, flag)            elif haspoint:#小数点浮点数                if IsFLOAT:                    print("&lt; FLOAT," + str(float(befpron)) + " &gt;", end=' ')                    flag = theskip                else:                    print("&lt; DOUBLE," + str(float(befpron)) + " &gt;", end=' ')            else:#纯整数                num = str(int(befpron))                if prog[flag].lower() == 'u':                    if prog[flag + 1].lower() == 'l':                        if prog[flag + 2].isalnum():                            print("&lt;ERROR,INT_UN_LONG_DEFINE,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                            flag += 3                            flag = skip(prog, flag)                        else:                            print("&lt;INT_UN_LONG," + num + "&gt;", end=' ')                            flag += 2                    elif prog[flag + 1].isalnum():                        print("&lt; ERROR,INT_LONG_DEFINE ,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                        flag += 1                        flag = skip(prog, flag)                    else:                        print("&lt;INT_UN," + num + "&gt;", end=' ')                elif prog[flag].lower() == 'l':                    if prog[flag + 1].lower() == 'u':                        if prog[flag + 2].isalnum():                            print("&lt; ERROR,INT_UN_LONG_DEFINE ,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                            flag += 3                            flag = skip(prog, flag)                        else:                            print("&lt; INT_UN_LONG," + num + "&gt;", end=' ')                            flag += 2                    elif prog[flag + 1].isalnum():                        print("&lt; ERROR,INT_LONG_DEFINE ,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                        flag += 1                        flag = skip(prog, flag)                    else:                        print("&lt; INT_LONG," + num + " &gt;", end=' ')                elif prog[flag].isalpha():                    print("&lt; ERROR,INT_DEFINE,LINE"+str(line)+" "+str(flag-befspace)+" &gt;", end=' ')                    flag = skip(prog, flag)                else:            print("&lt; INT," + num + " &gt;", end=' ')</pre><p>边上也有同学想用Python 的正则表达式，直接将符合前言中的那几种分别表示出来，进行直接匹配。但是其中还是有些复杂的结构无法表示，并且容易出误判，而无法显示出错位置。</p><p>不得不说其实不少代码冗余，本文全部的代码实现，欢迎拍砖 <a href="https://github.com/single-wolf/show-me-the-code/blob/master/analyzer.py" target="_blank" rel="noopener">https://github.com/single-wolf/show-me-the-code/blob/master/analyzer.py</a></p><p>最近也喜欢上Python ，分享个练手的有趣东西 <a href="https://github.com/Show-Me-the-Code/show-me-the-code" target="_blank" rel="noopener">https://github.com/Show-Me-the-Code/show-me-the-code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习编译原理的课程设计中，需要设计一个词法分许程序。于是尝试用Python来简单实现C语言词法分析器。其中其实并没有什么具体需要克服的难处，只要将部分的词法分析DFA设计好，实现起来思路便更清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2017/05/DFA.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://zhongm.in/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL 加锁处理</title>
    <link href="http://zhongm.in/2017/05/05/Lock-In-MySQL/"/>
    <id>http://zhongm.in/2017/05/05/Lock-In-MySQL/</id>
    <published>2017-05-04T23:54:59.000Z</published>
    <updated>2019-07-13T14:01:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一篇详细、较全面的MySQL InnoDB加锁介绍，虽然年代略旧不过其中基本锁的机制还是没变的。</p><p>MySQL/InnoDB的加锁分析，一直是一个比较困难的话题。本文，准备就MySQL/InnoDB的加锁问题，展开较为深入的分析与讨论，主要是介绍一种思路，运用此思路，拿到任何一条SQL语句，都能完整的分析出这条语句会加什么锁？会有什么样的使用风险？甚至是分析线上的一个死锁场景，了解死锁产生的原因。</p><p><strong>注：</strong>MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</p><a id="more"></a><blockquote><p>全文转载自 <a href="http://hedengcheng.com/" target="_blank" rel="noopener">何登成的技术博客</a> <a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></p><p>详尽的各语句加锁情况 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html" target="_blank" rel="noopener">Locks Set by Different SQL Statements in InnoDB</a></p></blockquote><ul><li><strong>MVCC**</strong>：Snapshot Read vs Current Read**<br>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (<a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">Multi-Version Concurrency Control</a>) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</li></ul><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><p>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p><ul><li><p><strong>快照读：</strong>简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)</p><ul><li>select * from table where ?;</li></ul></li><li><p><strong>当前读：</strong>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p><ul><li>select * from table where ? lock in share mode;</li><li>select * from table where ? for update;</li><li>insert into table values (…);</li><li>update table set ? where ?;</li><li>delete from table where ?;<br>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</li></ul></li></ul><p>为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：</p><p><img src="/images/2017/05/MySQL_Lock1.png" alt></p><p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p><p><strong>注</strong>：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕。</p><p>&nbsp;</p><ul><li><strong>Cluster Index**</strong>：聚簇索引**<br>InnoDB存储引擎的数据组织方式，是聚簇索引表：完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列。关于聚簇索引表的组织方式，可以参考MySQL的官方文档：<a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-index-types.html" target="_blank" rel="noopener">Clustered and Secondary Indexes</a> 。本文假设读者对这个，已经有了一定的认识，就不再做具体的介绍。接下来的部分，主键索引/聚簇索引 两个名称，会有一些混用，望读者知晓。</li></ul><p>&nbsp;</p><ul><li><strong>2PL**</strong>：Two-Phase Locking**<br>传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：<a href="http://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener">Two-Phase Locking</a>。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。</li></ul><p><img src="/images/2017/05/MySQL_Lock2.png" alt></p><p>从上图可以看出，2PL就是将加锁/解锁分为两个完全不相交的阶段。加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。</p><p>&nbsp;</p><ul><li><strong>Isolation Level</strong><br>隔离级别：<a href="http://en.wikipedia.org/wiki/Isolation_%28database_systems%29" target="_blank" rel="noopener">Isolation Level</a>，也是RDBMS的一个关键特性。相信对数据库有所了解的朋友，对于4种隔离级别：Read Uncommited，Read Committed，Repeatable Read，Serializable，都有了深入的认识。本文不打算讨论数据库理论中，是如何定义这4种隔离级别的含义的，而是跟大家介绍一下MySQL/InnoDB是如何定义这4种隔离级别的。</li></ul><p>MySQL/InnoDB定义的4种隔离级别：</p><ul><li><p><strong>Read Uncommited</strong><br>可以读取未提交记录。此隔离级别，不会使用，忽略。</p></li><li><p><strong>Read Committed (RC)</strong><br>快照读忽略，本文不考虑。</p></li></ul><p>针对当前读，<strong>RC隔离级别保证对读取到的记录加锁 (记录锁)</strong>，存在幻读现象。</p><ul><li><strong>Repeatable Read (RR)</strong><br>快照读忽略，本文不考虑。</li></ul><p>针对当前读，<strong>RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)</strong>，不存在幻读现象。</p><ul><li><strong>Serializable</strong><br>从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。</li></ul><p>Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。</p><p>&nbsp;</p><ul><li><strong>一条简单SQL的加锁实现分析</strong><br>在介绍完一些背景知识之后，本文接下来将选择几个有代表性的例子，来详细分析MySQL的加锁处理。当然，还是从最简单的例子说起。经常有朋友发给我一个SQL，然后问我，这个SQL加什么锁？就如同下面两条简单的SQL，他们加什么锁？</li></ul><p>&nbsp;</p><ul><li><strong>SQL1**</strong>：**select * from t1 where id = 10;</li><li><strong>SQL2**</strong>：**delete from t1 where id = 10;<br>&nbsp;</li></ul><p>针对这个问题，该怎么回答？我能想象到的一个答案是：</p><ul><li><p><strong>SQL1**</strong>：**不加锁。因为MySQL是使用多版本并发控制的，读不加锁。</p></li><li><p><strong>SQL2**</strong>：**对id = 10的记录加写锁 (走主键索引)。<br>这个答案对吗？说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。如果让我来回答这个问题，我必须还要知道以下的一些前提，前提不同，我能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？</p></li><li><p><strong>前提一：</strong>id列是不是主键？</p></li><li><p><strong>前提二：</strong>当前系统的隔离级别是什么？</p></li><li><p><strong>前提三：</strong>id列如果不是主键，那么id列上有索引吗？</p></li><li><p><strong>前提四：</strong>id列上如果有二级索引，那么这个索引是唯一索引吗？</p></li><li><p><strong>前提五：</strong>两个SQL的执行计划是什么？索引扫描？全表扫描？<br>&nbsp;</p></li></ul><p>没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？</p><p>&nbsp;</p><p><strong>注：</strong>下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。</p><p>&nbsp;</p><ul><li><strong>组合一**</strong>：**id列是主键，RC隔离级别</li><li><strong>组合二**</strong>：**id列是二级唯一索引，RC隔离级别</li><li><strong>组合三**</strong>：**id列是二级非唯一索引，RC隔离级别</li><li><strong>组合四**</strong>：**id列上没有索引，RC隔离级别</li><li><strong>组合五**</strong>：**id列是主键，RR隔离级别</li><li><strong>组合六**</strong>：**id列是二级唯一索引，RR隔离级别</li><li><strong>组合七**</strong>：**id列是二级非唯一索引，RR隔离级别</li><li><strong>组合八**</strong>：**id列上没有索引，RR隔离级别</li><li><strong>组合九**</strong>：**Serializable隔离级别<br>&nbsp;</li></ul><p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。</p><p>&nbsp;</p><p>注：在前面八种组合下，也就是RC，RR隔离级别下，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了，主要讨论SQL2：delete操作的加锁。</p><p>&nbsp;</p><p><strong>组合一：id主键+RC</strong></p><p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：</p><p><img src="/images/2017/05/MySQL_Lock3.png" alt></p><p><strong>结论：</strong>id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</p><p>&nbsp;</p><p><strong>组合二：id唯一索引+RC</strong></p><p>这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：</p><p><img src="/images/2017/05/MySQL_Lock4.png" alt></p><p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><p>&nbsp;</p><p><strong>结论</strong>：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</p><p>&nbsp;</p><p><strong>组合三：id非唯一索引+RC</strong></p><p>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：</p><p><img src="/images/2017/05/MySQL_Lock5.png" alt></p><p>根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p><p>&nbsp;</p><p><strong>结论</strong>：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p><p>&nbsp;</p><p><strong>组合四：id无索引+RC</strong></p><p>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：</p><p><img src="/images/2017/05/MySQL_Lock6.png" alt></p><p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p><p>&nbsp;</p><p>有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。</p><p>&nbsp;</p><p>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p><p>&nbsp;</p><p><strong>结论：</strong>若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</p><p>&nbsp;</p><p><strong>组合五：id主键+RR</strong></p><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。</p><p>&nbsp;</p><p>组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%B8%80%EF%BC%9Aid%E4%B8%BB%E9%94%AE+RC" target="_blank" rel="noopener">id主键，Read Committed</a>]一致。</p><p>&nbsp;</p><p><strong>组合六：id唯一索引+RR</strong></p><p>与组合五类似，组合六的加锁，与组合二：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%BA%8C%EF%BC%9Aid%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id唯一索引，Read Committed</a>]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p><p>&nbsp;</p><p><strong>组合七：id非唯一索引+RR</strong></p><p>还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，如何防止幻读呢？问题的答案，就在组合七中揭晓。</p><p>&nbsp;</p><p>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p><p><img src="/images/2017/05/MySQL_Lock7.png" alt></p><p>此图，相对于组合三：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%B8%89%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id列上非唯一锁，Read Committed</a>]看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？</p><p>&nbsp;</p><p>其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p><p>&nbsp;</p><p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p><p>&nbsp;</p><p>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p><p>&nbsp;</p><p>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p><p>&nbsp;</p><p>有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？</p><p>&nbsp;</p><p>首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。</p><p>&nbsp;</p><p><strong>结论：</strong>Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p><p>&nbsp;</p><p><strong>组合八：id无索引+RR</strong></p><p>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p><p><img src="/images/2017/05/MySQL_Lock8.png" alt></p><p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p><p>&nbsp;</p><p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p><p>&nbsp;</p><p>当然，跟组合四：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E5%9B%9B%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id无索引, Read Committed</a>]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了 <a href="http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html" target="_blank" rel="noopener">innodb_locks_unsafe_for_binlog</a> 参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：<a href="http://hedengcheng.com/?p=220" target="_blank" rel="noopener">MySQL+InnoDB semi-consitent read原理及实现分析</a> 。</p><p>&nbsp;</p><p><strong>结论：</strong>在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p><p>&nbsp;</p><p><strong>组合九：Serializable</strong></p><p>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。</p><p>&nbsp;</p><p>Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。</p><p>&nbsp;</p><p><strong>结论：</strong>在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p><p>&nbsp;</p><ul><li><strong>一条复杂的SQL</strong><br>写到这里，其实MySQL的加锁实现也已经介绍的八八九九。只要将本文上面的分析思路，大部分的SQL，都能分析出其会加哪些锁。而这里，再来看一个稍微复杂点的SQL，用于说明MySQL加锁的另外一个逻辑。SQL用例如下：</li></ul><p><img src="/images/2017/05/MySQL_Lock9.png" alt></p><p>如图中的SQL，会加什么锁？假定在Repeatable Read隔离级别下 (Read Committed隔离级别下的加锁情况，留给读者分析。)，同时，假设SQL走的是idx_t1_pu索引。</p><p>&nbsp;</p><p>在详细分析这条SQL的加锁情况前，还需要有一个知识储备，那就是一个SQL中的where条件如何拆分？具体的介绍，建议阅读我之前的一篇文章：<a href="http://hedengcheng.com/?p=577" target="_blank" rel="noopener">SQL中的where条件，在数据库中提取与应用浅析</a> 。在这里，我直接给出分析后的结果：</p><p>&nbsp;</p><ul><li><strong>Index key**</strong>：**pubtime &gt; 1 and puptime &lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。</li><li><strong>Index Filter**</strong>：**userid = ‘hdc’ 。此条件，可以在idx_t1_pu索引上进行过滤，但不属于Index Key。</li><li><strong>Table Filter**</strong>：**comment is not NULL。此条件，在idx_t1_pu索引上无法过滤，只能在聚簇索引上过滤。<br>在分析出SQL where条件的构成之后，再来看看这条SQL的加锁情况 (RR隔离级别)，如下图所示：</li></ul><p><img src="/images/2017/05/MySQL_Lock10.png" alt></p><p>从图中可以看出，在Repeatable Read隔离级别下，由Index Key所确定的范围，被加上了GAP锁；Index Filter锁给定的条件 (userid = ‘hdc’)何时过滤，视MySQL的版本而定，在MySQL 5.6版本之前，不支持<a href="http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">Index Condition Pushdown</a>(ICP)，因此Index Filter在MySQL Server层过滤，在5.6后支持了Index Condition Pushdown，则在index上过滤。若不支持ICP，不满足Index Filter的记录，也需要加上记录X锁，若支持ICP，则不满足Index Filter的记录，无需加记录X锁 (图中，用红色箭头标出的X锁，是否要加，视是否支持ICP而定)；而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要X锁。最后，选取出了一条满足条件的记录[8,hdc,d,5,good]，但是加锁的数量，要远远大于满足条件的记录数量。</p><p>&nbsp;</p><p><strong>结论：</strong>在Repeatable Read隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。Index Key确定的范围，需要加上GAP锁；Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加X锁，否则需要X锁；Table Filter过滤条件，无论是否满足，都需要加X锁。</p><p>&nbsp;</p><ul><li><strong>死锁原理与分析</strong><br>本文前面的部分，基本上已经涵盖了MySQL/InnoDB所有的加锁规则。深入理解MySQL如何加锁，有两个比较重要的作用：</li></ul><p>&nbsp;</p><ul><li>可以根据MySQL的加锁规则，写出不会发生死锁的SQL；</li><li>可以根据MySQL的加锁规则，定位出线上产生死锁的原因；<br>下面，来看看两个死锁的例子 (一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁)：</li></ul><p><img src="/images/2017/05/MySQL_Lock11.png" alt></p><p><img src="/images/2017/05/MySQL_Lock12.png" alt></p><p>上面的两个死锁用例。第一个非常好理解，也是最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。</p><p>&nbsp;</p><p>第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p><p>&nbsp;</p><p><strong>结论：</strong>死锁的发生与否，并不在于事务中有多少条SQL语句，<strong>死锁的关键在于</strong>：两个(或以上)的Session<strong>加锁的顺序</strong>不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。</p><p>&nbsp;</p><p><strong>总结</strong></p><p>&nbsp;</p><p>写到这儿，本文也告一段落，做一个简单的总结，要做的完全掌握MySQL/InnoDB的加锁规则，甚至是其他任何数据库的加锁规则，需要具备以下的一些知识点：</p><p>&nbsp;</p><ul><li>了解数据库的一些基本理论知识：数据的存储格式 (堆组织表 vs 聚簇索引表)；并发控制协议 (MVCC vs Lock-Based CC)；Two-Phase Locking；数据库的隔离级别定义 (Isolation Level)；</li><li>了解SQL本身的执行计划 (主键扫描 vs 唯一键扫描 vs 范围扫描 vs 全表扫描)；</li><li>了解数据库本身的一些实现细节 (过滤条件提取；Index Condition Pushdown；Semi-Consistent Read)；</li><li>了解死锁产生的原因及分析的方法 (加锁顺序不一致；分析每个SQL的加锁顺序)<br>有了这些知识点，再加上适当的实战经验，全面掌控MySQL/InnoDB的加锁规则，当不在话下。<blockquote><p>以上转载自<a href="https://www.icerainwill.com" target="_blank" rel="noopener">你懂的越多，懂你的越少</a> » <a href="https://www.icerainwill.com/?p=663" target="_blank" rel="noopener">MySQL 加锁处理分析</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一篇详细、较全面的MySQL InnoDB加锁介绍，虽然年代略旧不过其中基本锁的机制还是没变的。&lt;/p&gt;
&lt;p&gt;MySQL/InnoDB的加锁分析，一直是一个比较困难的话题。本文，准备就MySQL/InnoDB的加锁问题，展开较为深入的分析与讨论，主要是介绍一种思路，运用此思路，拿到任何一条SQL语句，都能完整的分析出这条语句会加什么锁？会有什么样的使用风险？甚至是分析线上的一个死锁场景，了解死锁产生的原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="DataBase" scheme="http://zhongm.in/categories/DataBase/"/>
    
      <category term="转载" scheme="http://zhongm.in/categories/DataBase/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="MySQL" scheme="http://zhongm.in/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2017百度、腾讯春招笔试</title>
    <link href="http://zhongm.in/2017/05/03/2017-Interview-Baidu-And-Tecent/"/>
    <id>http://zhongm.in/2017/05/03/2017-Interview-Baidu-And-Tecent/</id>
    <published>2017-05-03T11:08:12.000Z</published>
    <updated>2017-09-29T11:27:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>在经历惨烈的春招后，还是回头看看，好好总结总结。还是需要多练习、多见识，锻炼自己的编程思想，这样在临场时思路更清晰、编码更稳健、排错更及时。</p><p>需要申明的是，下面都是自己的解题思路或者查询到的解题方法，不见得是最优解法，欢迎交流，指错扔砖。</p><a id="more"></a><h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="1、构造回文"><a href="#1、构造回文" class="headerlink" title="1、构造回文"></a>1、构造回文</h2><p>题目描述：给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。</p><p>输入例子：</p><blockquote><p>abcda</p><p>google<br>输出例子：<br>2</p><p>2<br>第一时间想到的是递归遍历出这个最长回文串，但是提交发现运行超时，输出描述上写着1&lt;=s.length&lt;=1000 ，看来确实很大。</p></blockquote><p>后来看讨论中给出一个思路：将求最长回文串问题转化为，求原字符串和其反串(即原字符串逆转)的最长公共子序列(不是子串，可不连续但是顺序一致)的长度，通过动态规划法即可简洁的写出。详尽的关于求最长公共子序列的动态规划算法可参考 万仓一黍 <a href="http://www.cnblogs.com/grenet/archive/2010/06/03/1750454.html" target="_blank" rel="noopener">http://www.cnblogs.com/grenet/archive/2010/06/03/1750454.html</a></p><pre class="lang:java mark:13-19 decode:true">import java.util.Scanner;public class Main{    public static void main(String args[]){        Scanner sc= new Scanner(System.in);        while(sc.hasNext()){            String input=sc.next();            int len=input.length();            int i,j;            char str[]=input.toCharArray();            int alth[][]=new int[len+1][len+1];            for(i=0;i&lt;=len;i++)                alth[0][i]=alth[i][0]=0;            for(i=1;i&lt;=len;i++)//动态规划                for(j=1;j&lt;=len;j++){                    if (str[j-1]==str[len-i])                        alth[i][j]=alth[i-1][j-1]+1;                    else                        alth[i][j]=Math.max(alth[i-1][j],alth[i][j-1]);                }            System.out.println(len-alth[len][len]);        }        sc.close();    }}</pre><h2 id="2、字符移位"><a href="#2、字符移位" class="headerlink" title="2、字符移位"></a>2、字符移位</h2><p>题目描述： 小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？</p><p>输入例子：</p><blockquote><p>AkleBiCeilD<br>输出例子：<br>kleieilABCD<br>题目中的不能申请额外空间一开始让我很迷惑，原来是指空间复杂度为O(1) 常数级而不是不能定义变量之类的。</p></blockquote><p>但是后来在java 实现中会发现：标准输入中只能等到String 对象，但是显然String 对字符操作不方便(当然你要是转空子直接遍历 、CharAt()判断、输出也能得到想要的输出)，在String 类的一些操作类中char [] 的一些方法 如：replace()、replaceAll() ，看似很简洁其实你查看java源码会发现其中使用了很多StringBuffer、StringBuilder，不符合空间复杂度。</p><p>所以建议用C、C++来编写，核心代码：</p><pre class="lang:c decode:true">do{    swap=0;same=0;//swap记录交换次数，name记录遇到大写相遇次数    for(int i=begin;i&lt;len-1;i++){//begin初始为0，标记下一次遍历开始点        if(str[i]&lt;'a'&amp;&amp;str[i+1]&gt;='a'){//遇到aA情况，交换        tmp=str[i];str[i]=str[i+1];str[i+1]=tmp;        swap++;    }    else if(str[i]&lt;'a'&amp;&amp;str[i+1]&lt;'a') {//遇到AA情况        same++ ;if(same==1) begin=i;    }    }}while(swap!=0&amp;&amp;same!=0);//两个记录中有一为0表明排序完成</pre><h2 id="3、有趣的数字"><a href="#3、有趣的数字" class="headerlink" title="3、有趣的数字"></a>3、有趣的数字</h2><p>题目描述：：有n个数，两两组成二元组，差最小的有多少对呢？差最大呢？</p><p>输入描述：输入包含多组测试数据，对于每组测试数据：N - 本组测试数据有n个数，a1,a2…an - 需要计算的数据，1&lt;=N&lt;=100000,0&lt;=ai&lt;=INT_MAX.</p><p>输出描述：对每组，输出两个数，第一个数表示差最小的对数，第二个数表示差最大的对数。</p><p>输入例子：</p><blockquote><p>6</p><p>45 12 45 32 5 6<br>输出例子：<br>1  2<br>其中也没有什么特殊算法，咋一看感觉只需要n^2，不过时间复杂度太大。</p></blockquote><pre class="lang:default decode:true">    1.先排序        1.1.特殊情况：如果排完序之后发现数组中所有数都相同，直接输出结果             结果为：差最大个数 = 差最小个数 = （n * (n-1))/2;(两两组合)    2.统计数组中每种数字的个数（可用map）    3.计算差最小个数        3.1.如果数组中没有重复数字，说明最小差不为0，最小差肯定是数组中相邻两个数的差            因此，遍历一边数组，计算并统计最小差。        3.2.如果数组中有重复数字，说明最小差是0，此时，遍历一边map，数字个数不为0的            数字会产生最小差0，利用公式计算即可    4.计算差最大个数        只有一种情况，最大值与最小值的两两组合，即最大值个数 * 最小值个数    算法复杂度：排序O(nlogn), 统计O(n)    就是很细，有些情况容易忽略</pre><h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="1、回家"><a href="#1、回家" class="headerlink" title="1、回家"></a>1、回家</h2><p>题目描述：一个数轴上共有N个点，第一个点的坐标是度度熊现在位置，第N-1个点是度度熊的家。现在他需要依次的从0号坐标走到N-1号坐标。</p><p>但是除了0号坐标和N-1号坐标，他可以在其余的N-2个坐标中选出一个点，并直接将这个点忽略掉，问度度熊回家至少走多少距离？</p><p>输入例子：</p><blockquote><p>4</p><p>1 4 -1 3<br>输出例子：<br>4<br>求解是先找出那个需要直接忽略掉的坐标点，而判断一个点是不是最值得忽略，判断去除这个点后能让要走的距离减少最多。这样题目就很清晰了</p></blockquote><pre class="lang:java decode:true">    //当n为2或3，直接输出    if(n==2) System.out.println(Math.abs(pos[0]-pos[1]));    else if(n==3) System.out.println(Math.abs(pos[0]-pos[2]));    else{        int []log=new int[n-2];//记录中间坐标去除后可减少长度        for(i=1;i&lt;n-1;i++){            log[i-1]=Math.abs(pos[i]-pos[i-1])+Math.abs(pos[i+1]-pos[i])                    -Math.abs(pos[i+1]-pos[i-1]);//坐标i去除后减少的长度             if(log[i-1]&gt;log[max]) max=i-1;//记录最值得去除点         }         pos[max+1]=(pos[max]+pos[max+2])/2;//将最值得去除点改值，使不影响计算         for(i=1;i&lt;n;i++) sum+=Math.abs(pos[i]-pos[i-1]);//总路径         System.out.println(sum);    }</pre><h1 id="2、不等式数列"><a href="#2、不等式数列" class="headerlink" title="2、不等式数列"></a>2、不等式数列</h1><p>题目描述：对于1到n的一个排列，度度熊发现可以在中间根据大小关系插入合适的大于和小于符号(即 ‘&gt;’ 和 ‘&lt;’ )使其成为一个合法的不等式数列。但是现在手中只有k个小于符号即(‘&lt;’’)和n-k-1个大于符号(即’&gt;’)，想知道对于1至n任意的排列中有多少个排列可以使用这些符号使其为合法的不等式数列。</p><p>如n=3、k=1，则有3&gt;1&lt;2、2&gt;1&lt;3、1&lt;3&gt;2，1&lt;3&gt;2，满足条件的有4种</p><p>输入描述：</p><blockquote><p>包含两个整数n和k(k &lt; n ≤ 1000)<br>输出描述：<br>满足条件的排列数，对2017取模<br>解题思路：</p></blockquote><p>用dp[i][j]表示有 i 个数字及 j 个小于号所能组成的数量(大于号数量当然是i - j - 1 个)</p><p>归纳：在dp[i][j]的前提下，加入第 i+1 个数字即 i+1，分为四种情况</p><ol><li><p>如果将i+1插入当前序列的开头，即有了1&lt;2（或2&gt;1），加入后成为3&gt;1&lt;2，会发现等于同时加入了一个大于号！(此时可以无视1与2内部的关系，因为 i+1&gt;i )</p></li><li><p>如果将i+1插入当前序列末尾,即1&lt;2（或2&gt;1）变成了 1&lt;2&lt;3，会发现等于同时加入了一个小于号！ (此时可以无视1与2之间的关系，因为i+1&gt;i)</p></li><li><p>如果将i+1加入一个小于号之间，即已经有 1&lt;2了，向中间加入3,会发现变成了1&lt;3&gt;2，等于同时加入了一个大于号！</p></li><li><p>如果将i+1加入一个大于号中间，即有了2&gt;1，变成了2&lt;3&gt;1，等于同时加入了一个小于号！<br>则可知dp[i][j]的值等于上述值的和:</p></li><li><p>dp[i-1][j]—-只加了一个大于号及 i</p></li><li><p>dp[i - 1][j - 1] —-只加了一个小于号及 i</p></li><li><p>dp[i - 1][j] * j  —-在其中的每个小于号之间，加入 i 和大于号</p></li><li><p>dp[i - 1][j - 1] * (i- j - 1) —-在其中的每个大于号之间，加入 i 和小于号<br>可得 dp[i][j] = (dp[i - 1][j - 1] * (i - j) + dp[i - 1][j] * (j + 1)) 再对2017取模</p></li></ol><p>之后问题便迎刃而解。</p><pre class="lang:java decode:true">        int[][] dp = new int[n+1][k+1];          for (int i = 1; i &lt; n+1; i++)            dp[i][0] = 1;  //初始值全为1        for (int i = 2; i &lt; n+1; i++) {              for (int j = 1; j &lt;= k &amp;&amp; j &lt; i; j++) {                  dp[i][j] = (dp[i-1][j-1]*(i-j)+dp[i-1][j]*(j+1))%2017;              }          }</pre><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在经历惨烈的春招后，还是回头看看，好好总结总结。还是需要多练习、多见识，锻炼自己的编程思想，这样在临场时思路更清晰、编码更稳健、排错更及时。&lt;/p&gt;
&lt;p&gt;需要申明的是，下面都是自己的解题思路或者查询到的解题方法，不见得是最优解法，欢迎交流，指错扔砖。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://zhongm.in/categories/Java/"/>
    
      <category term="随笔" scheme="http://zhongm.in/categories/Java/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="算法" scheme="http://zhongm.in/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
